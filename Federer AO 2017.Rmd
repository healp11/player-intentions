---
title: "Tennis HMMs"
output: html_notebook
---

#Federer's Matches in Aus Open 2017

```{r loaddata}
setwd("~/Documents/Winter Project/intentions/data")
library(devtools)
#install()
load("/Users/Jeremy/Documents/Winter Project/intentions/data/federer2017.RData")

library(ggplot2)
library(tidyr)
library(dplyr)
library(readr)
```
Shaping and manipulating the data. Adding new variables.


```{r df}
fed_df <- federer2017

fed_df <- arrange(fed_df, matchid, set, game, point, shot)

#Reorienting shots so that all Federer's shot are from negative x side of court, and all opponents shots are from positive x side. y coordinates have been flipped as required.

#Federer
fed_df <- fed_df %>% rowwise %>%
  mutate(ballmark.x = ifelse(impact.player == "FEDERER" & start.x >= 0, -ballmark.x, ballmark.x)) %>%
  mutate(ballmark.y = ifelse(impact.player == "FEDERER" & start.x >= 0, -ballmark.y, ballmark.y)) %>%
  mutate(start.y = ifelse(impact.player == "FEDERER" & start.x >= 0, -start.y, start.y)) %>%
  mutate(final.x = ifelse(impact.player == "FEDERER" & start.x >= 0, -final.x, ballmark.x)) %>%
  mutate(final.y = ifelse(impact.player == "FEDERER" & start.x >= 0, -final.y, ballmark.y)) %>%
  mutate(start.x = ifelse(impact.player == "FEDERER" & start.x >= 0, -start.x, start.x))

#Opponents
fed_df <- fed_df %>% rowwise %>%
  mutate(start.y = ifelse(impact.player != "FEDERER" & start.x <= 0, -start.y, start.y)) %>%
  mutate(ballmark.x = ifelse(impact.player != "FEDERER" & start.x <= 0, -ballmark.x, ballmark.x)) %>%
  mutate(ballmark.y = ifelse(impact.player != "FEDERER" & start.x <= 0, -ballmark.y, ballmark.y)) %>%
  mutate(final.x = ifelse(impact.player != "FEDERER" & start.x <= 0, -final.x, ballmark.x)) %>%
  mutate(final.y = ifelse(impact.player != "FEDERER" & start.x <= 0, -final.y, ballmark.y)) %>%
  mutate(start.x = ifelse(impact.player != "FEDERER" & start.x <= 0, -start.x, start.x))


#Adding Vars

fed_df <- fed_df %>%
  mutate(lastshot = ifelse(shot == final.shot,1,0)) %>%
  mutate(isserver = ifelse(server == impact.player,1,0)) %>%
  mutate(fhand = ifelse(hitpoint == "F",1,0)) %>%
  mutate(opponent = ifelse(server == "FEDERER", receiver, server))

fed_df <- fed_df %>%
  mutate(winner = ifelse(ended.in.error == FALSE & lastshot == 1,1,0)) %>%
  mutate(retser = ifelse(shot == 2,1,0)) %>%
  mutate(retser1 = ifelse(shot == 2 & serve.classification == 1,1,0)) %>%
  mutate(retser2 = ifelse(shot == 2 & serve.classification == 2,1,0))

for (i in 1:ncol(fed_df)) {
  if(is.character(fed_df[,i]) == TRUE) {
    fed_df[,i] <- as.factor(fed_df[,i])
  }
}
```


```{r scores}
library(stringi)

ids <- fed_df$id
split.ids <- t(data.frame(stri_split_boundaries(ids, type="character")))

fed_df <- fed_df %>%
  plyr::mutate(server.points = split.ids[,1], receiver.points = split.ids[,2], server.games = split.ids[,3], receiver.games = split.ids[,4], server.sets = split.ids[,5], receiver.sets = split.ids[,6])

#Now mutate this to Federer score and opponent score
fed_df <- fed_df %>% rowwise %>%
  mutate(fed.points = ifelse(server == "FEDERER", as.numeric(server.points), as.numeric(receiver.points))) %>%
  mutate(fed.games = ifelse(server == "FEDERER", as.numeric(server.games), as.numeric(receiver.games))) %>%
  mutate(fed.sets = ifelse(server == "FEDERER", as.numeric(server.sets), as.numeric(receiver.sets))) %>%
  mutate(opp.points = ifelse(server == "FEDERER", as.numeric(receiver.points), as.numeric(server.points))) %>%
  mutate(opp.games = ifelse(server == "FEDERER", as.numeric(receiver.games), as.numeric(server.games))) %>%
  mutate(opp.sets = ifelse(server == "FEDERER", as.numeric(receiver.sets), as.numeric(server.sets)))

fed_df <- fed_df %>%
    mutate(sets.diff = fed.sets - opp.sets) %>%
    mutate(games.diff = fed.games - opp.games) %>%
    mutate(points.diff = fed.points - opp.points)
```


```{r newvars}
fed_df <- fed_df %>%
  mutate(speed.diff = NA) %>%
  mutate(oppo.hit.x = NA) %>%
  mutate(oppo.hit.y = NA) %>%
  mutate(oppo.hit.z = NA) %>%
  mutate(oppo.speed = NA) %>%
  mutate(oppo.ballmark.x = NA) %>%
  mutate(oppo.ballmark.y = NA) %>%
  mutate(speed.ratio = NA)

for (i in 2:nrow(fed_df)) {
  if(fed_df$shot[i] != 1) {#so that only non-serves are affected

  fed_df$speed.diff[i]=fed_df$speed1[i]-fed_df$speed1[i-1]
  #speed difference
  
  fed_df$oppo.hit.x[i]=fed_df$start.x[i-1]
  fed_df$oppo.hit.y[i]=fed_df$start.y[i-1]
  fed_df$oppo.hit.z[i]=fed_df$start.z[i-1]
  fed_df$oppo.speed[i]=fed_df$speed1[i-1]
  fed_df$oppo.ballmark.x[i]=fed_df$ballmark.x[i-1]
  fed_df$oppo.ballmark.y[i]=fed_df$ballmark.y[i-1]
  #oppo hit
  
  }
}

fed_df <- fed_df %>%
  mutate(speed.ratio = speed1/oppo.speed) %>% #speed ratio
  mutate(side.dist = 4.115 - abs(oppo.ballmark.y)) %>% #distance of oppo.ballmark from sideline
  mutate(base.dist = 11.89 - abs(oppo.ballmark.x)) %>% #distance of oppo.ballmark from baseline
  mutate(short.dist = min(side.dist, base.dist)) #shortest distance from any line


#Adding angles
fed_df <- fed_df %>%
  mutate(p.start.x = NA) %>%
  mutate(p.start.y = NA)

for (i in 3:nrow(fed_df)) {
  if(fed_df$impact.player[i] == fed_df$impact.player[i-2] & fed_df$shot[i] == fed_df$shot[i-2] + 2) {
    fed_df$p.start.x[i]=fed_df$start.x[i-2]
    fed_df$p.start.y[i]=fed_df$start.y[i-2]
  }
}

#adding angle between fed.shot-opp.shot vector and opp.shot-opp.ballmark vector
#doing it in one line because df doesn't want to add vectors
fed_df <- fed_df %>%
  mutate(o.angle = NA)
  
for (i in 1:nrow(fed_df)) {
  x1 <- fed_df$p.start.x[i]
  y1 <- fed_df$p.start.y[i]
  x2 <- fed_df$oppo.hit.x[i]
  y2 <- fed_df$oppo.hit.y[i]
  x3 <- fed_df$oppo.ballmark.x[i]
  y3 <- fed_df$oppo.ballmark.y[i]
  
  o.angle <- acos(
  ((c(x1,y1)-c(x2,y2))/sqrt((x1-x2)^2+(y1-y2)^2)) %*%
    ((c(x2,y2)-c(x3,y3))/sqrt((x2-x3)^2+(y2-y3)^2))) * 180/pi
  
  fed_df$o.angle[i] = ifelse(o.angle > 90, 180-o.angle, o.angle)
}

#Now adding the angle the player hits
fed_df <- fed_df %>%
  mutate(p.angle = NA)
  
for (i in 1:nrow(fed_df)) {
  x1 <- fed_df$oppo.hit.x[i]
  y1 <- fed_df$oppo.hit.y[i]
  x2 <- fed_df$start.x[i]
  y2 <- fed_df$start.y[i]
  x3 <- fed_df$ballmark.x[i]
  y3 <- fed_df$ballmark.y[i]
  
  p.angle <- acos(
  ((c(x1,y1)-c(x2,y2))/sqrt((x1-x2)^2+(y1-y2)^2)) %*%
    ((c(x2,y2)-c(x3,y3))/sqrt((x2-x3)^2+(y2-y3)^2))) * 180/pi
  
  fed_df$p.angle[i] = ifelse(p.angle > 90, 180-p.angle, p.angle)
}

fed_df <- fed_df %>%
  mutate(lag.p.angle = 0) %>%
  mutate(lag.speed.ratio = 0)

#Add p.angle and speed ratio of prior shot
for (i in 3:nrow(fed_df)) {
  fed_df$lag.p.angle[i] = ifelse(fed_df$impact.player[i]==fed_df$impact.player[i-2] & fed_df$shot[i] >= 4, fed_df$p.angle[i-2], 0)
  fed_df$lag.speed.ratio[i] = ifelse(fed_df$impact.player[i]==fed_df$impact.player[i-2] & fed_df$shot[i] >= 4, fed_df$speed.ratio[i-2], 0)
}
```

Glossary:
lastshot - last shot in the point
fedhit - federer hits the shot
isserver - if server hits the shot
winner - if shot is winner (i.e. point doesn't end in error, as opponent doesn't reach the ball)
retser - if shot is returning serve
retser1 - if shot is returning first serve
retser2 - if shot is returning second serve
speed.diff - difference in current shot speed vs opponents last shot speed (at impact)
speed.ratio - shot speed/opponent's previous shot speed
speed1 - speed of shot from impact with racquet
o.angle - angle made by opponents previous shot
p.angle - angle made by player's current shot
lag.p.angle - angle made by player's previous shot in rally
lag.speed.ratio - speed ratio of player's previous in rally
oppo.hit - coordinates of opponents previous impact
fed.points/games/sets - fed score up to current point
opp.points/games/sets - opponent score up to current point
points/games/sets.diff - difference in score from Federer's perspective


```{r noserves}
#remove opponents
fed_no.opp <- fed_df %>% 
  dplyr::filter(impact.player == "FEDERER")

#federer only - remove serves
fed_only <- fed_no.opp %>%
  filter(hitpoint != "S") %>%
  dplyr::select(-serveid)


#First remove any errors for start, ballmark, so that we are only looking at shots that we hit onto the other side
#To check: ggplot(fed_only, aes(ballmark.x, ballmark.y)) + geom_point()
fed_only <- fed_only %>%
  filter(oppo.hit.x >= 0) %>%
  filter(oppo.ballmark.x <= 0) %>%
  filter(ballmark.x >= 0)

#Adding shot number cumulative count (functions as time)
fed_only <- fed_only %>%
  mutate(count = 1)

  for (i in 2:nrow(fed_only)) {
    if(fed_only$matchid[i]==fed_only$matchid[i-1]) {
      fed_only$count[i] = fed_only$count[i-1] + 1
    }
  }
```


#Visualization - Before We Start Modelling

Here are a series of plots which give us an idea of how each variable affects hitting a winner.

Looking at these plots, we try to determine which variables may be used as response variables, meaning that they make up part of the state classification, or as a covariate, meaning they affect the likelihood of being in a state.

##Plots of shot and ballmark co-ordinates, angles made by shots and speed measures

```{r vis}
library(ggplot2)
#X Co-ordinate of shot
ggplot(fed_only, aes(x=start.x,winner)) + geom_smooth() + xlab("X Coordinate of Shot") + ylab("Proportion of Winners") + ggtitle("Winners By X Co-Ordinate")

#Opponents shot before
library(hexbin)
ggplot(fed_only, aes(x=oppo.hit.x,y=oppo.hit.y,z=winner)) + stat_summary_hex(fun = function(winner) sum(winner)) + xlab("X Coordinate of Oppo Shot") + ylab("Y Coordinate of Oppo Shot") + ggtitle("Count of Winners By Opponent's Shot Co-Ordinates")
### Get help transforming this to proportion in each bin instead of raw count

#Fed Shots on x-y plane
ggplot(fed_only, aes(x=start.x,y=start.y,z=winner)) + stat_summary_hex(fun = function(winner) sum(winner)) + xlab("X Coordinate") + ylab("Y Coordinate") + ggtitle("Winners By Shot Co-Ordinates")

#Fed Ballmark by winner in x-y plane
ggplot(fed_only, aes(x=ballmark.x,y=ballmark.y,z=winner)) + stat_summary_hex(fun = function(winner) sum(winner)) + xlab("X Coordinate") + ylab("Y Coordinate") + ggtitle("Winners By Shot Ballmark Co-Ordinates")


#Angle of shots
ggplot(fed_only, aes(x=o.angle,y=winner)) + geom_smooth() + xlab("Angle Made By Opponents Shot With Fed's Previous Shot") + ylab("Proportion of Winners") + ggtitle("Winners By Opponent Shot Angle")

ggplot(fed_only, aes(x=p.angle,y=winner)) + geom_smooth() + xlab("Angle Made By Federer's Shot") + ylab("Proportion of Winners") + ggtitle("Winners By Federer's Shot Angle")

ggplot(fed_only) + geom_density(aes(p.angle,group=factor(winner),color=factor(winner))) + ggtitle("Density of Winners by Fed Shot Angles")

ggplot(fed_only) + geom_density(aes(o.angle,group=factor(winner),color=factor(winner))) + ggtitle("Density of Winners by Opponent Shot Angles")

#Winners by oppo speed
ggplot(fed_only) + geom_density(aes(oppo.speed, group = factor(winner), color=factor(winner)))

ggplot(fed_only, aes(x=factor(winner),y=oppo.speed,fill=factor(winner))) + geom_boxplot() + ggtitle("Winner by Opponent Speed")

#Winners by speed ratio
ggplot(fed_only) + geom_density(aes(speed.ratio, group = factor(winner), color=factor(winner)))

ggplot(fed_only, aes(x=factor(winner),y=speed.ratio,fill=factor(winner))) + geom_boxplot() + ggtitle("Winner by Speed Ratio")
```


###Differences in speed for winners across match situations/scores
```{r vis2}
#Box plots across multiple categories
df_long1 <- gather(data = fed_only, key = variables, value = stat, speed1, final.shot, shot)

ggplot(df_long1) + geom_boxplot(aes(x=factor(winner), y=stat, fill=factor(winner))) + facet_wrap(~variables, scale = "free_y") + ggtitle("Differences In Characteristics of Winner/Not")

#Boxplots for speed by winner, facet by sets difference
ggplot(fed_only, aes(x=factor(winner),y=speed1,fill=factor(winner))) + geom_boxplot() + facet_grid(.~ sets.diff) + ggtitle("Speed of Shots For Difference in Sets Won")

#Boxplots for speed by winner, facet by games difference
ggplot(fed_only, aes(x=factor(winner),y=speed1,fill=factor(winner))) + geom_boxplot() + facet_grid(.~ games.diff) + ggtitle("Speed of Shots For Difference in Games Won")

#Boxplots for speed by winner, facet by points difference
ggplot(fed_only, aes(x=factor(winner),y=speed1,fill=factor(winner))) + geom_boxplot() + facet_grid(.~ points.diff) + ggtitle("Speed of Shots For Difference in Points Won")

#Boxplots for speed.ratio by winner, facet by sets difference
ggplot(fed_only, aes(x=factor(winner),y=speed.ratio,fill=factor(winner))) + geom_boxplot() + facet_grid(.~ sets.diff) + ggtitle("Difference in Speed Ratio For Difference in Sets Won")

#Boxplots for speed.ratio by winner, facet by games difference
ggplot(fed_only, aes(x=factor(winner),y=speed.ratio,fill=factor(winner))) + geom_boxplot() + facet_grid(.~ games.diff) + ggtitle("Difference in Speed Ratio For Difference in Games Won")

#Boxplots for speed.ratio by winner, facet by points difference
ggplot(fed_only, aes(x=factor(winner),y=speed.ratio,fill=factor(winner))) + geom_boxplot() + facet_grid(.~ points.diff) + ggtitle("Difference in Speed Ratio For Difference in Points Won")
```

###Winners by forehand/backhand, return serve classifcations and the effect of importance (metric)

```{r vis3}
#Proportion of winners by forehand/backhand
fed_hand <- na.omit(fed_only) %>%
  group_by(hitpoint,winner) %>%
  summarise(n=n()) %>%
  mutate(proportion = n/sum(n))
ggplot(fed_hand, aes(x=factor(winner),y=proportion,color=factor(winner))) + geom_point() + facet_grid(~hitpoint,labeller = label_both) + ggtitle("Proportion of Winners for Backhand/Forehand Shots")

#Proportion of winners for returning serve
fed_ret <- fed_only %>%
  group_by(retser,retser1,winner) %>%
  summarise(n=n()) %>%
  mutate(proportion = n/sum(n))
ggplot(fed_ret, aes(x=factor(winner),y=proportion,color=factor(winner))) + geom_point() + facet_wrap(~retser ~retser1,labeller = label_both) + ggtitle("Proportion of Winners for Returning Serve - For Both Serve 1 and 2")

#Plotting Importance
ggplot(fed_only, aes(x=importance,y=winner)) + geom_smooth() + xlab("Importance") + ylab("Proportion of Winners") + labs(title="Proportion of Winners against Importance")

ggplot(fed_only) + geom_density(aes(importance, group = factor(winner), color=factor(winner))) + labs(title="Density of Importance by Winners")
```


Notes Pre-Modelling:


Response variables to consider: 
winner
speed.ratio
p.angle
ballmark.x
ballmark.y

Covariates
o.angle, oppo.speed, retser1, retser2, fhand, start.x, diff.sets, diff.games, diff.points

```{r adjustingo.angle}
fed_only$o.angle[is.na(fed_only$o.angle)] <- 0
```


# Type 1: Simple Models, Independent of Match Score/Situation

### T1: Model 1
Response: winner
Covariates: oppo.speed, retser1, retser2, fhand, start.x

```{r t1m1}
library(depmixS4)
library(dplyr)
t1.mod1 <- depmix(winner ~ 1, transition = ~ oppo.speed + retser1 + retser2 + fhand + start.x, data = fed_only, nstates = 2, family=multinomial("identity"))
t1.fm1 <- fit(t1.mod1)
summary(t1.fm1)
```

State 1 is returning as there is 0.052 probability of hitting a winner
State 2 is more aggressive, with 0.226 chance of hitting a winner

### T1: Model 2
Response: winner
Covariates: oppo.speed, retser1, retser2, fhand, start.x, o.angle

```{r t1m2}
library(depmixS4)
t1.mod2 <- depmix(winner ~ 1, transition = ~ oppo.speed + retser1 + retser2 + fhand + start.x + o.angle, data = fed_only, nstates = 2, family=multinomial("identity"))
t1.fm2 <- fit(t1.mod2)
summary(t1.fm2)
```

State 1 is returning as there is 0.000 probability of hitting a winner
State 2 is more aggressive, with 0.227 chance of hitting a winner

### T1: Model 3
Response: winner
Covariates: oppo.speed, retser1, retser2, fhand, start.x, o.angle, oppo.hit.x

```{r t1m3}
library(depmixS4)
t1.mod3 <- depmix(winner ~ 1, transition = ~ oppo.speed + retser1 + retser2 + fhand + start.x + o.angle + oppo.hit.x, data = fed_only, nstates = 2, family=multinomial("identity"))
t1.fm3<- fit(t1.mod3)
summary(t1.fm3)
```

### T1: Model 4
Response: winner
Covariates: oppo.speed, retser1, retser2, fhand, start.x, o.angle, oppo.hit.x, oppo.ballmark.x

```{r t1m4}
library(depmixS4)
t1.mod4 <- depmix(winner ~ 1, transition = ~ oppo.speed + retser1 + retser2 + fhand + start.x + o.angle + oppo.hit.x + oppo.ballmark.x, data = fed_only, nstates = 2, family=multinomial("identity"))
t1.fm4<- fit(t1.mod4)
summary(t1.fm4)
```

### T1: Model 5
Response: winner
Covariates: oppo.speed, retser1, retser2, fhand, start.x, o.angle,  oppo.hit.x, lag.p.angle, lag.speed.ratio

```{r t1m5}
library(depmixS4)
t1.mod5 <- depmix(winner ~ 1, transition = ~ oppo.speed + retser1 + retser2 + fhand + start.x + o.angle + oppo.hit.x + lag.p.angle + lag.speed.ratio, data = fed_only, nstates = 2, family=multinomial("identity"))
t1.fm5 <- fit(t1.mod5)
summary(t1.fm5)
```

### Comparing Type 1 Models
```{r}
AIC(t1.fm1)
AIC(t1.fm2)
AIC(t1.fm3)
AIC(t1.fm4)
AIC(t1.fm5)

library(lmtest)
lrtest(t1.fm3,t1.fm5)
```

Conclusion:
Model 5 has lowest AIC, which is slightly lower than model 3. LR Test confirms that Model 5 is significantly different to Model 3, so we will continue with Model 5's covariates.


# Type 2: Higher Resolution Models, Independent of Match Score

### T2: Model 1
Response: winner, speed.ratio
Covariates: oppo.speed, retser1, retser2, fhand, start.x, o.angle,  oppo.hit.x, lag.p.angle, lag.speed.ratio

```{r t2m1}
library(depmixS4)
t2.mod1 <- depmix(list(winner ~ 1, speed.ratio ~ 1), transition = ~ oppo.speed + retser1 + retser2 + fhand + start.x + o.angle + oppo.hit.x + lag.p.angle + lag.speed.ratio, data = fed_only, nstates = 2, family=list(multinomial("identity"),gaussian()))
t2.fm1<- fit(t2.mod1)
summary(t2.fm1)
```

### T2: Model 2
Response: winner, p.angle
Covariates: oppo.speed, retser1, retser2, fhand, start.x, o.angle,  oppo.hit.x, lag.p.angle, lag.speed.ratio

```{r t2m2}
library(depmixS4)
t2.mod1 <- depmix(list(winner ~ 1, p.angle ~ 1), transition = ~ oppo.speed + retser1 + retser2 + fhand + start.x + o.angle + oppo.hit.x + lag.p.angle + lag.speed.ratio, data = fed_only, nstates = 2, family=list(multinomial("identity"),gaussian()))
t2.fm2<- fit(t2.mod2)
summary(t2.fm2)
```


### T2: Model 3
Response: winner, speed.ratio p.angle
Covariates: oppo.speed, retser1, retser2, fhand, start.x, o.angle,  oppo.hit.x, lag.p.angle, lag.speed.ratio

```{r t2m3}
library(depmixS4)
t2.mod3 <- depmix(list(winner ~ 1, speed.ratio ~ 1, p.angle ~ 1), transition = ~ oppo.speed + retser1 + retser2 + fhand + start.x + o.angle + oppo.hit.x + lag.p.angle + lag.speed.ratio, data = fed_only, nstates = 2, family=list(multinomial("identity"),gaussian(),gaussian()))
t2.fm3<- fit(t2.mod3)
summary(t2.fm3)
```

Comparing these three to see which combination of response variables is the best fit

```{r}
AIC(t2.fm1)
AIC(t2.fm2)
AIC(t2.fm3)
AIC(t2.fm4)
```
Model 1 - winner and speed.ratio as response variables - is the best fit.

# Type 3: Detailed Models, Dependent of Match Score/Situation

### T3: Model 1
Response: winner, speed.ratio p.angle
Covariates: oppo.speed, retser1, retser2, fhand, start.x, o.angle,  oppo.hit.x, lag.p.angle, lag.speed.ratio, importance

```{r t3m1}
library(depmixS4)
t3.mod1 <- depmix(list(winner ~ 1, speed.ratio ~ 1), transition = ~ oppo.speed + retser1 + retser2 + fhand + start.x + o.angle + oppo.hit.x + lag.p.angle + lag.speed.ratio + importance, data = fed_only, nstates = 2, family=list(multinomial("identity"),gaussian()))
t3.fm1<- fit(t3.mod1)
summary(t3.fm1)

AIC(t2.fm1)
AIC(t3.fm1)
lrtest(t2.fm1,t3.fm1)
```
No signficant change in the model from including importance. Decision is to not include it.


### T3: Model 2
Response: winner, speed.ratio p.angle
Covariates: oppo.speed, retser1, retser2, fhand, start.x, o.angle,  oppo.hit.x, lag.p.angle, lag.speed.ratio, points.diff

```{r t3m2}
library(depmixS4)
t3.mod2 <- depmix(list(winner ~ 1, speed.ratio ~ 1), transition = ~ oppo.speed + retser1 + retser2 + fhand + start.x + o.angle + oppo.hit.x + lag.p.angle + lag.speed.ratio + points.diff, data = fed_only, nstates = 2, family=list(multinomial("identity"),gaussian()))
t3.fm2<- fit(t3.mod2)
summary(t3.fm2)

```

```{r}
AIC(t3.fm1)
AIC(t3.fm2)

lrtest(t3.fm1,t3.fm2)
```

Adding the point differential does improve the model. Let's continue by adding game differential.

### T3: Model 3
Response: winner, speed.ratio p.angle
Covariates: oppo.speed, retser1, retser2, fhand, start.x, o.angle,  oppo.hit.x, lag.p.angle, lag.speed.ratio, points.diff, games.diff

```{r t3m3}
library(depmixS4)
t3.mod3 <- depmix(list(winner ~ 1, speed.ratio ~ 1), transition = ~ oppo.speed + retser1 + retser2 + fhand + start.x + o.angle + oppo.hit.x + lag.p.angle + lag.speed.ratio + points.diff + games.diff, data = fed_only, nstates = 2, family=list(multinomial("identity"),gaussian()))
t3.fm3<- fit(t3.mod3)
summary(t3.fm3)

```

```{r}
AIC(t3.fm2)
AIC(t3.fm3)

lrtest(t3.fm2,t3.fm3)
```
It appears that adding the games differential doesn't improve from model 2. Let's try adding sets as well.

### T3: Model 4
Response: winner, speed.ratio p.angle
Covariates: oppo.speed, retser1, retser2, fhand, start.x, o.angle,  oppo.hit.x, lag.p.angle, lag.speed.ratio, points.diff, games.diff, sets.diff

```{r t3m4}
library(depmixS4)
t3.mod4 <- depmix(list(winner ~ 1, speed.ratio ~ 1), transition = ~ oppo.speed + retser1 + retser2 + fhand + start.x + o.angle + oppo.hit.x + lag.p.angle + lag.speed.ratio + points.diff + games.diff + sets.diff, data = fed_only, nstates = 2, family=list(multinomial("identity"),gaussian()))
t3.fm4<- fit(t3.mod4)
summary(t3.fm4)

```

```{r}
AIC(t3.fm2)
AIC(t3.fm3)
AIC(t3.fm4)

lrtest(t3.fm2,t3.fm4)
lrtest(t3.fm3,t3.fm4)
```

Adding sets improves the model with games, but is not an overall improvement from points. Because the difference in AIC is so small, and p-value for LR test is almost 0.05, I have decided to include points, games and set difference in the model for the sake of examining other players. Federer may be able to block out the score in a match and play consistantly throughout, whereas other players may behave differently with different score differentials.

#Decision on a Final Model

```{r}
AIC(t3.fm4)
AIC(t2.fm1)

lrtest(t3.fm4,t2.fm1)
```

The model that includes match score overall (Type 3: Model 4) is an improvement from the model without (Type 2: Model 1). So we will use Type 3: Model 4 for the forecasts.

#Predictions with Model - BELOW FROM PREVIOUS CODE - DO NOT RUN

```{r predict}
#Pull out parameters
pars <- getpars(t3.fm4)

#Creating temporary transition matrix
#Refresh function: Inputs
#a - oppo.speed
#b - retser1
#c - retser2
#d - fhand
#e - start.x
#f - o.angle
#g - oppo.hit.x
#h - lag.p.angle
#i - lag.speed.ratio
#j - points.diff
#k - games.diff
#l - sets.diff
tr.refresh <- function(a,b,c,d,e,f,g,h,i,j,k,l) {
  p11 <- 1/(1+exp(pars[[4]]+pars[[6]]*a+pars[[8]]*b+pars[[10]]*c+pars[[12]]*d+pars[[14]]*e+pars[[16]]*f+pars[[18]]*g+pars[[20]]*h+pars[[22]]*i+pars[[24]]*j+pars[[26]]*k+pars[[28]]*l))
  
  p21 <- 1/(1+exp(pars[[30]]+pars[[32]]*a+pars[[34]]*b+pars[[36]]*c+pars[[38]]*d+pars[[40]]*e+pars[[42]]*f+pars[[44]]*g+pars[[46]]*h+pars[[48]]*i+pars[[50]]*j+pars[[52]]*k+pars[[54]]*l))
  
  p12 <- 1 - p11
  p22 <- 1 - p21
  
  tr.temp <- as.matrix(c(p11,p21,p12,p22))
  tr.temp <- matrix(tr.temp, ncol=2)
}


#Predicted states shell
pr.state <- matrix(0,nrow(fed_only),2)

#State 1
init.state <- matrix(c(pars[[1]],pars[[2]]),ncol=2) #initial state
a <- fed_only$oppo.speed[1]
b <- fed_only$retser1[1]
c <- fed_only$retser2[1]
d <- fed_only$fhand[1]
e <- fed_only$start.x[1]
f <- fed_only$o.angle[1]
g <- fed_only$oppo.hit.x[1]
h <- fed_only$lag.p.angle[1]
i <- fed_only$lag.speed.ratio[1]
j <- fed_only$points.diff[1]
k <- fed_only$games.diff[1]
l <- fed_only$sets.diff[1]
trans <- tr.refresh(a,b,c,d,e,f,g,h,i,j,k,l)
pr.state[1,] <- init.state %*% trans

#States 2 onwards (holding probabilities)
for(q in 2:nrow(fed_only)) {
a <- fed_only$oppo.speed[q]
b <- fed_only$retser1[q]
c <- fed_only$retser2[q]
d <- fed_only$fhand[q]
e <- fed_only$start.x[q]
f <- fed_only$o.angle[q]
g <- fed_only$oppo.hit.x[q]
h <- fed_only$lag.p.angle[q]
i <- fed_only$lag.speed.ratio[q]
j <- fed_only$points.diff[q]
k <- fed_only$games.diff[q]
l <- fed_only$sets.diff[q]
  trans <- tr.refresh(a,b,c,d,e,f,g,h,i,j,k,l)
  pr.state[q,] <- pr.state[q-1,] %*% trans
}

#Predicted states
predict_df <- data.frame(prob.win=pr.state[,1])

#Making conclusions on state
predict_df <- predict_df %>% rowwise %>%
  mutate(pred.win = ifelse(prob.win <= 0.5, 0, 1))

fed_pred <- cbind(fed_only, predict_df)

#Remember that state 1 is winner, state 2 is returning
```

```{r}
df_long <- fed_pred %>%
  gather(key = vars, value = measurement, pred.win, oppo.speed, retser1, retser2, fhand, start.x, o.angle, oppo.hit.x, lag.p.angle, lag.speed.ratio, points.diff, games.diff, sets.diff)
  
ggplot(df_long, aes(x=count,y=measurement)) + geom_line() + facet_grid(opponent~vars~., scale="free_y") + xlab("Time")


ggplot(test_pred,aes(prob.win,winner)) + geom_point(aes(color = pred.s1)) + ggtitle("Model 4 - Response: Winner, Speed")



models_df <- cbind(mut_eye_x, chs_m4 = mut_eye_n4x$pred.chs) %>%
 cbind(chs_m5 = mut_eye_n5x$pred.chs) %>%
  cbind(chs_m6 = mut_eye_n6x$pred.chs)

models_long <- models_df %>%
  gather(key = model, value = choosing, chs_m4, chs_m5, chs_m6)

ggplot(models_long, aes(x=begtime,y=choosing)) + geom_point(aes(color = model)) + facet_grid(model~., scale="free_y") + xlab("Time") + ylab("Choosing State")
```




```{r Appendix}
```

