---
title: "rallies"
author: "Pat Healy"
date: "17 November 2018"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
library(devtools)
library(ggplot2)
library(tidyr)
library(dplyr)
library(tidyverse)
```
```{r}
load("data/rallies.RData")
library(readr)
```
Shaping data to recreate the variables used in ("Federer AO 2017.Rmd")'Federer vs Berdych 2017' for the AO matches 'Djokovic v Chung 2016', 'Djokovic v Chung 2018', 'Federer v Berdych 2016', 'Federer v Berdych 2018', 'Makarova v Konta 2016','Makarova v Konta 2017','Strycova v Garcia 2016' 'Strycova v Garcia 2017', 'Siegemund v Jankovic 2016','Siegemund v Jankovic 2017', 'Goffin v Thiem 2016''Goffin v Thiem 2017'""

'Siegemund v Jankovic 2017' goes from set 3 to set 6?? 

#Seperating and shaping matches

```{r }
djo16_df <- filter(rallies, year == 2016, h2h == "DJOKOVIC CHUNG" )
djo16_df <- arrange(djo16_df, matchid, set, game, point, shot)

djo18_df <- filter(rallies, year == 2018, h2h == "DJOKOVIC CHUNG" )
djo18_df <- arrange(djo18_df, matchid, set, game, point, shot)

fed16_df <- filter(rallies, year == 2016, h2h == "FEDERER BERDYCH" )
fed16_df <- arrange(fed16_df, matchid, set, game, point, shot)

fed17_df <- filter(rallies, year == 2017, h2h == "FEDERER BERDYCH" )
fed17_df <- arrange(fed17_df, matchid, set, game, point, shot)

fed18_df <- filter(rallies, year == 2018, h2h == "FEDERER BERDYCH" )
fed18_df <- arrange(fed18_df, matchid, set, game, point, shot)

mak16_df <- filter(rallies, year == 2016, h2h == "MAKAROVA KONTA" )
mak16_df <- arrange(mak16_df, matchid, set, game, point, shot)

mak17_df <- filter(rallies, year == 2017, h2h == "MAKAROVA KONTA" )
mak17_df <- arrange(mak17_df, matchid, set, game, point, shot)

stry16_df <- filter(rallies, year == 2016, h2h == "STRYCOVA GARCIA" )
stry16_df <- arrange(stry16_df, matchid, set, game, point, shot)

stry17_df <- filter(rallies, year == 2017, h2h == "STRYCOVA GARCIA" )
stry17_df <- arrange(stry17_df, matchid, set, game, point, shot)

sie16_df <- filter(rallies, year == 2016, h2h == "SIEGEMUND JANKOVIC" )
sie16_df <- arrange(sie16_df, matchid, set, game, point, shot)

sie17_df <- filter(rallies, year == 2017, h2h == "SIEGEMUND JANKOVIC" )
sie17_df <- arrange(sie17_df, matchid, set, game, point, shot)

thi16_df <- filter(rallies, year == 2016, h2h == "THIEM GOFFIN" )
thi16_df <- arrange(thi16_df, matchid, set, game, point, shot)

thi17_df <- filter(rallies, year == 2017, h2h == "THIEM GOFFIN" )
thi17_df <- arrange(thi17_df, matchid, set, game, point, shot)
```
##Federer Vs Berdych
(some columns in rallies data have a different classification than in federer2017 data. Such as 'is.good' replaces 'ended.in.error')(With Aces dropped we also now cannot recreate retser, retser1 or retser2 )
Starting with Federer vs Berdych 2016


###Federer 2016 
```{r  }

#Reorienting shots so that all Federer's shot are from negative x side of court, and all opponents shots are from positive x side. y coordinates have been flipped as required.
fed16_df <- fed16_df %>% rowwise %>%
  mutate(projected.ballmark.y = ifelse(impact.player == "FEDERER" & start.x >= 0, -projected.ballmark.y, projected.ballmark.y)) %>%
  mutate(start.y = ifelse(impact.player == "FEDERER" & start.x >= 0, -start.y, start.y))%>%
  mutate(projected.ballmark.x = ifelse(impact.player == "FEDERER" & start.x >= 0, -projected.ballmark.x, projected.ballmark.x)) %>%
  mutate(start.x = ifelse(impact.player == "FEDERER" & start.x >= 0, -start.x, start.x)) 

#Reorienting opponent shots
fed16_df <- fed16_df %>% rowwise %>%
  mutate(start.y = ifelse(impact.player != "FEDERER" & start.x <= 0, -start.y, start.y)) %>%
  mutate(projected.ballmark.y = ifelse(impact.player != "FEDERER" & start.x <= 0, -projected.ballmark.y, projected.ballmark.y)) %>%
  mutate(projected.ballmark.x = ifelse(impact.player != "FEDERER" & start.x <= 0, -projected.ballmark.x, projected.ballmark.x)) %>%
  mutate(start.x = ifelse(impact.player != "FEDERER" & start.x <= 0, -start.x, start.x))
```


```{r }

#Reorienting player positions so that all Federer's & Opponents start/end positions match reoriented ballmarks
#For Federer
fed16_df <- fed16_df %>% rowwise %>%
  mutate(start.server.y = ifelse(server == "FEDERER" & start.server.x >= 0, -start.server.y, start.server.y)) %>%
  mutate(start.receiver.y = ifelse(receiver == "FEDERER" & start.receiver.x >= 0, -start.receiver.y, start.receiver.y))%>%
  mutate(end.server.y = ifelse(server == "FEDERER" & end.server.x >= 0, -end.server.y, end.server.y)) %>%
  mutate(end.receiver.y = ifelse(receiver == "FEDERER" & end.receiver.x >= 0, -end.receiver.y, end.receiver.y))%>%
  mutate(start.server.x = ifelse(server == "FEDERER" & start.server.x >= 0, -start.server.x, start.server.x)) %>%
  mutate(start.receiver.x = ifelse(receiver == "FEDERER" & start.receiver.x >= 0, -start.receiver.x, start.receiver.x)) 

fed16_df <- fed16_df %>% rowwise %>%
  mutate(end.server.x = ifelse(server == "FEDERER" & end.server.x >= 0, -end.server.x, end.server.x)) %>%
  mutate(end.receiver.x = ifelse(receiver == "FEDERER" & end.receiver.x >= 0, -end.receiver.x, end.receiver.x)) 
```

```{r }


#For Opponent
fed16_df <- fed16_df %>% rowwise %>%
  mutate(start.server.y = ifelse(server != "FEDERER" & start.server.x <= 0, -start.server.y, start.server.y)) %>%
  mutate(start.receiver.y = ifelse(receiver != "FEDERER" & start.receiver.x <= 0, -start.receiver.y, start.receiver.y))%>%
  mutate(end.server.y = ifelse(server != "FEDERER" & end.server.x <= 0, -end.server.y, end.server.y)) %>%
  mutate(end.receiver.y = ifelse(receiver != "FEDERER" & end.receiver.x <= 0, -end.receiver.y, end.receiver.y))%>%
  mutate(start.server.x = ifelse(server != "FEDERER" & start.server.x <= 0, -start.server.x, start.server.x)) %>%
  mutate(start.receiver.x = ifelse(receiver != "FEDERER" & start.receiver.x <= 0, -start.receiver.x, start.receiver.x)) 

fed16_df <- fed16_df %>% rowwise %>%
  mutate(end.server.x = ifelse(server != "FEDERER" & end.server.x <= 0, -end.server.x, end.server.x)) %>%
  mutate(end.receiver.x = ifelse(receiver != "FEDERER" & end.receiver.x <= 0, -end.receiver.x, end.receiver.x)) 
```





```{r}
fed16_df <- fed16_df %>%
  mutate(lastshot = ifelse(shot == final.shot,1,0)) %>%
  mutate(isserver = ifelse(server == impact.player,1,0)) %>%
  mutate(fhand = ifelse(hitpoint == "F",1,0)) %>%
  mutate(opponent = ifelse(server == "FEDERER", receiver, server)) 
 

  

```

```{r}
#Serve, return and winner classifications


#Create variables for winner, 1st serve and second serve
fed16_df <- fed16_df %>%
  mutate(winner = ifelse(is.good == TRUE & lastshot == 1,1,0)) %>%
  mutate(ser1 = ifelse(serve == 1 & serve_classification == 1,1,0)) %>%
  mutate(ser2 = ifelse(serve == 2 & serve_classification == 1,1,0)) 
  
for (i in 1:ncol(fed16_df)) {
  if(is.character(fed16_df[,i]) == TRUE) {
    fed16_df[,i] <- as.factor(fed16_df[,i])
  }
}
```

```{r}
#Combining winner, return into play and error into 1 column for three states in hidden markov model
#If ball is in play and the shot is a winner value of 1
#If ball is in play and the shot is not a winner value of 0
#If the ball is out of play and thus not a winner value of -1

fed16_df <- fed16_df %>%
  mutate(winner.return.error = ifelse(is.good =="TRUE" & winner == "1",1,
                ifelse(is.good =="TRUE" & winner == "0",0,-1)))
```


```{r}
#Creating variable for rally number
col = c("set","game", "point")
rally.num = as.data.frame(group_indices_(fed16_df,.dots = col))
colnames(rally.num)<- "rally.number"
```

```{r}
#joining rally.number to federer16 data frame

fed16_df <- fed16_df %>%
  cbind(rally.num)
 
```



```{r}
#New Variables for player and opponent: start/end positions,  speed &acceleration, distance run within shot, work, advantage, total changes  

#start/end player positions x/y
fed16_df <- fed16_df %>%
  mutate(oppo.start.position.x = ifelse(server != "FEDERER", start.server.x,0)+ifelse(server == "FEDERER", start.receiver.x,0))%>%
  mutate(oppo.start.position.y = ifelse(server != "FEDERER", start.server.y,0)+ifelse(server == "FEDERER", start.receiver.y,0)) %>%
  mutate(oppo.end.position.x = ifelse(server != "FEDERER", end.server.x,0)+ifelse(server == "FEDERER", end.receiver.x,0)) %>%
  mutate(oppo.end.position.y = ifelse(server != "FEDERER", end.server.y,0)+ifelse(server == "FEDERER", end.receiver.y,0)) %>%
  mutate(p.start.position.x = ifelse(server == "FEDERER", start.server.x,0)+ifelse(server != "FEDERER", start.receiver.x,0)) %>%
  mutate(p.start.position.y = ifelse(server == "FEDERER", start.server.y,0)+ifelse(server != "FEDERER", start.receiver.y,0)) %>%
  mutate(p.end.position.x = ifelse(server == "FEDERER", end.server.x,0)+ifelse(server != "FEDERER", end.receiver.x,0)) %>%
  mutate(p.end.position.y = ifelse(server == "FEDERER", end.server.y,0)+ifelse(server != "FEDERER", end.receiver.y,0)) 
  
#player and opponent distances travelled from start of shot to end of next shot
fed16_df <- fed16_df %>%  
  mutate(oppo.distance = ifelse(server != "FEDERER", server.distance,0)+ifelse(server == "FEDERER", receiver.distance,0)) %>%
  mutate(p.distance = ifelse(server == "FEDERER", server.distance,0)+ifelse(server != "FEDERER", receiver.distance,0))

#player and opponent speed 
fed16_df <- fed16_df %>%
  mutate(p.peak.speed = ifelse(server == "FEDERER", server.peak.speed,0)+ifelse(server != "FEDERER", receiver.peak.speed,0)) %>%
  mutate(p.avg.speed = ifelse(server == "FEDERER", server.avg.speed,0)+ifelse(server != "FEDERER", receiver.avg.speed,0)) 
  

#player and opponent acceleration
fed16_df <- fed16_df %>%  
  mutate(p.avg.acceleration = ifelse(server == "FEDERER", server.avg.acceleration,0)+ifelse(server != "FEDERER", receiver.avg.acceleration,0)) %>%
  mutate(p.peak.acceleration = ifelse(server == "FEDERER", server.peak.acceleration,0)+ifelse(server != "FEDERER", receiver.peak.acceleration,0)) %>%
  mutate(oppo.peak.speed = ifelse(server != "FEDERER", server.peak.speed,0)+ifelse(server == "FEDERER", receiver.peak.speed,0)) %>%
  mutate(oppo.avg.speed = ifelse(server != "FEDERER", server.avg.speed,0)+ifelse(server == "FEDERER", receiver.avg.speed,0)) %>%
  mutate(oppo.avg.acceleration = ifelse(server != "FEDERER", server.avg.acceleration,0)+ifelse(server == "FEDERER", receiver.avg.acceleration,0)) %>%
  mutate(oppo.peak.acceleration = ifelse(server != "FEDERER", server.peak.acceleration,0)+ifelse(server == "FEDERER", receiver.peak.acceleration,0))


#player and opponent work
fed16_df <- fed16_df %>%
  mutate(oppo.work = ifelse(server != "FEDERER", server.work,0)+ifelse(server == "FEDERER", receiver.work,0)) %>%
  mutate(p.work = ifelse(server == "FEDERER", server.work,0)+ifelse(server != "FEDERER", receiver.work,0)) 

#player and opponent advantage
fed16_df <- fed16_df %>%
  mutate(oppo.advantage =ifelse(server != "FEDERER", server.advantage,0)+ifelse(server == "FEDERER", receiver.advantage,0))%>%
   mutate(p.advantage =ifelse(server == "FEDERER", server.advantage,0)+ifelse(server != "FEDERER", receiver.advantage,0))


#player and opponent total changes
fed16_df <- fed16_df %>%
  mutate(oppo.total.changes =ifelse(server != "FEDERER", server.total.changes,0)+ifelse(server == "FEDERER", receiver.total.changes,0))%>%
   mutate(p.total.changes =ifelse(server == "FEDERER", server.total.changes,0)+ifelse(server != "FEDERER", receiver.total.changes,0))
  
  
```

```{r}

#player speed and acceleration differences and ratios
fed16_df <- fed16_df %>%
  mutate(avg.player.speed.diff = p.avg.speed-oppo.avg.speed) %>%
  mutate(peak.player.speed.diff = p.peak.speed-oppo.peak.speed) %>%
  mutate(avg.player.speed.ratio = p.avg.speed/oppo.avg.speed) %>%
  mutate(peak.player.speed.ratio = p.peak.speed/oppo.peak.speed) %>%
  mutate(avg.player.acceleration.diff = (p.avg.acceleration)-(oppo.avg.acceleration)) %>%
  mutate(peak.player.acceleration.diff = (p.peak.acceleration)-(oppo.peak.acceleration)) %>%
  mutate(avg.player.acceleration.ratio = (p.avg.acceleration)/(oppo.avg.acceleration)) %>%
  mutate(peak.player.acceleration.ratio = (p.peak.acceleration)/(oppo.peak.acceleration)) %>%
  mutate(p.avg.speed.match = mean(p.avg.speed)) %>%
  mutate(oppo.avg.speed.match = mean(oppo.avg.speed)) %>%
  mutate(p.diff.avg.shot.and.match.movement.speed = p.avg.speed - p.avg.speed.match) %>%
  mutate(oppo.diff.avg.shot.and.match.movement.speed = oppo.avg.speed - oppo.avg.speed.match)
  

#player/opponent side distance for start/end positions
fed16_df <- fed16_df %>%
  mutate(p.start.position.side.dist = 4.115 - abs(p.start.position.y)) %>%
  mutate(p.end.position.side.dist = 4.115 - abs(p.end.position.y)) %>%
  mutate(oppo.start.position.side.dist = 4.115 - abs(oppo.start.position.y)) %>%
  mutate(oppo.end.position.side.dist = 4.115 - abs(oppo.end.position.y))
  
#player/opponent base distances for start/end positions  
fed16_df <- fed16_df %>%
  mutate(p.start.position.base.dist = 11.89 - abs(p.start.position.x)) %>%
  mutate(p.end.position.base.dist = 11.89 - abs(p.end.position.x)) %>%
  mutate(oppo.start.position.base.dist = 11.89 - abs(oppo.start.position.x)) %>%
  mutate(oppo.end.position.base.dist = 11.89 - abs(oppo.end.position.x)) %>%
  mutate(oppo.start.position.base.diff = p.start.position.base.dist - oppo.start.position.base.dist) %>%
  mutate(p.start.position.base.diff = oppo.start.position.base.dist -p.start.position.base.dist) %>%
  mutate(oppo.end.position.base.diff = p.end.position.base.dist - oppo.end.position.base.dist) %>%
  mutate(p.end.position.base.diff = oppo.end.position.base.dist -p.end.position.base.dist) %>%
  mutate(p.start.position.centre.diff = abs(oppo.start.position.y)-abs(p.start.position.y)) %>%
  mutate(p.end.position.centre.diff = abs(oppo.end.position.y)-abs(p.end.position.y)) %>%
  mutate(oppo.start.position.centre.diff = abs(p.start.position.y)-abs(oppo.start.position.y)) %>%
  mutate(oppo.end.position.centre.diff = abs(p.end.position.y)-abs(oppo.end.position.y))
  
  
```
```{r}
#player/ opponent shortest distances for start/end positions 
fed16_df <- fed16_df %>%
  mutate(oppo.start.position.short.dist = min(oppo.start.position.side.dist, oppo.start.position.base.dist)) %>%
   mutate(oppo.end.position.short.dist = min(oppo.end.position.side.dist, oppo.end.position.base.dist)) %>%
  mutate(p.start.position.short.dist = min(p.start.position.side.dist, p.start.position.base.dist)) %>%
   mutate(p.end.position.short.dist = min(p.end.position.side.dist, p.end.position.base.dist)) 
```



```{r}

#Tally of the number of times player and opponent change side during rally
#Defining change of side as having travelled from a location 2.0575 or more metres away from the centre on one side of the court (half the distance between centre and singles lines) to a location 2.0575 or more metres away from the centre on the other side of the court
fed16_df <- fed16_df %>%
  mutate(p.side.change.count = ifelse(p.start.position.y <= -2.0575 & p.end.position.y >= 2.0575, 1, ifelse(p.start.position.y >= 2.0575 & p.end.position.y <= -2.0575, 1, 0))) %>%
  mutate(p.side.change.cumsum = cumsum(p.side.change.count)) %>%
  mutate(oppo.side.change.count = ifelse(oppo.start.position.y <= -2.0575 & oppo.end.position.y >= 2.0575, 1, ifelse(oppo.start.position.y >= 2.0575 & oppo.end.position.y <= -2.0575, 1, 0))) %>%
  mutate(oppo.side.change.cumsum = cumsum(oppo.side.change.count)) 
  


  
  
```

```{r}
#Within rally tally of side change count and distance run
fed16_df <- fed16_df %>%
  group_by(rally.number ) %>%
  dplyr::mutate(p.rally.side.change.count = cumsum(p.side.change.count)) %>%
  dplyr::mutate(oppo.rally.side.change.count = cumsum(oppo.side.change.count)) %>%
  dplyr::mutate(rally.side.change.count.diff = p.rally.side.change.count-oppo.rally.side.change.count) %>%
  dplyr::mutate(oppo.rally.distance.run = cumsum(oppo.distance)) %>%
  dplyr::mutate(p.rally.distance.run = cumsum(p.distance)) %>%
  dplyr::mutate(rally.distance.run.ratio = p.rally.distance.run/oppo.rally.distance.run) %>%
  ungroup
 
```
```{r}
#Seperating height over net of shots for player and opponent.

fed16_df <- fed16_df %>%
  mutate(p.height.off.net = ifelse(impact.player == "FEDERER",height.off.net,0)) %>%
  mutate(oppo.height.off.net = ifelse(impact.player != "FEDERER", height.off.net,0)) 
  
```


```{r}
#Adding angles for player & opposition movement from start position[i] to end position[i] as well as end position[i] to start position[i+1]. Measuring the angle of movement from the baseline. Directly towards the net is 0 deg. Directly away from the net is 180 deg.


fed16_df <- fed16_df %>%
  mutate(p.movement.angle.1 = NA) %>%
  mutate(p.movement.angle.2 = NA) %>%
  mutate(oppo.movement.angle.1 = NA) %>%
  mutate(oppo.movement.angle.2 = NA) 
  
  
#player start to end movement angle  
for (i in 1:nrow(fed16_df)) {
  a1 <- fed16_df$p.start.position.x[i]
  b1 <- fed16_df$p.start.position.y[i]
  a2 <- fed16_df$p.end.position.x[i]
  b2 <- fed16_df$p.end.position.y[i]
  
  
  p.movement.angle.1 <- atan(
  ((abs(b1)-abs(b2))/(abs(a1)-abs(a2)))* 180/pi) 
  
  fed16_df$p.movement.angle.1[i] = ifelse(p.movement.angle.1 < 0 & (abs(a1)-abs(a2))<0, 180+p.movement.angle.1,
                                          ifelse(p.movement.angle.1 < 0 & (abs(b1)-abs(b2))<0,abs(p.movement.angle.1),
                                                 ifelse(p.movement.angle.1 > 0 & (abs(a1)-abs(a2))<0, 90+p.movement.angle.1,p.movement.angle.1)))
                                                                                                            
}



```
```{r}
#player end position(i) to start position (i+1) movement angle
for (i in 2:nrow(fed16_df)) {
  a1 <- fed16_df$p.end.position.x[i]
  b1 <- fed16_df$p.end.position.y[i]
  a2 <- fed16_df$p.start.position.x[i+1]
  b2 <- fed16_df$p.start.position.y[i+1]
  
  p.movement.angle.2 <- atan(
  ((abs(b1)-abs(b2))/(abs(a1)-abs(a2)))* 180/pi) 
  
  fed16_df$p.movement.angle.2[i] = ifelse(p.movement.angle.2 < 0 & (abs(a1)-abs(a2))<0, 180+p.movement.angle.2,
                                          ifelse(p.movement.angle.2 < 0 & (abs(b1)-abs(b2))<0,abs(p.movement.angle.2),
                                                 ifelse(p.movement.angle.2 > 0 & (abs(a1)-abs(a2))<0, 90+p.movement.angle.2,p.movement.angle.2)))
  
}  
  


```

```{r}
# opposition start to end movement angle

  
for (i in 1:nrow(fed16_df)) {
  a1 <- fed16_df$oppo.start.position.x[i]
  b1 <- fed16_df$oppo.start.position.y[i]
  a2 <- fed16_df$oppo.end.position.x[i]
  b2 <- fed16_df$oppo.end.position.y[i]
  
  oppo.movement.angle.1 <- atan(
  ((abs(b1)-abs(b2))/(abs(a1)-abs(a2)))* 180/pi) 
  
  fed16_df$oppo.movement.angle.1[i] = ifelse(oppo.movement.angle.1 < 0 & (abs(a1)-abs(a2))<0,180+oppo.movement.angle.1,
                                          ifelse(oppo.movement.angle.1 < 0 & (abs(b1)-abs(b2))<0,abs(oppo.movement.angle.1),
                                                 ifelse(oppo.movement.angle.1 > 0 & (abs(a1)-abs(a2))<0,90+oppo.movement.angle.1,p.movement.angle.1)))
  
  
}
```
```{r}
#oppositions end[i] to start [i+1] movement angle
for (i in 2:nrow(fed16_df)) {
  a1 <- fed16_df$oppo.end.position.x[i]
  b1 <- fed16_df$oppo.end.position.y[i]
  a2 <- fed16_df$oppo.start.position.x[i+1]
  b2 <- fed16_df$oppo.start.position.y[i+1]
  
  oppo.movement.angle.2 <- atan(
  ((abs(b1)-abs(b2))/(abs(a1)-abs(a2)))* 180/pi) 
  
  fed16_df$oppo.movement.angle.2[i] = ifelse(oppo.movement.angle.2 < 0 & (abs(a1)-abs(a2))<0, 180+oppo.movement.angle.2,
                                          ifelse(oppo.movement.angle.2 < 0 & (abs(b1)-abs(b2))<0,abs(oppo.movement.angle.2),
                                                 ifelse(oppo.movement.angle.2 > 0 & (abs(a1)-abs(a2))<0, 90+oppo.movement.angle.2,oppo.movement.angle.2)))
}
```
```{r}
##speed of player ad opponent shots in m/s at the start of the shot arc
fed16_df <- fed16_df %>%
  mutate(p.start.shot.speed = ifelse(impact.player == "FEDERER", speed.start, 0)) %>%
  mutate(oppo.start.shot.speed = ifelse(impact.player != "FEDERER", speed.start, 0)) 
```


```{r}
#code for this chunk relatively unchanged
# replaced ballmark.x with projected.ballmark.x; speed1 replaced by speed.start

fed16_df <- fed16_df %>%
  mutate(speed.diff = NA) %>%
  mutate(oppo.hit.x = NA) %>%
  mutate(oppo.hit.y = NA) %>%
  mutate(oppo.hit.z = NA) %>%
  mutate(oppo.speed = NA) %>%
  mutate(oppo.projected.ballmark.x = NA) %>%
  mutate(oppo.projected.ballmark.y = NA) %>%
  mutate(speed.ratio = NA) 


for (i in 2:nrow(fed16_df)) {
  if(fed16_df$shot[i] != 1) {#so that only non-serves are affected

  fed16_df$speed.diff[i]=fed16_df$speed.start[i]-fed16_df$speed.start[i-1]
  #speed difference
  
  fed16_df$oppo.hit.x[i]=fed16_df$start.x[i-1]
  fed16_df$oppo.hit.y[i]=fed16_df$start.y[i-1]
  fed16_df$oppo.hit.z[i]=fed16_df$start.z[i-1]
  fed16_df$oppo.speed[i]=fed16_df$speed.start[i-1]
  fed16_df$oppo.projected.ballmark.x[i]=fed16_df$projected.ballmark.x[i-1]
  fed16_df$oppo.projected.ballmark.y[i]=fed16_df$projected.ballmark.y[i-1]
  #oppo hit
  
  }
}

fed16_df <- fed16_df %>%
  mutate(speed.ratio = speed.start/oppo.speed) %>% #speed ratio
  mutate(side.dist = 4.115 - abs(oppo.projected.ballmark.y)) %>% #distance of oppo.projected.ballmark from sideline
  mutate(base.dist = 11.89 - abs(oppo.projected.ballmark.x)) %>% #distance of oppo.projected.ballmark from baseline
  mutate(short.dist = min(side.dist, base.dist)) #shortest distance from any line


#Adding angles
fed16_df <- fed16_df %>%
  mutate(p.start.shot.x = NA) %>%
  mutate(p.start.shot.y = NA)

for (i in 3:nrow(fed16_df)) {
  if(fed16_df$impact.player[i] == fed16_df$impact.player[i-2] & fed16_df$shot[i] == fed16_df$shot[i-2] + 2) {
    fed16_df$p.start.shot.x[i]=fed16_df$start.x[i-2]
    fed16_df$p.start.shot.y[i]=fed16_df$start.y[i-2]
  }
}

#adding angle between fed.shot-opp.shot vector and opp.shot-opp.projected.ballmark vector
#doing it in one line because df doesn't want to add vectors
fed16_df <- fed16_df %>%
  mutate(o.angle = NA)
  
for (i in 1:nrow(fed16_df)) {
  x1 <- fed16_df$p.start.shot.x[i]
  y1 <- fed16_df$p.start.shot.y[i]
  x2 <- fed16_df$oppo.hit.x[i]
  y2 <- fed16_df$oppo.hit.y[i]
  x3 <- fed16_df$oppo.projected.ballmark.x[i]
  y3 <- fed16_df$oppo.projected.ballmark.y[i]
  
  o.angle <- acos(
  ((c(x1,y1)-c(x2,y2))/sqrt((x1-x2)^2+(y1-y2)^2)) %*%
    ((c(x2,y2)-c(x3,y3))/sqrt((x2-x3)^2+(y2-y3)^2))) * 180/pi
  
  fed16_df$o.angle[i] = ifelse(o.angle > 90, 180-o.angle, o.angle)
}

#Now adding the angle the player hits
fed16_df <- fed16_df %>%
  mutate(p.angle = NA)
  
for (i in 1:nrow(fed16_df)) {
  x1 <- fed16_df$oppo.hit.x[i]
  y1 <- fed16_df$oppo.hit.y[i]
  x2 <- fed16_df$start.x[i]
  y2 <- fed16_df$start.y[i]
  x3 <- fed16_df$projected.ballmark.x[i]
  y3 <- fed16_df$projected.ballmark.y[i]
  
  p.angle <- acos(
  ((c(x1,y1)-c(x2,y2))/sqrt((x1-x2)^2+(y1-y2)^2)) %*%
    ((c(x2,y2)-c(x3,y3))/sqrt((x2-x3)^2+(y2-y3)^2))) * 180/pi
  
  fed16_df$p.angle[i] = ifelse(p.angle > 90, 180-p.angle, p.angle)
}

fed16_df <- fed16_df %>%
  group_by(rally.number) %>%
  mutate(lag.p.angle = dplyr::lag(p.angle, n = 1, default = NA)) %>%
  mutate(lag.speed.ratio = dplyr::lag(speed.ratio, n = 1, default = NA)) %>%
  mutate(lag.p.movement.angle.1 = dplyr::lag(p.movement.angle.1, n = 1, default = NA)) %>%
  mutate(lag.p.movement.angle.2 = dplyr::lag(p.movement.angle.2, n = 1, default = NA)) %>%
  mutate(lag.oppo.height.off.net = dplyr::lag(oppo.height.off.net, n = 1, default = NA)) %>%
  mutate(lag.p.start.shot.speed = dplyr::lag(p.start.shot.speed, n = 1, default = NA)) %>%
  mutate(lag.oppo.start.shot.speed = dplyr::lag(oppo.start.shot.speed, n = 1, default = NA)) %>%
  ungroup


```




```{r}
fed16_df <- fed16_df %>%
  mutate(oppo.start.server.x = ifelse(server != "FEDERER", start.server.x, 0)) 
```



```{r  }
#Creating Columns of player, opponent and ball positions for Animations
#creating new rows so that every second row start and end player positions are switched
#Also creating new rows so that every second row in start.x,/start.y is projected ballmark
#this allows us to better plot player positions as well as track positions for animations

join_df <- transform(fed16_df, p.start.position.x=p.end.position.x, p.start.position.y=p.end.position.y, oppo.start.position.x=oppo.end.position.x, oppo.start.position.y=oppo.end.position.y, start.x=projected.ballmark.x, start.y=projected.ballmark.y)

fed16_pos <- bind_rows(fed16_df, setNames(join_df, names(fed16_df))) %>% 
           arrange(rally.number, shot)

fed16_pos <- fed16_pos %>%
  group_by(rally.number, idx = cumsum(event == 1L)) %>%
  mutate(location.id= row_number()) %>%
  ungroup

fed16_pos <- fed16_pos %>%
  group_by(rally.number) %>%
  mutate(pos.rally.count= 1:n()) %>%
  ungroup
``` 





```{r }

#Removing opponent shots from data as we want to look at Federer for the Hidden Markov Model
#remove opponents
fed_no.opp <- fed16_df %>% 
  dplyr::filter(impact.player == "FEDERER")

#federer only - remove serves
fed16_only <- fed_no.opp %>%
  filter(hitpoint != "S") %>%
  dplyr::select(-serveid)


#First remove any errors for start, projected.ballmark, so that we are only looking at shots that we hit onto the other side
#To check: ggplot(fed16_only, aes(projected.ballmark.x, projected.ballmark.y)) + geom_point()
fed16_only <- fed16_only %>%
  filter(oppo.hit.x >= 0) %>%
  filter(oppo.projected.ballmark.x <= 0) %>%
  filter(projected.ballmark.x >= 0)

#Adding shot number cumulative count (functions as time)
#check this for new data set .
fed16_only <- fed16_only %>%
  mutate(count = 1)

  for (i in 2:nrow(fed16_only)) {
    if(fed16_only$matchid[i]==fed16_only$matchid[i-1]) {
      fed16_only$count[i] = fed16_only$count[i-1] + 1
    }
  }

  

#Adjusting to remove NAs and replace with 0s for modelling
fed16_only$o.angle[is.na(fed16_only$o.angle)] <- 0
fed16_only$lag.p.angle[is.na(fed16_only$lag.p.angle)] <- 0
fed16_only$lag.speed.ratio[is.na(fed16_only$lag.speed.ratio)] <- 0
fed16_only$p.start.shot.x[is.na(fed16_only$p.start.shot.x)] <- 0
fed16_only$p.start.shot.y[is.na(fed16_only$p.start.shot.y)] <- 0
fed16_only$lag.p.movement.angle.1[is.na(fed16_only$lag.p.movement.angle.1)] <- 0
fed16_only$lag.p.movement.angle.2[is.na(fed16_only$lag.p.movement.angle.2)] <- 0
fed16_only$lag.oppo.height.off.net[is.na(fed16_only$lag.oppo.height.off.net)] <- 0



fed16_only <- fed16_only %>% mutate(player.total.shot.number = row_number())
```
```{r}
fed16_only_plots <- fed16_only
```

```{r}
#making y positions absolute for fed16_only as this is more relevant for the depmix model

fed16_only <- fed16_only %>%
  mutate(p.start.position.y = abs(p.start.position.y)) %>%
  mutate(p.end.position.y = abs(p.end.position.y)) %>%
  mutate(oppo.start.position.y = abs(oppo.start.position.y)) %>%
  mutate(oppo.end.position.y = abs(oppo.end.position.y))%>%
  mutate(p.start.shot.y =abs(p.start.shot.y))
  
  

```


```{r }
#Creating seperate data frames for shot types useful for visualisation of shot patterns
dlb_pos <- filter(fed16_pos, down.line.backhand == "TRUE")

dlb_df <- filter(fed16_df, down.line.backhand == "TRUE")

dlb_fedonly <- filter(fed16_only, down.line.backhand == "TRUE")

iof_fedonly <- filter(fed16_only, inside.out.forehand == "TRUE")

dlw_fedonly <- filter(fed16_only, down.line.winner == "TRUE")
```




```{r}
#variables for speed of ball at the start of shot arcs

fed16_only <- fed16_only %>%
  mutate(avg.p.start.shot.speed = mean(p.start.shot.speed)) %>%
  mutate(avg.lag.oppo.start.shot.speed = mean(lag.oppo.start.shot.speed)) %>%
  mutate(diff.p.avg.and.current.shot.speed = p.start.shot.speed- avg.p.start.shot.speed) %>%
  mutate(diff.lag.oppo.avg.and.current.shot.speed = lag.oppo.start.shot.speed- avg.lag.oppo.start.shot.speed) 


  
```







 
```{r }
#Seperating out the longest rallies from this match to visualise them through animation
#examining rallies to look at side to side movement within rallies. Starting with the longest rally.
longral_df <- filter(fed16_pos, final.shot >= 10)
```
```{r}
longest_df <- filter(fed16_pos, final.shot == 17)
```


```{r}
longest_pos <- filter(fed16_pos, final.shot == 17)
longral_pos <- filter(fed16_pos, final.shot >= 10)
```


```{r}
seventythree_df <- filter(longral_pos, rally.number=="73")

```




```{r}
fed16_only[is.na(fed16_only)] <- 0

write.csv(longral_pos,"longral.csv")
write.csv(seventythree_df,"longest.csv")
write.csv(fed16_only, "data/fed16_only.csv")
```

##Fed vs Berdych 2017 Data
```{r  }

#Reorienting shots so that all Federer's shot are from negative x side of court, and all opponents shots are from positive x side. y coordinates have been flipped as required.
fed17_df <- fed17_df %>% rowwise %>%
  mutate(projected.ballmark.y = ifelse(impact.player == "FEDERER" & start.x >= 0, -projected.ballmark.y, projected.ballmark.y)) %>%
  mutate(start.y = ifelse(impact.player == "FEDERER" & start.x >= 0, -start.y, start.y))%>%
  mutate(projected.ballmark.x = ifelse(impact.player == "FEDERER" & start.x >= 0, -projected.ballmark.x, projected.ballmark.x)) %>%
  mutate(start.x = ifelse(impact.player == "FEDERER" & start.x >= 0, -start.x, start.x)) 

#Reorienting opponent shots
fed17_df <- fed17_df %>% rowwise %>%
  mutate(start.y = ifelse(impact.player != "FEDERER" & start.x <= 0, -start.y, start.y)) %>%
  mutate(projected.ballmark.y = ifelse(impact.player != "FEDERER" & start.x <= 0, -projected.ballmark.y, projected.ballmark.y)) %>%
  mutate(projected.ballmark.x = ifelse(impact.player != "FEDERER" & start.x <= 0, -projected.ballmark.x, projected.ballmark.x)) %>%
  mutate(start.x = ifelse(impact.player != "FEDERER" & start.x <= 0, -start.x, start.x))
```


```{r }

#Reorienting player positions so that all Federer's & Opponents start/end positions match reoriented ballmarks
#For Federer
fed17_df <- fed17_df %>% rowwise %>%
  mutate(start.server.y = ifelse(server == "FEDERER" & start.server.x >= 0, -start.server.y, start.server.y)) %>%
  mutate(start.receiver.y = ifelse(receiver == "FEDERER" & start.receiver.x >= 0, -start.receiver.y, start.receiver.y))%>%
  mutate(end.server.y = ifelse(server == "FEDERER" & end.server.x >= 0, -end.server.y, end.server.y)) %>%
  mutate(end.receiver.y = ifelse(receiver == "FEDERER" & end.receiver.x >= 0, -end.receiver.y, end.receiver.y))%>%
  mutate(start.server.x = ifelse(server == "FEDERER" & start.server.x >= 0, -start.server.x, start.server.x)) %>%
  mutate(start.receiver.x = ifelse(receiver == "FEDERER" & start.receiver.x >= 0, -start.receiver.x, start.receiver.x)) 

fed17_df <- fed17_df %>% rowwise %>%
  mutate(end.server.x = ifelse(server == "FEDERER" & end.server.x >= 0, -end.server.x, end.server.x)) %>%
  mutate(end.receiver.x = ifelse(receiver == "FEDERER" & end.receiver.x >= 0, -end.receiver.x, end.receiver.x)) 
```

```{r }


#For Opponent
fed17_df <- fed17_df %>% rowwise %>%
  mutate(start.server.y = ifelse(server != "FEDERER" & start.server.x <= 0, -start.server.y, start.server.y)) %>%
  mutate(start.receiver.y = ifelse(receiver != "FEDERER" & start.receiver.x <= 0, -start.receiver.y, start.receiver.y))%>%
  mutate(end.server.y = ifelse(server != "FEDERER" & end.server.x <= 0, -end.server.y, end.server.y)) %>%
  mutate(end.receiver.y = ifelse(receiver != "FEDERER" & end.receiver.x <= 0, -end.receiver.y, end.receiver.y))%>%
  mutate(start.server.x = ifelse(server != "FEDERER" & start.server.x <= 0, -start.server.x, start.server.x)) %>%
  mutate(start.receiver.x = ifelse(receiver != "FEDERER" & start.receiver.x <= 0, -start.receiver.x, start.receiver.x)) 

fed17_df <- fed17_df %>% rowwise %>%
  mutate(end.server.x = ifelse(server != "FEDERER" & end.server.x <= 0, -end.server.x, end.server.x)) %>%
  mutate(end.receiver.x = ifelse(receiver != "FEDERER" & end.receiver.x <= 0, -end.receiver.x, end.receiver.x)) 
```



```{r}
fed17_df <- fed17_df %>%
  mutate(lastshot = ifelse(shot == final.shot,1,0)) %>%
  mutate(isserver = ifelse(server == impact.player,1,0)) %>%
  mutate(fhand = ifelse(hitpoint == "F",1,0)) %>%
  mutate(opponent = ifelse(server == "FEDERER", receiver, server)) 
 

  

```





```{r}

fed17_df <- fed17_df %>%
  mutate(winner = ifelse(is.good == TRUE & lastshot == 1,1,0)) %>%
  mutate(ser1 = ifelse(serve == 1 & serve_classification == 1,1,0)) %>%
  mutate(ser2 = ifelse(serve == 2 & serve_classification == 1,1,0)) 
  
for (i in 1:ncol(fed17_df)) {
  if(is.character(fed17_df[,i]) == TRUE) {
    fed17_df[,i] <- as.factor(fed17_df[,i])
  }
}
```

```{r}
#Combining winner, return into play and error into 1 column for three states in hidden markov model
#If ball is in play and the shot is a winner value of 1
#If ball is in play and the shot is not a winner value of 0
#If the ball is out of play and thus not a winner value of -1

fed17_df <- fed17_df %>%
  mutate(winner.return.error = ifelse(is.good =="TRUE" & winner == "1",1,
                ifelse(is.good =="TRUE" & winner == "0",0,-1)))
```

```{r}
col = c("set","game", "point")
rally.numfed17 = as.data.frame(group_indices_(fed17_df,.dots = col))
colnames(rally.numfed17)<- "rally.number"
```

```{r}


fed17_df <- fed17_df %>%
  cbind(rally.numfed17)
 
```



```{r}

#start/end player positions x/y
fed17_df <- fed17_df %>%
  mutate(oppo.start.position.x = ifelse(server != "FEDERER", start.server.x,0)+ifelse(server == "FEDERER", start.receiver.x,0))%>%
  mutate(oppo.start.position.y = ifelse(server != "FEDERER", start.server.y,0)+ifelse(server == "FEDERER", start.receiver.y,0)) %>%
  mutate(oppo.end.position.x = ifelse(server != "FEDERER", end.server.x,0)+ifelse(server == "FEDERER", end.receiver.x,0)) %>%
  mutate(oppo.end.position.y = ifelse(server != "FEDERER", end.server.y,0)+ifelse(server == "FEDERER", end.receiver.y,0)) %>%
  mutate(p.start.position.x = ifelse(server == "FEDERER", start.server.x,0)+ifelse(server != "FEDERER", start.receiver.x,0)) %>%
  mutate(p.start.position.y = ifelse(server == "FEDERER", start.server.y,0)+ifelse(server != "FEDERER", start.receiver.y,0)) %>%
  mutate(p.end.position.x = ifelse(server == "FEDERER", end.server.x,0)+ifelse(server != "FEDERER", end.receiver.x,0)) %>%
  mutate(p.end.position.y = ifelse(server == "FEDERER", end.server.y,0)+ifelse(server != "FEDERER", end.receiver.y,0)) 
  
#player and opponent distances travelled from start of shot to end of next shot
fed17_df <- fed17_df %>%  
  mutate(oppo.distance = ifelse(server != "FEDERER", server.distance,0)+ifelse(server == "FEDERER", receiver.distance,0)) %>%
  mutate(p.distance = ifelse(server == "FEDERER", server.distance,0)+ifelse(server != "FEDERER", receiver.distance,0))

#player and opponent speed 
fed17_df <- fed17_df %>%
  mutate(p.peak.speed = ifelse(server == "FEDERER", server.peak.speed,0)+ifelse(server != "FEDERER", receiver.peak.speed,0)) %>%
  mutate(p.avg.speed = ifelse(server == "FEDERER", server.avg.speed,0)+ifelse(server != "FEDERER", receiver.avg.speed,0)) 
  

#player and opponent acceleration
fed17_df <- fed17_df %>%  
  mutate(p.avg.acceleration = ifelse(server == "FEDERER", server.avg.acceleration,0)+ifelse(server != "FEDERER", receiver.avg.acceleration,0)) %>%
  mutate(p.peak.acceleration = ifelse(server == "FEDERER", server.peak.acceleration,0)+ifelse(server != "FEDERER", receiver.peak.acceleration,0)) %>%
  mutate(oppo.peak.speed = ifelse(server != "FEDERER", server.peak.speed,0)+ifelse(server == "FEDERER", receiver.peak.speed,0)) %>%
  mutate(oppo.avg.speed = ifelse(server != "FEDERER", server.avg.speed,0)+ifelse(server == "FEDERER", receiver.avg.speed,0)) %>%
  mutate(oppo.avg.acceleration = ifelse(server != "FEDERER", server.avg.acceleration,0)+ifelse(server == "FEDERER", receiver.avg.acceleration,0)) %>%
  mutate(oppo.peak.acceleration = ifelse(server != "FEDERER", server.peak.acceleration,0)+ifelse(server == "FEDERER", receiver.peak.acceleration,0))


#player and opponent work
fed17_df <- fed17_df %>%
  mutate(oppo.work = ifelse(server != "FEDERER", server.work,0)+ifelse(server == "FEDERER", receiver.work,0)) %>%
  mutate(p.work = ifelse(server == "FEDERER", server.work,0)+ifelse(server != "FEDERER", receiver.work,0)) 

#player and opponent advantage
fed17_df <- fed17_df %>%
  mutate(oppo.advantage =ifelse(server != "FEDERER", server.advantage,0)+ifelse(server == "FEDERER", receiver.advantage,0))%>%
   mutate(p.advantage =ifelse(server == "FEDERER", server.advantage,0)+ifelse(server != "FEDERER", receiver.advantage,0))


#player and opponent total changes
fed17_df <- fed17_df %>%
  mutate(oppo.total.changes =ifelse(server != "FEDERER", server.total.changes,0)+ifelse(server == "FEDERER", receiver.total.changes,0))%>%
   mutate(p.total.changes =ifelse(server == "FEDERER", server.total.changes,0)+ifelse(server != "FEDERER", receiver.total.changes,0))
  
  
```


```{r}

#player speed and acceleration differences and ratios
fed17_df <- fed17_df %>%
  mutate(avg.player.speed.diff = p.avg.speed-oppo.avg.speed) %>%
  mutate(peak.player.speed.diff = p.peak.speed-oppo.peak.speed) %>%
  mutate(avg.player.speed.ratio = p.avg.speed/oppo.avg.speed) %>%
  mutate(peak.player.speed.ratio = p.peak.speed/oppo.peak.speed) %>%
  mutate(avg.player.acceleration.diff = (p.avg.acceleration)-(oppo.avg.acceleration)) %>%
  mutate(peak.player.acceleration.diff = (p.peak.acceleration)-(oppo.peak.acceleration)) %>%
  mutate(avg.player.acceleration.ratio = (p.avg.acceleration)/(oppo.avg.acceleration)) %>%
  mutate(peak.player.acceleration.ratio = (p.peak.acceleration)/(oppo.peak.acceleration)) 

fed17_df[is.na(fed17_df)] <- 0
  
fed17_df <- fed17_df %>%  
  mutate(p.avg.speed.match = mean(p.avg.speed)) %>%
  mutate(oppo.avg.speed.match = mean(oppo.avg.speed)) %>%
  mutate(p.diff.avg.shot.and.match.movement.speed = p.avg.speed - p.avg.speed.match) %>%
  mutate(oppo.diff.avg.shot.and.match.movement.speed = oppo.avg.speed - oppo.avg.speed.match)
  

#player/opponent side distance for start/end positions
fed17_df <- fed17_df %>%
  mutate(p.start.position.side.dist = 4.115 - abs(p.start.position.y)) %>%
  mutate(p.end.position.side.dist = 4.115 - abs(p.end.position.y)) %>%
  mutate(oppo.start.position.side.dist = 4.115 - abs(oppo.start.position.y)) %>%
  mutate(oppo.end.position.side.dist = 4.115 - abs(oppo.end.position.y))
  
#player/opponent base distances for start/end positions  
fed17_df <- fed17_df %>%
  mutate(p.start.position.base.dist = 11.89 - abs(p.start.position.x)) %>%
  mutate(p.end.position.base.dist = 11.89 - abs(p.end.position.x)) %>%
  mutate(oppo.start.position.base.dist = 11.89 - abs(oppo.start.position.x)) %>%
  mutate(oppo.end.position.base.dist = 11.89 - abs(oppo.end.position.x)) %>%
  mutate(oppo.start.position.base.diff = p.start.position.base.dist - oppo.start.position.base.dist) %>%
  mutate(p.start.position.base.diff = oppo.start.position.base.dist -p.start.position.base.dist) %>%
  mutate(oppo.end.position.base.diff = p.end.position.base.dist - oppo.end.position.base.dist) %>%
  mutate(p.end.position.base.diff = oppo.end.position.base.dist -p.end.position.base.dist) %>%
  mutate(p.start.position.centre.diff = abs(oppo.start.position.y)-abs(p.start.position.y)) %>%
  mutate(p.end.position.centre.diff = abs(oppo.end.position.y)-abs(p.end.position.y)) %>%
  mutate(oppo.start.position.centre.diff = abs(p.start.position.y)-abs(oppo.start.position.y)) %>%
  mutate(oppo.end.position.centre.diff = abs(p.end.position.y)-abs(oppo.end.position.y))
  
  
```



```{r}
#player/ opponent shortest distances for start/end positions 
fed17_df <- fed17_df %>%
  mutate(oppo.start.position.short.dist = min(oppo.start.position.side.dist, oppo.start.position.base.dist)) %>%
   mutate(oppo.end.position.short.dist = min(oppo.end.position.side.dist, oppo.end.position.base.dist)) %>%
  mutate(p.start.position.short.dist = min(p.start.position.side.dist, p.start.position.base.dist)) %>%
   mutate(p.end.position.short.dist = min(p.end.position.side.dist, p.end.position.base.dist)) 
```



```{r}

#Tally of the number of times player and opponent change side during rally
#Defining change of side as having travelled from a location 2.0575 or more metres away from the centre on one side of the court (half the distance between centre and singles lines) to a location 2.0575 or more metres away from the centre on the other side of the court
fed17_df <- fed17_df %>%
  mutate(p.side.change.count = ifelse(p.start.position.y <= -2.0575 & p.end.position.y >= 2.0575, 1, ifelse(p.start.position.y >= 2.0575 & p.end.position.y <= -2.0575, 1, 0))) %>%
  mutate(p.side.change.cumsum = cumsum(p.side.change.count)) %>%
  mutate(oppo.side.change.count = ifelse(oppo.start.position.y <= -2.0575 & oppo.end.position.y >= 2.0575, 1, ifelse(oppo.start.position.y >= 2.0575 & oppo.end.position.y <= -2.0575, 1, 0))) %>%
  mutate(oppo.side.change.cumsum = cumsum(oppo.side.change.count)) 
  


  
  
```

```{r}
#Within rally tally of side change count and distance run
fed17_df <- fed17_df %>%
  group_by(rally.number ) %>%
  dplyr::mutate(p.rally.side.change.count = cumsum(p.side.change.count)) %>%
  dplyr::mutate(oppo.rally.side.change.count = cumsum(oppo.side.change.count)) %>%
  dplyr::mutate(rally.side.change.count.diff = p.rally.side.change.count-oppo.rally.side.change.count) %>%
  dplyr::mutate(oppo.rally.distance.run = cumsum(oppo.distance)) %>%
  dplyr::mutate(p.rally.distance.run = cumsum(p.distance)) %>%
  dplyr::mutate(rally.distance.run.ratio = p.rally.distance.run/oppo.rally.distance.run) %>%
  ungroup
 
```
```{r}
#Seperating height over net of shots for player and opponent.

fed17_df <- fed17_df %>%
  mutate(p.height.off.net = ifelse(impact.player == "FEDERER",height.off.net,0)) %>%
  mutate(oppo.height.off.net = ifelse(impact.player != "FEDERER", height.off.net,0)) 
  
```


```{r}
#Adding angles for player & opposition movement from start position[i] to end position[i] as well as end position[i] to start position[i+1]. Measuring the angle of movement from the baseline. Directly towards the net is 0 deg. Directly away from the net is 180 deg.


fed17_df <- fed17_df %>%
  mutate(p.movement.angle.1 = NA) %>%
  mutate(p.movement.angle.2 = NA) %>%
  mutate(oppo.movement.angle.1 = NA) %>%
  mutate(oppo.movement.angle.2 = NA) 
  
  
#player start to end movement angle  
for (i in 1:nrow(fed17_df)) {
  a1 <- fed17_df$p.start.position.x[i]
  b1 <- fed17_df$p.start.position.y[i]
  a2 <- fed17_df$p.end.position.x[i]
  b2 <- fed17_df$p.end.position.y[i]
  
  
  p.movement.angle.1 <- atan(
  ((abs(b1)-abs(b2))/(abs(a1)-abs(a2)))* 180/pi) 
  
  fed17_df$p.movement.angle.1[i] = ifelse(p.movement.angle.1 < 0 & (abs(a1)-abs(a2))<0, 180+p.movement.angle.1,
                                          ifelse(p.movement.angle.1 < 0 & (abs(b1)-abs(b2))<0,abs(p.movement.angle.1),
                                                 ifelse(p.movement.angle.1 > 0 & (abs(a1)-abs(a2))<0, 90+p.movement.angle.1,p.movement.angle.1)))
                                                                                                            
}



```
```{r}
#player end position(i) to start position (i+1) movement angle
for (i in 2:nrow(fed17_df)) {
  a1 <- fed17_df$p.end.position.x[i]
  b1 <- fed17_df$p.end.position.y[i]
  a2 <- fed17_df$p.start.position.x[i+1]
  b2 <- fed17_df$p.start.position.y[i+1]
  
  p.movement.angle.2 <- atan(
  ((abs(b1)-abs(b2))/(abs(a1)-abs(a2)))* 180/pi) 
  
  fed17_df$p.movement.angle.2[i] = ifelse(p.movement.angle.2 < 0 & (abs(a1)-abs(a2))<0, 180+p.movement.angle.2,
                                          ifelse(p.movement.angle.2 < 0 & (abs(b1)-abs(b2))<0,abs(p.movement.angle.2),
                                                 ifelse(p.movement.angle.2 > 0 & (abs(a1)-abs(a2))<0, 90+p.movement.angle.2,p.movement.angle.2)))
  
}  
  


```

```{r}
# opposition start to end movement angle

  
for (i in 1:nrow(fed17_df)) {
  a1 <- fed17_df$oppo.start.position.x[i]
  b1 <- fed17_df$oppo.start.position.y[i]
  a2 <- fed17_df$oppo.end.position.x[i]
  b2 <- fed17_df$oppo.end.position.y[i]
  
  oppo.movement.angle.1 <- atan(
  ((abs(b1)-abs(b2))/(abs(a1)-abs(a2)))* 180/pi) 
  
  fed17_df$oppo.movement.angle.1[i] = ifelse(oppo.movement.angle.1 < 0 & (abs(a1)-abs(a2))<0,180+oppo.movement.angle.1,
                                          ifelse(oppo.movement.angle.1 < 0 & (abs(b1)-abs(b2))<0,abs(oppo.movement.angle.1),
                                                 ifelse(oppo.movement.angle.1 > 0 & (abs(a1)-abs(a2))<0,90+oppo.movement.angle.1,p.movement.angle.1)))
  
  
}
```
```{r}
#oppositions end[i] to start [i+1] movement angle
for (i in 2:nrow(fed17_df)) {
  a1 <- fed17_df$oppo.end.position.x[i]
  b1 <- fed17_df$oppo.end.position.y[i]
  a2 <- fed17_df$oppo.start.position.x[i+1]
  b2 <- fed17_df$oppo.start.position.y[i+1]
  
  oppo.movement.angle.2 <- atan(
  ((abs(b1)-abs(b2))/(abs(a1)-abs(a2)))* 180/pi) 
  
  fed17_df$oppo.movement.angle.2[i] = ifelse(oppo.movement.angle.2 < 0 & (abs(a1)-abs(a2))<0, 180+oppo.movement.angle.2,
                                          ifelse(oppo.movement.angle.2 < 0 & (abs(b1)-abs(b2))<0,abs(oppo.movement.angle.2),
                                                 ifelse(oppo.movement.angle.2 > 0 & (abs(a1)-abs(a2))<0, 90+oppo.movement.angle.2,oppo.movement.angle.2)))
}
```

```{r}
#speed of player ad opponent shots in m/s at the start of the shot arc
fed17_df<- fed17_df %>%
  mutate(p.start.shot.speed = ifelse(impact.player == "FEDERER", speed.start, 0)) %>%
  mutate(oppo.start.shot.speed = ifelse(impact.player != "FEDERER", speed.start, 0)) 
```

```{r}
#code for this chunk relatively unchanged
# replaced ballmark.x with projected.ballmark.x; speed1 replaced by speed.start

fed17_df <- fed17_df %>%
  mutate(speed.diff = NA) %>%
  mutate(oppo.hit.x = NA) %>%
  mutate(oppo.hit.y = NA) %>%
  mutate(oppo.hit.z = NA) %>%
  mutate(oppo.speed = NA) %>%
  mutate(oppo.projected.ballmark.x = NA) %>%
  mutate(oppo.projected.ballmark.y = NA) %>%
  mutate(speed.ratio = NA) 


for (i in 2:nrow(fed17_df)) {
  if(fed17_df$shot[i] != 1) {#so that only non-serves are affected

  fed17_df$speed.diff[i]=fed17_df$speed.start[i]-fed17_df$speed.start[i-1]
  #speed difference
  
  fed17_df$oppo.hit.x[i]=fed17_df$start.x[i-1]
  fed17_df$oppo.hit.y[i]=fed17_df$start.y[i-1]
  fed17_df$oppo.hit.z[i]=fed17_df$start.z[i-1]
  fed17_df$oppo.speed[i]=fed17_df$speed.start[i-1]
  fed17_df$oppo.projected.ballmark.x[i]=fed17_df$projected.ballmark.x[i-1]
  fed17_df$oppo.projected.ballmark.y[i]=fed17_df$projected.ballmark.y[i-1]
  #oppo hit
  
  }
}

fed17_df <- fed17_df %>%
  mutate(speed.ratio = speed.start/oppo.speed) %>% #speed ratio
  mutate(side.dist = 4.115 - abs(oppo.projected.ballmark.y)) %>% #distance of oppo.projected.ballmark from sideline
  mutate(base.dist = 11.89 - abs(oppo.projected.ballmark.x)) %>% #distance of oppo.projected.ballmark from baseline
  mutate(short.dist = min(side.dist, base.dist)) #shortest distance from any line


#Adding angles
fed17_df <- fed17_df %>%
  mutate(p.start.shot.x = NA) %>%
  mutate(p.start.shot.y = NA)

for (i in 3:nrow(fed17_df)) {
  if(fed17_df$impact.player[i] == fed17_df$impact.player[i-2] & fed17_df$shot[i] == fed17_df$shot[i-2] + 2) {
    fed17_df$p.start.shot.x[i]=fed17_df$start.x[i-2]
    fed17_df$p.start.shot.y[i]=fed17_df$start.y[i-2]
  }
}

#adding angle between fed.shot-opp.shot vector and opp.shot-opp.projected.ballmark vector
#doing it in one line because df doesn't want to add vectors
fed17_df <- fed17_df %>%
  mutate(o.angle = NA)
  
for (i in 1:nrow(fed17_df)) {
  x1 <- fed17_df$p.start.shot.x[i]
  y1 <- fed17_df$p.start.shot.y[i]
  x2 <- fed17_df$oppo.hit.x[i]
  y2 <- fed17_df$oppo.hit.y[i]
  x3 <- fed17_df$oppo.projected.ballmark.x[i]
  y3 <- fed17_df$oppo.projected.ballmark.y[i]
  
  o.angle <- acos(
  ((c(x1,y1)-c(x2,y2))/sqrt((x1-x2)^2+(y1-y2)^2)) %*%
    ((c(x2,y2)-c(x3,y3))/sqrt((x2-x3)^2+(y2-y3)^2))) * 180/pi
  
  fed17_df$o.angle[i] = ifelse(o.angle > 90, 180-o.angle, o.angle)
}

#Now adding the angle the player hits
fed17_df <- fed17_df %>%
  mutate(p.angle = NA)
  
for (i in 1:nrow(fed17_df)) {
  x1 <- fed17_df$oppo.hit.x[i]
  y1 <- fed17_df$oppo.hit.y[i]
  x2 <- fed17_df$start.x[i]
  y2 <- fed17_df$start.y[i]
  x3 <- fed17_df$projected.ballmark.x[i]
  y3 <- fed17_df$projected.ballmark.y[i]
  
  p.angle <- acos(
  ((c(x1,y1)-c(x2,y2))/sqrt((x1-x2)^2+(y1-y2)^2)) %*%
    ((c(x2,y2)-c(x3,y3))/sqrt((x2-x3)^2+(y2-y3)^2))) * 180/pi
  
  fed17_df$p.angle[i] = ifelse(p.angle > 90, 180-p.angle, p.angle)
}

fed17_df <- fed17_df %>%
  group_by(rally.number) %>%
  mutate(lag.p.angle = dplyr::lag(p.angle, n = 1, default = NA)) %>%
  mutate(lag.speed.ratio = dplyr::lag(speed.ratio, n = 1, default = NA)) %>%
  mutate(lag.p.movement.angle.1 = dplyr::lag(p.movement.angle.1, n = 1, default = NA)) %>%
  mutate(lag.p.movement.angle.2 = dplyr::lag(p.movement.angle.2, n = 1, default = NA)) %>%
  mutate(lag.oppo.height.off.net = dplyr::lag(oppo.height.off.net, n = 1, default = NA)) %>%
  mutate(lag.p.start.shot.speed = dplyr::lag(p.start.shot.speed, n = 1, default = NA)) %>%
  mutate(lag.oppo.start.shot.speed = dplyr::lag(oppo.start.shot.speed, n = 1, default = NA)) %>%
  ungroup


```





```{r}
fed17_df <- fed17_df %>%
  mutate(oppo.start.server.x = ifelse(server != "FEDERER", start.server.x, 0)) 
```



```{r  }

#creating new rows so that every second row start and end player positions are switched
#Also creating new rows so that every second row in start.x,/start.y is projected ballmark
#this allows us to better plot player positions as well as track positions for animations

joinfed17_df <- transform(fed17_df, p.start.position.x=p.end.position.x, p.start.position.y=p.end.position.y, oppo.start.position.x=oppo.end.position.x, oppo.start.position.y=oppo.end.position.y, start.x=projected.ballmark.x, start.y=projected.ballmark.y)

fed17_pos <- bind_rows(fed17_df, setNames(joinfed17_df, names(fed17_df))) %>% 
           arrange(rally.number, shot)

fed17_pos <- fed17_pos %>%
  group_by(rally.number, idx = cumsum(event == 1L)) %>%
  mutate(location.id= row_number()) %>%
  ungroup

fed17_pos <- fed17_pos %>%
  group_by(rally.number) %>%
  mutate(pos.rally.count= 1:n()) %>%
  ungroup
``` 





```{r }
#remove opponents
fed17_no.opp <- fed17_df %>% 
  dplyr::filter(impact.player == "FEDERER")

#federer only - remove serves
fed17_only <- fed17_no.opp %>%
  filter(hitpoint != "S") %>%
  dplyr::select(-serveid)


#First remove any errors for start, projected.ballmark, so that we are only looking at shots that we hit onto the other side
#To check: ggplot(fed17_only, aes(projected.ballmark.x, projected.ballmark.y)) + geom_point()
fed17_only <- fed17_only %>%
  filter(oppo.hit.x >= 0) %>%
  filter(oppo.projected.ballmark.x <= 0) %>%
  filter(projected.ballmark.x >= 0)

#Adding shot number cumulative count (functions as time)
#check this for new data set .
fed17_only <- fed17_only %>%
  mutate(count = 1)

  for (i in 2:nrow(fed17_only)) {
    if(fed17_only$matchid[i]==fed17_only$matchid[i-1]) {
      fed17_only$count[i] = fed17_only$count[i-1] + 1
    }
  }

  

#Adjusting to remove NAs and replace with 0s for modelling
fed17_only$o.angle[is.na(fed17_only$o.angle)] <- 0
fed17_only$lag.p.angle[is.na(fed17_only$lag.p.angle)] <- 0
fed17_only$lag.speed.ratio[is.na(fed17_only$lag.speed.ratio)] <- 0
fed17_only$p.start.shot.x[is.na(fed17_only$p.start.shot.x)] <- 0
fed17_only$p.start.shot.y[is.na(fed17_only$p.start.shot.y)] <- 0
fed17_only$lag.p.movement.angle.1[is.na(fed17_only$lag.p.movement.angle.1)] <- 0
fed17_only$lag.p.movement.angle.2[is.na(fed17_only$lag.p.movement.angle.2)] <- 0
fed17_only$lag.oppo.height.off.net[is.na(fed17_only$lag.oppo.height.off.net)] <- 0



fed17_only <- fed17_only %>% mutate(player.total.shot.number = row_number())
```


```{r}
#variables for speed of ball at the start of shot arcs

fed17_only <- fed17_only %>%
  mutate(avg.p.start.shot.speed = mean(p.start.shot.speed)) %>%
  mutate(avg.lag.oppo.start.shot.speed = mean(lag.oppo.start.shot.speed)) %>%
  mutate(diff.p.avg.and.current.shot.speed = p.start.shot.speed- avg.p.start.shot.speed) %>%
  mutate(diff.lag.oppo.avg.and.current.shot.speed = lag.oppo.start.shot.speed- avg.lag.oppo.start.shot.speed) 


  
```



```{r}
#making y positions absolute for fed17_only as this is more relevant for the depmix model

fed17_only <- fed17_only %>%
  mutate(p.start.position.y = abs(p.start.position.y)) %>%
  mutate(p.end.position.y = abs(p.end.position.y)) %>%
  mutate(oppo.start.position.y = abs(oppo.start.position.y)) %>%
  mutate(oppo.end.position.y = abs(oppo.end.position.y))%>%
  mutate(p.start.shot.y =abs(p.start.shot.y))
  
  

```
```{r}
#Save output
fed17_only[is.na(fed17_only)] <- 0
write.csv(fed17_only, "data/fed17_only.csv")
```

##Fed vs Berdych 2018 Data 
```{r  }

#Reorienting shots so that all Federer's shot are from negative x side of court, and all opponents shots are from positive x side. y coordinates have been flipped as required.
fed18_df <- fed18_df %>% rowwise %>%
  mutate(projected.ballmark.y = ifelse(impact.player == "FEDERER" & start.x >= 0, -projected.ballmark.y, projected.ballmark.y)) %>%
  mutate(start.y = ifelse(impact.player == "FEDERER" & start.x >= 0, -start.y, start.y))%>%
  mutate(projected.ballmark.x = ifelse(impact.player == "FEDERER" & start.x >= 0, -projected.ballmark.x, projected.ballmark.x)) %>%
  mutate(start.x = ifelse(impact.player == "FEDERER" & start.x >= 0, -start.x, start.x)) 

#Reorienting opponent shots
fed18_df <- fed18_df %>% rowwise %>%
  mutate(start.y = ifelse(impact.player != "FEDERER" & start.x <= 0, -start.y, start.y)) %>%
  mutate(projected.ballmark.y = ifelse(impact.player != "FEDERER" & start.x <= 0, -projected.ballmark.y, projected.ballmark.y)) %>%
  mutate(projected.ballmark.x = ifelse(impact.player != "FEDERER" & start.x <= 0, -projected.ballmark.x, projected.ballmark.x)) %>%
  mutate(start.x = ifelse(impact.player != "FEDERER" & start.x <= 0, -start.x, start.x))
```


```{r }

#Reorienting player positions so that all Federer's & Opponents start/end positions match reoriented ballmarks
#For Federer
fed18_df <- fed18_df %>% rowwise %>%
  mutate(start.server.y = ifelse(server == "FEDERER" & start.server.x >= 0, -start.server.y, start.server.y)) %>%
  mutate(start.receiver.y = ifelse(receiver == "FEDERER" & start.receiver.x >= 0, -start.receiver.y, start.receiver.y))%>%
  mutate(end.server.y = ifelse(server == "FEDERER" & end.server.x >= 0, -end.server.y, end.server.y)) %>%
  mutate(end.receiver.y = ifelse(receiver == "FEDERER" & end.receiver.x >= 0, -end.receiver.y, end.receiver.y))%>%
  mutate(start.server.x = ifelse(server == "FEDERER" & start.server.x >= 0, -start.server.x, start.server.x)) %>%
  mutate(start.receiver.x = ifelse(receiver == "FEDERER" & start.receiver.x >= 0, -start.receiver.x, start.receiver.x)) 

fed18_df <- fed18_df %>% rowwise %>%
  mutate(end.server.x = ifelse(server == "FEDERER" & end.server.x >= 0, -end.server.x, end.server.x)) %>%
  mutate(end.receiver.x = ifelse(receiver == "FEDERER" & end.receiver.x >= 0, -end.receiver.x, end.receiver.x)) 
```

```{r }


#For Opponent
fed18_df <- fed18_df %>% rowwise %>%
  mutate(start.server.y = ifelse(server != "FEDERER" & start.server.x <= 0, -start.server.y, start.server.y)) %>%
  mutate(start.receiver.y = ifelse(receiver != "FEDERER" & start.receiver.x <= 0, -start.receiver.y, start.receiver.y))%>%
  mutate(end.server.y = ifelse(server != "FEDERER" & end.server.x <= 0, -end.server.y, end.server.y)) %>%
  mutate(end.receiver.y = ifelse(receiver != "FEDERER" & end.receiver.x <= 0, -end.receiver.y, end.receiver.y))%>%
  mutate(start.server.x = ifelse(server != "FEDERER" & start.server.x <= 0, -start.server.x, start.server.x)) %>%
  mutate(start.receiver.x = ifelse(receiver != "FEDERER" & start.receiver.x <= 0, -start.receiver.x, start.receiver.x)) 

fed18_df <- fed18_df %>% rowwise %>%
  mutate(end.server.x = ifelse(server != "FEDERER" & end.server.x <= 0, -end.server.x, end.server.x)) %>%
  mutate(end.receiver.x = ifelse(receiver != "FEDERER" & end.receiver.x <= 0, -end.receiver.x, end.receiver.x)) 
```



```{r}
fed18_df <- fed18_df %>%
  mutate(lastshot = ifelse(shot == final.shot,1,0)) %>%
  mutate(isserver = ifelse(server == impact.player,1,0)) %>%
  mutate(fhand = ifelse(hitpoint == "F",1,0)) %>%
  mutate(opponent = ifelse(server == "FEDERER", receiver, server)) 
 

  

```



```{r}

fed18_df <- fed18_df %>%
  mutate(winner = ifelse(is.good == TRUE & lastshot == 1,1,0)) %>%
  mutate(ser1 = ifelse(serve == 1 & serve_classification == 1,1,0)) %>%
  mutate(ser2 = ifelse(serve == 2 & serve_classification == 1,1,0)) 
  
for (i in 1:ncol(fed18_df)) {
  if(is.character(fed18_df[,i]) == TRUE) {
    fed18_df[,i] <- as.factor(fed18_df[,i])
  }
}
```

```{r}
#Combining winner, return into play and error into 1 column for three states in hidden markov model
#If ball is in play and the shot is a winner value of 1
#If ball is in play and the shot is not a winner value of 0
#If the ball is out of play and thus not a winner value of -1

fed18_df <- fed18_df %>%
  mutate(winner.return.error = ifelse(is.good =="TRUE" & winner == "1",1,
                ifelse(is.good =="TRUE" & winner == "0",0,-1)))
```




```{r}
col = c("set","game", "point")
rally.numfed18 = as.data.frame(group_indices_(fed18_df,.dots = col))
colnames(rally.numfed18)<- "rally.number"
```

```{r}


fed18_df <- fed18_df %>%
  cbind(rally.numfed18)
 
```



```{r}

#start/end player positions x/y
fed18_df <- fed18_df %>%
  mutate(oppo.start.position.x = ifelse(server != "FEDERER", start.server.x,0)+ifelse(server == "FEDERER", start.receiver.x,0))%>%
  mutate(oppo.start.position.y = ifelse(server != "FEDERER", start.server.y,0)+ifelse(server == "FEDERER", start.receiver.y,0)) %>%
  mutate(oppo.end.position.x = ifelse(server != "FEDERER", end.server.x,0)+ifelse(server == "FEDERER", end.receiver.x,0)) %>%
  mutate(oppo.end.position.y = ifelse(server != "FEDERER", end.server.y,0)+ifelse(server == "FEDERER", end.receiver.y,0)) %>%
  mutate(p.start.position.x = ifelse(server == "FEDERER", start.server.x,0)+ifelse(server != "FEDERER", start.receiver.x,0)) %>%
  mutate(p.start.position.y = ifelse(server == "FEDERER", start.server.y,0)+ifelse(server != "FEDERER", start.receiver.y,0)) %>%
  mutate(p.end.position.x = ifelse(server == "FEDERER", end.server.x,0)+ifelse(server != "FEDERER", end.receiver.x,0)) %>%
  mutate(p.end.position.y = ifelse(server == "FEDERER", end.server.y,0)+ifelse(server != "FEDERER", end.receiver.y,0)) 
  
#player and opponent distances travelled from start of shot to end of next shot
fed18_df <- fed18_df %>%  
  mutate(oppo.distance = ifelse(server != "FEDERER", server.distance,0)+ifelse(server == "FEDERER", receiver.distance,0)) %>%
  mutate(p.distance = ifelse(server == "FEDERER", server.distance,0)+ifelse(server != "FEDERER", receiver.distance,0))

#player and opponent speed 
fed18_df <- fed18_df %>%
  mutate(p.peak.speed = ifelse(server == "FEDERER", server.peak.speed,0)+ifelse(server != "FEDERER", receiver.peak.speed,0)) %>%
  mutate(p.avg.speed = ifelse(server == "FEDERER", server.avg.speed,0)+ifelse(server != "FEDERER", receiver.avg.speed,0)) 
  

#player and opponent acceleration
fed18_df <- fed18_df %>%  
  mutate(p.avg.acceleration = ifelse(server == "FEDERER", server.avg.acceleration,0)+ifelse(server != "FEDERER", receiver.avg.acceleration,0)) %>%
  mutate(p.peak.acceleration = ifelse(server == "FEDERER", server.peak.acceleration,0)+ifelse(server != "FEDERER", receiver.peak.acceleration,0)) %>%
  mutate(oppo.peak.speed = ifelse(server != "FEDERER", server.peak.speed,0)+ifelse(server == "FEDERER", receiver.peak.speed,0)) %>%
  mutate(oppo.avg.speed = ifelse(server != "FEDERER", server.avg.speed,0)+ifelse(server == "FEDERER", receiver.avg.speed,0)) %>%
  mutate(oppo.avg.acceleration = ifelse(server != "FEDERER", server.avg.acceleration,0)+ifelse(server == "FEDERER", receiver.avg.acceleration,0)) %>%
  mutate(oppo.peak.acceleration = ifelse(server != "FEDERER", server.peak.acceleration,0)+ifelse(server == "FEDERER", receiver.peak.acceleration,0))


#player and opponent work
fed18_df <- fed18_df %>%
  mutate(oppo.work = ifelse(server != "FEDERER", server.work,0)+ifelse(server == "FEDERER", receiver.work,0)) %>%
  mutate(p.work = ifelse(server == "FEDERER", server.work,0)+ifelse(server != "FEDERER", receiver.work,0)) 

#player and opponent advantage
fed18_df <- fed18_df %>%
  mutate(oppo.advantage =ifelse(server != "FEDERER", server.advantage,0)+ifelse(server == "FEDERER", receiver.advantage,0))%>%
   mutate(p.advantage =ifelse(server == "FEDERER", server.advantage,0)+ifelse(server != "FEDERER", receiver.advantage,0))


#player and opponent total changes
fed18_df <- fed18_df %>%
  mutate(oppo.total.changes =ifelse(server != "FEDERER", server.total.changes,0)+ifelse(server == "FEDERER", receiver.total.changes,0))%>%
   mutate(p.total.changes =ifelse(server == "FEDERER", server.total.changes,0)+ifelse(server != "FEDERER", receiver.total.changes,0))
  
  
```
```{r}
fed18_df[is.na(fed18_df)] <- 0
```


```{r}

#player speed and acceleration differences and ratios
fed18_df <- fed18_df %>%
  mutate(avg.player.speed.diff = p.avg.speed-oppo.avg.speed) %>%
  mutate(peak.player.speed.diff = p.peak.speed-oppo.peak.speed) %>%
  mutate(avg.player.speed.ratio = p.avg.speed/oppo.avg.speed) %>%
  mutate(peak.player.speed.ratio = p.peak.speed/oppo.peak.speed) %>%
  mutate(avg.player.acceleration.diff = (p.avg.acceleration)-(oppo.avg.acceleration)) %>%
  mutate(peak.player.acceleration.diff = (p.peak.acceleration)-(oppo.peak.acceleration)) %>%
  mutate(avg.player.acceleration.ratio = (p.avg.acceleration)/(oppo.avg.acceleration)) %>%
  mutate(peak.player.acceleration.ratio = (p.peak.acceleration)/(oppo.peak.acceleration)) %>%
  mutate(p.avg.speed.match = mean(p.avg.speed)) %>%
  mutate(oppo.avg.speed.match = mean(oppo.avg.speed)) %>%
  mutate(p.diff.avg.shot.and.match.movement.speed = p.avg.speed - p.avg.speed.match) %>%
  mutate(oppo.diff.avg.shot.and.match.movement.speed = oppo.avg.speed - oppo.avg.speed.match)
  

#player/opponent side distance for start/end positions
fed18_df <- fed18_df %>%
  mutate(p.start.position.side.dist = 4.115 - abs(p.start.position.y)) %>%
  mutate(p.end.position.side.dist = 4.115 - abs(p.end.position.y)) %>%
  mutate(oppo.start.position.side.dist = 4.115 - abs(oppo.start.position.y)) %>%
  mutate(oppo.end.position.side.dist = 4.115 - abs(oppo.end.position.y))
  
#player/opponent base distances for start/end positions  
fed18_df <- fed18_df %>%
  mutate(p.start.position.base.dist = 11.89 - abs(p.start.position.x)) %>%
  mutate(p.end.position.base.dist = 11.89 - abs(p.end.position.x)) %>%
  mutate(oppo.start.position.base.dist = 11.89 - abs(oppo.start.position.x)) %>%
  mutate(oppo.end.position.base.dist = 11.89 - abs(oppo.end.position.x)) %>%
  mutate(oppo.start.position.base.diff = p.start.position.base.dist - oppo.start.position.base.dist) %>%
  mutate(p.start.position.base.diff = oppo.start.position.base.dist -p.start.position.base.dist) %>%
  mutate(oppo.end.position.base.diff = p.end.position.base.dist - oppo.end.position.base.dist) %>%
  mutate(p.end.position.base.diff = oppo.end.position.base.dist -p.end.position.base.dist) %>%
  mutate(p.start.position.centre.diff = abs(oppo.start.position.y)-abs(p.start.position.y)) %>%
  mutate(p.end.position.centre.diff = abs(oppo.end.position.y)-abs(p.end.position.y)) %>%
  mutate(oppo.start.position.centre.diff = abs(p.start.position.y)-abs(oppo.start.position.y)) %>%
  mutate(oppo.end.position.centre.diff = abs(p.end.position.y)-abs(oppo.end.position.y))
  
  
```
```{r}
#player/ opponent shortest distances for start/end positions 
fed18_df <- fed18_df %>%
  mutate(oppo.start.position.short.dist = min(oppo.start.position.side.dist, oppo.start.position.base.dist)) %>%
   mutate(oppo.end.position.short.dist = min(oppo.end.position.side.dist, oppo.end.position.base.dist)) %>%
  mutate(p.start.position.short.dist = min(p.start.position.side.dist, p.start.position.base.dist)) %>%
   mutate(p.end.position.short.dist = min(p.end.position.side.dist, p.end.position.base.dist)) 
```



```{r}

#Tally of the number of times player and opponent change side during rally
#Defining change of side as having travelled from a location 2.0575 or more metres away from the centre on one side of the court (half the distance between centre and singles lines) to a location 2.0575 or more metres away from the centre on the other side of the court
fed18_df <- fed18_df %>%
  mutate(p.side.change.count = ifelse(p.start.position.y <= -2.0575 & p.end.position.y >= 2.0575, 1, ifelse(p.start.position.y >= 2.0575 & p.end.position.y <= -2.0575, 1, 0))) %>%
  mutate(p.side.change.cumsum = cumsum(p.side.change.count)) %>%
  mutate(oppo.side.change.count = ifelse(oppo.start.position.y <= -2.0575 & oppo.end.position.y >= 2.0575, 1, ifelse(oppo.start.position.y >= 2.0575 & oppo.end.position.y <= -2.0575, 1, 0))) %>%
  mutate(oppo.side.change.cumsum = cumsum(oppo.side.change.count)) 
  


  
  
```

```{r}
#Within rally tally of side change count and distance run
fed18_df <- fed18_df %>%
  group_by(rally.number ) %>%
  dplyr::mutate(p.rally.side.change.count = cumsum(p.side.change.count)) %>%
  dplyr::mutate(oppo.rally.side.change.count = cumsum(oppo.side.change.count)) %>%
  dplyr::mutate(rally.side.change.count.diff = p.rally.side.change.count-oppo.rally.side.change.count) %>%
  dplyr::mutate(oppo.rally.distance.run = cumsum(oppo.distance)) %>%
  dplyr::mutate(p.rally.distance.run = cumsum(p.distance)) %>%
  dplyr::mutate(rally.distance.run.ratio = p.rally.distance.run/oppo.rally.distance.run) %>%
  ungroup
 
```
```{r}
#Seperating height over net of shots for player and opponent.

fed18_df <- fed18_df %>%
  mutate(p.height.off.net = ifelse(impact.player == "FEDERER",height.off.net,0)) %>%
  mutate(oppo.height.off.net = ifelse(impact.player != "FEDERER", height.off.net,0)) 
  
```


```{r}
#Adding angles for player & opposition movement from start position[i] to end position[i] as well as end position[i] to start position[i+1]. Measuring the angle of movement from the baseline. Directly towards the net is 0 deg. Directly away from the net is 180 deg.


fed18_df <- fed18_df %>%
  mutate(p.movement.angle.1 = NA) %>%
  mutate(p.movement.angle.2 = NA) %>%
  mutate(oppo.movement.angle.1 = NA) %>%
  mutate(oppo.movement.angle.2 = NA) 
  
  
#player start to end movement angle  
for (i in 1:nrow(fed18_df)) {
  a1 <- fed18_df$p.start.position.x[i]
  b1 <- fed18_df$p.start.position.y[i]
  a2 <- fed18_df$p.end.position.x[i]
  b2 <- fed18_df$p.end.position.y[i]
  
  
  p.movement.angle.1 <- atan(
  ((abs(b1)-abs(b2))/(abs(a1)-abs(a2)))* 180/pi) 
  
  fed18_df$p.movement.angle.1[i] = ifelse(p.movement.angle.1 < 0 & (abs(a1)-abs(a2))<0, 180+p.movement.angle.1,
                                          ifelse(p.movement.angle.1 < 0 & (abs(b1)-abs(b2))<0,abs(p.movement.angle.1),
                                                 ifelse(p.movement.angle.1 > 0 & (abs(a1)-abs(a2))<0, 90+p.movement.angle.1,p.movement.angle.1)))
                                                                                                            
}



```
```{r}
#player end position(i) to start position (i+1) movement angle
for (i in 2:nrow(fed18_df)) {
  a1 <- fed18_df$p.end.position.x[i]
  b1 <- fed18_df$p.end.position.y[i]
  a2 <- fed18_df$p.start.position.x[i+1]
  b2 <- fed18_df$p.start.position.y[i+1]
  
  p.movement.angle.2 <- atan(
  ((abs(b1)-abs(b2))/(abs(a1)-abs(a2)))* 180/pi) 
  
  fed18_df$p.movement.angle.2[i] = ifelse(p.movement.angle.2 < 0 & (abs(a1)-abs(a2))<0, 180+p.movement.angle.2,
                                          ifelse(p.movement.angle.2 < 0 & (abs(b1)-abs(b2))<0,abs(p.movement.angle.2),
                                                 ifelse(p.movement.angle.2 > 0 & (abs(a1)-abs(a2))<0, 90+p.movement.angle.2,p.movement.angle.2)))
  
}  
  


```

```{r}
# opposition start to end movement angle

  
for (i in 1:nrow(fed18_df)) {
  a1 <- fed18_df$oppo.start.position.x[i]
  b1 <- fed18_df$oppo.start.position.y[i]
  a2 <- fed18_df$oppo.end.position.x[i]
  b2 <- fed18_df$oppo.end.position.y[i]
  
  oppo.movement.angle.1 <- atan(
  ((abs(b1)-abs(b2))/(abs(a1)-abs(a2)))* 180/pi) 
  
  fed18_df$oppo.movement.angle.1[i] = ifelse(oppo.movement.angle.1 < 0 & (abs(a1)-abs(a2))<0,180+oppo.movement.angle.1,
                                          ifelse(oppo.movement.angle.1 < 0 & (abs(b1)-abs(b2))<0,abs(oppo.movement.angle.1),
                                                 ifelse(oppo.movement.angle.1 > 0 & (abs(a1)-abs(a2))<0,90+oppo.movement.angle.1,p.movement.angle.1)))
  
  
}
```
```{r}
#oppositions end[i] to start [i+1] movement angle
for (i in 2:nrow(fed18_df)) {
  a1 <- fed18_df$oppo.end.position.x[i]
  b1 <- fed18_df$oppo.end.position.y[i]
  a2 <- fed18_df$oppo.start.position.x[i+1]
  b2 <- fed18_df$oppo.start.position.y[i+1]
  
  oppo.movement.angle.2 <- atan(
  ((abs(b1)-abs(b2))/(abs(a1)-abs(a2)))* 180/pi) 
  
  fed18_df$oppo.movement.angle.2[i] = ifelse(oppo.movement.angle.2 < 0 & (abs(a1)-abs(a2))<0, 180+oppo.movement.angle.2,
                                          ifelse(oppo.movement.angle.2 < 0 & (abs(b1)-abs(b2))<0,abs(oppo.movement.angle.2),
                                                 ifelse(oppo.movement.angle.2 > 0 & (abs(a1)-abs(a2))<0, 90+oppo.movement.angle.2,oppo.movement.angle.2)))
}
```
```{r}
#speed of player ad opponent shots in m/s at the start of the shot arc
fed18_df<- fed18_df %>%
  mutate(p.start.shot.speed = ifelse(impact.player == "FEDERER", speed.start, 0)) %>%
  mutate(oppo.start.shot.speed = ifelse(impact.player != "FEDERER", speed.start, 0)) 
```


```{r}
#code for this chunk relatively unchanged
# replaced ballmark.x with projected.ballmark.x; speed1 replaced by speed.start

fed18_df <- fed18_df %>%
  mutate(speed.diff = NA) %>%
  mutate(oppo.hit.x = NA) %>%
  mutate(oppo.hit.y = NA) %>%
  mutate(oppo.hit.z = NA) %>%
  mutate(oppo.speed = NA) %>%
  mutate(oppo.projected.ballmark.x = NA) %>%
  mutate(oppo.projected.ballmark.y = NA) %>%
  mutate(speed.ratio = NA) 


for (i in 2:nrow(fed18_df)) {
  if(fed18_df$shot[i] != 1) {#so that only non-serves are affected

  fed18_df$speed.diff[i]=fed18_df$speed.start[i]-fed18_df$speed.start[i-1]
  #speed difference
  
  fed18_df$oppo.hit.x[i]=fed18_df$start.x[i-1]
  fed18_df$oppo.hit.y[i]=fed18_df$start.y[i-1]
  fed18_df$oppo.hit.z[i]=fed18_df$start.z[i-1]
  fed18_df$oppo.speed[i]=fed18_df$speed.start[i-1]
  fed18_df$oppo.projected.ballmark.x[i]=fed18_df$projected.ballmark.x[i-1]
  fed18_df$oppo.projected.ballmark.y[i]=fed18_df$projected.ballmark.y[i-1]
  #oppo hit
  
  }
}

fed18_df <- fed18_df %>%
  mutate(speed.ratio = speed.start/oppo.speed) %>% #speed ratio
  mutate(side.dist = 4.115 - abs(oppo.projected.ballmark.y)) %>% #distance of oppo.projected.ballmark from sideline
  mutate(base.dist = 11.89 - abs(oppo.projected.ballmark.x)) %>% #distance of oppo.projected.ballmark from baseline
  mutate(short.dist = min(side.dist, base.dist)) #shortest distance from any line


#Adding angles
fed18_df <- fed18_df %>%
  mutate(p.start.shot.x = NA) %>%
  mutate(p.start.shot.y = NA)

for (i in 3:nrow(fed18_df)) {
  if(fed18_df$impact.player[i] == fed18_df$impact.player[i-2] & fed18_df$shot[i] == fed18_df$shot[i-2] + 2) {
    fed18_df$p.start.shot.x[i]=fed18_df$start.x[i-2]
    fed18_df$p.start.shot.y[i]=fed18_df$start.y[i-2]
  }
}

#adding angle between fed.shot-opp.shot vector and opp.shot-opp.projected.ballmark vector
#doing it in one line because df doesn't want to add vectors
fed18_df <- fed18_df %>%
  mutate(o.angle = NA)
  
for (i in 1:nrow(fed18_df)) {
  x1 <- fed18_df$p.start.shot.x[i]
  y1 <- fed18_df$p.start.shot.y[i]
  x2 <- fed18_df$oppo.hit.x[i]
  y2 <- fed18_df$oppo.hit.y[i]
  x3 <- fed18_df$oppo.projected.ballmark.x[i]
  y3 <- fed18_df$oppo.projected.ballmark.y[i]
  
  o.angle <- acos(
  ((c(x1,y1)-c(x2,y2))/sqrt((x1-x2)^2+(y1-y2)^2)) %*%
    ((c(x2,y2)-c(x3,y3))/sqrt((x2-x3)^2+(y2-y3)^2))) * 180/pi
  
  fed18_df$o.angle[i] = ifelse(o.angle > 90, 180-o.angle, o.angle)
}

#Now adding the angle the player hits
fed18_df <- fed18_df %>%
  mutate(p.angle = NA)
  
for (i in 1:nrow(fed18_df)) {
  x1 <- fed18_df$oppo.hit.x[i]
  y1 <- fed18_df$oppo.hit.y[i]
  x2 <- fed18_df$start.x[i]
  y2 <- fed18_df$start.y[i]
  x3 <- fed18_df$projected.ballmark.x[i]
  y3 <- fed18_df$projected.ballmark.y[i]
  
  p.angle <- acos(
  ((c(x1,y1)-c(x2,y2))/sqrt((x1-x2)^2+(y1-y2)^2)) %*%
    ((c(x2,y2)-c(x3,y3))/sqrt((x2-x3)^2+(y2-y3)^2))) * 180/pi
  
  fed18_df$p.angle[i] = ifelse(p.angle > 90, 180-p.angle, p.angle)
}

fed18_df <- fed18_df %>%
  group_by(rally.number) %>%
  mutate(lag.p.angle = dplyr::lag(p.angle, n = 1, default = NA)) %>%
  mutate(lag.speed.ratio = dplyr::lag(speed.ratio, n = 1, default = NA)) %>%
  mutate(lag.p.movement.angle.1 = dplyr::lag(p.movement.angle.1, n = 1, default = NA)) %>%
  mutate(lag.p.movement.angle.2 = dplyr::lag(p.movement.angle.2, n = 1, default = NA)) %>%
  mutate(lag.oppo.height.off.net = dplyr::lag(oppo.height.off.net, n = 1, default = NA)) %>%
  mutate(lag.p.start.shot.speed = dplyr::lag(p.start.shot.speed, n = 1, default = NA)) %>%
  mutate(lag.oppo.start.shot.speed = dplyr::lag(oppo.start.shot.speed, n = 1, default = NA)) %>%
  ungroup


```





```{r}
fed18_df <- fed18_df %>%
  mutate(oppo.start.server.x = ifelse(server != "FEDERER", start.server.x, 0)) 
```

```{r}
#fed18_df <- na.omit(fed18_df)
```


```{r  }

#creating new rows so that every second row start and end player positions are switched
#Also creating new rows so that every second row in start.x,/start.y is projected ballmark
#this allows us to better plot player positions as well as track positions for animations

joinfed18_df <- transform(fed18_df, p.start.position.x=p.end.position.x, p.start.position.y=p.end.position.y, oppo.start.position.x=oppo.end.position.x, oppo.start.position.y=oppo.end.position.y, start.x=projected.ballmark.x, start.y=projected.ballmark.y)

fed18_pos <- bind_rows(fed18_df, setNames(joinfed18_df, names(fed18_df))) %>% 
           arrange(rally.number, shot)

fed18_pos <- fed18_pos %>%
  group_by(rally.number, idx = cumsum(event == 1L)) %>%
  mutate(location.id= row_number()) %>%
  ungroup

fed18_pos <- fed18_pos %>%
  group_by(rally.number) %>%
  mutate(pos.rally.count= 1:n()) %>%
  ungroup
``` 






```{r }
#remove opponents
fed18_no.opp <- fed18_df %>% 
  dplyr::filter(impact.player == "FEDERER")

#federer only - remove serves
fed18_only <- fed18_no.opp %>%
  filter(hitpoint != "S") %>%
  dplyr::select(-serveid)


#First remove any errors for start, projected.ballmark, so that we are only looking at shots that we hit onto the other side
#To check: ggplot(fed18_only, aes(projected.ballmark.x, projected.ballmark.y)) + geom_point()
fed18_only <- fed18_only %>%
  filter(oppo.hit.x >= 0) %>%
  filter(oppo.projected.ballmark.x <= 0) %>%
  filter(projected.ballmark.x >= 0)

#Adding shot number cumulative count (functions as time)
#check this for new data set .
fed18_only <- fed18_only %>%
  mutate(count = 1)

  for (i in 2:nrow(fed18_only)) {
    if(fed18_only$matchid[i]==fed18_only$matchid[i-1]) {
      fed18_only$count[i] = fed18_only$count[i-1] + 1
    }
  }

  

#Adjusting to remove NAs and replace with 0s for modelling
fed18_only$o.angle[is.na(fed18_only$o.angle)] <- 0
fed18_only$lag.p.angle[is.na(fed18_only$lag.p.angle)] <- 0
fed18_only$lag.speed.ratio[is.na(fed18_only$lag.speed.ratio)] <- 0
fed18_only$p.start.shot.x[is.na(fed18_only$p.start.shot.x)] <- 0
fed18_only$p.start.shot.y[is.na(fed18_only$p.start.shot.y)] <- 0
fed18_only$lag.p.movement.angle.1[is.na(fed18_only$lag.p.movement.angle.1)] <- 0
fed18_only$lag.p.movement.angle.2[is.na(fed18_only$lag.p.movement.angle.2)] <- 0
fed18_only$lag.oppo.height.off.net[is.na(fed18_only$lag.oppo.height.off.net)] <- 0



fed18_only <- fed18_only %>% mutate(player.total.shot.number = row_number())
```

```{r}
#variables for difference of the current shot in m/s from the average speed of ball at the start of shot arcs

fed18_only<- fed18_only %>%
  mutate(avg.p.start.shot.speed = mean(p.start.shot.speed)) %>%
  mutate(avg.lag.oppo.start.shot.speed = mean(lag.oppo.start.shot.speed)) %>%
  mutate(diff.p.avg.and.current.shot.speed = p.start.shot.speed- avg.p.start.shot.speed) %>%
  mutate(diff.lag.oppo.avg.and.current.shot.speed = lag.oppo.start.shot.speed- avg.lag.oppo.start.shot.speed) 


  
```


```{r}
#making y positions absolute for fed18_only as this is more relevant for the depmix model

fed18_only <- fed18_only %>%
  mutate(p.start.position.y = abs(p.start.position.y)) %>%
  mutate(p.end.position.y = abs(p.end.position.y)) %>%
  mutate(oppo.start.position.y = abs(oppo.start.position.y)) %>%
  mutate(oppo.end.position.y = abs(oppo.end.position.y))%>%
  mutate(p.start.shot.y =abs(p.start.shot.y))
  
  

```
```{r}
#Save output & remove any NA's for modelling
fed18_only[is.na(fed18_only)] <- 0
write.csv(fed18_only, "data/fed18_only.csv")
```
##Strycova Vs Garcia 2016 Data




```{r  }

#Reorienting shots so that all STRYCOVA's shot are from negative x side of court, and all opponents shots are from positive x side. y coordinates have been flipped as required.
stry16_df <- stry16_df %>% rowwise %>%
  mutate(projected.ballmark.y = ifelse(impact.player == "STRYCOVA" & start.x >= 0, -projected.ballmark.y, projected.ballmark.y)) %>%
  mutate(start.y = ifelse(impact.player == "STRYCOVA" & start.x >= 0, -start.y, start.y))%>%
  mutate(projected.ballmark.x = ifelse(impact.player == "STRYCOVA" & start.x >= 0, -projected.ballmark.x, projected.ballmark.x)) %>%
  mutate(start.x = ifelse(impact.player == "STRYCOVA" & start.x >= 0, -start.x, start.x)) 

#Reorienting opponent shots
stry16_df <- stry16_df %>% rowwise %>%
  mutate(start.y = ifelse(impact.player != "STRYCOVA" & start.x <= 0, -start.y, start.y)) %>%
  mutate(projected.ballmark.y = ifelse(impact.player != "STRYCOVA" & start.x <= 0, -projected.ballmark.y, projected.ballmark.y)) %>%
  mutate(projected.ballmark.x = ifelse(impact.player != "STRYCOVA" & start.x <= 0, -projected.ballmark.x, projected.ballmark.x)) %>%
  mutate(start.x = ifelse(impact.player != "STRYCOVA" & start.x <= 0, -start.x, start.x))
```


```{r }

#Reorienting player positions so that all STRYCOVA's & Opponents start/end positions match reoriented ballmarks
#For STRYCOVA
stry16_df <- stry16_df %>% rowwise %>%
  mutate(start.server.y = ifelse(server == "STRYCOVA" & start.server.x >= 0, -start.server.y, start.server.y)) %>%
  mutate(start.receiver.y = ifelse(receiver == "STRYCOVA" & start.receiver.x >= 0, -start.receiver.y, start.receiver.y))%>%
  mutate(end.server.y = ifelse(server == "STRYCOVA" & end.server.x >= 0, -end.server.y, end.server.y)) %>%
  mutate(end.receiver.y = ifelse(receiver == "STRYCOVA" & end.receiver.x >= 0, -end.receiver.y, end.receiver.y))%>%
  mutate(start.server.x = ifelse(server == "STRYCOVA" & start.server.x >= 0, -start.server.x, start.server.x)) %>%
  mutate(start.receiver.x = ifelse(receiver == "STRYCOVA" & start.receiver.x >= 0, -start.receiver.x, start.receiver.x)) 

stry16_df <- stry16_df %>% rowwise %>%
  mutate(end.server.x = ifelse(server == "STRYCOVA" & end.server.x >= 0, -end.server.x, end.server.x)) %>%
  mutate(end.receiver.x = ifelse(receiver == "STRYCOVA" & end.receiver.x >= 0, -end.receiver.x, end.receiver.x)) 
```

```{r }


#For Opponent
stry16_df <- stry16_df %>% rowwise %>%
  mutate(start.server.y = ifelse(server != "STRYCOVA" & start.server.x <= 0, -start.server.y, start.server.y)) %>%
  mutate(start.receiver.y = ifelse(receiver != "STRYCOVA" & start.receiver.x <= 0, -start.receiver.y, start.receiver.y))%>%
  mutate(end.server.y = ifelse(server != "STRYCOVA" & end.server.x <= 0, -end.server.y, end.server.y)) %>%
  mutate(end.receiver.y = ifelse(receiver != "STRYCOVA" & end.receiver.x <= 0, -end.receiver.y, end.receiver.y))%>%
  mutate(start.server.x = ifelse(server != "STRYCOVA" & start.server.x <= 0, -start.server.x, start.server.x)) %>%
  mutate(start.receiver.x = ifelse(receiver != "STRYCOVA" & start.receiver.x <= 0, -start.receiver.x, start.receiver.x)) 

stry16_df <- stry16_df %>% rowwise %>%
  mutate(end.server.x = ifelse(server != "STRYCOVA" & end.server.x <= 0, -end.server.x, end.server.x)) %>%
  mutate(end.receiver.x = ifelse(receiver != "STRYCOVA" & end.receiver.x <= 0, -end.receiver.x, end.receiver.x)) 
```



```{r}
stry16_df <- stry16_df %>%
  mutate(lastshot = ifelse(shot == final.shot,1,0)) %>%
  mutate(isserver = ifelse(server == impact.player,1,0)) %>%
  mutate(fhand = ifelse(hitpoint == "F",1,0)) %>%
  mutate(opponent = ifelse(server == "STRYCOVA", receiver, server)) 
 

  

```





```{r}

stry16_df <- stry16_df %>%
  mutate(winner = ifelse(is.good == TRUE & lastshot == 1,1,0)) %>%
  mutate(ser1 = ifelse(serve == 1 & serve_classification == 1,1,0)) %>%
  mutate(ser2 = ifelse(serve == 2 & serve_classification == 1,1,0)) 
  
for (i in 1:ncol(stry16_df)) {
  if(is.character(stry16_df[,i]) == TRUE) {
    stry16_df[,i] <- as.factor(stry16_df[,i])
  }
}
```

```{r}
#Combining winner, return into play and error into 1 column for three states in hidden markov model
#If ball is in play and the shot is a winner value of 1
#If ball is in play and the shot is not a winner value of 0
#If the ball is out of play and thus not a winner value of -1

stry16_df <- stry16_df %>%
  mutate(winner.return.error = ifelse(is.good =="TRUE" & winner == "1",1,
                ifelse(is.good =="TRUE" & winner == "0",0,-1)))
```

```{r}
col = c("set","game", "point")
rally.numstry16 = as.data.frame(group_indices_(stry16_df,.dots = col))
colnames(rally.numstry16)<- "rally.number"
```

```{r}


stry16_df <- stry16_df %>%
  cbind(rally.numstry16)
 
```



```{r}

#start/end player positions x/y
stry16_df <- stry16_df %>%
  mutate(oppo.start.position.x = ifelse(server != "STRYCOVA", start.server.x,0)+ifelse(server == "STRYCOVA", start.receiver.x,0))%>%
  mutate(oppo.start.position.y = ifelse(server != "STRYCOVA", start.server.y,0)+ifelse(server == "STRYCOVA", start.receiver.y,0)) %>%
  mutate(oppo.end.position.x = ifelse(server != "STRYCOVA", end.server.x,0)+ifelse(server == "STRYCOVA", end.receiver.x,0)) %>%
  mutate(oppo.end.position.y = ifelse(server != "STRYCOVA", end.server.y,0)+ifelse(server == "STRYCOVA", end.receiver.y,0)) %>%
  mutate(p.start.position.x = ifelse(server == "STRYCOVA", start.server.x,0)+ifelse(server != "STRYCOVA", start.receiver.x,0)) %>%
  mutate(p.start.position.y = ifelse(server == "STRYCOVA", start.server.y,0)+ifelse(server != "STRYCOVA", start.receiver.y,0)) %>%
  mutate(p.end.position.x = ifelse(server == "STRYCOVA", end.server.x,0)+ifelse(server != "STRYCOVA", end.receiver.x,0)) %>%
  mutate(p.end.position.y = ifelse(server == "STRYCOVA", end.server.y,0)+ifelse(server != "STRYCOVA", end.receiver.y,0)) 
  
#player and opponent distances travelled from start of shot to end of next shot
stry16_df <- stry16_df %>%  
  mutate(oppo.distance = ifelse(server != "STRYCOVA", server.distance,0)+ifelse(server == "STRYCOVA", receiver.distance,0)) %>%
  mutate(p.distance = ifelse(server == "STRYCOVA", server.distance,0)+ifelse(server != "STRYCOVA", receiver.distance,0))

#player and opponent speed 
stry16_df <- stry16_df %>%
  mutate(p.peak.speed = ifelse(server == "STRYCOVA", server.peak.speed,0)+ifelse(server != "STRYCOVA", receiver.peak.speed,0)) %>%
  mutate(p.avg.speed = ifelse(server == "STRYCOVA", server.avg.speed,0)+ifelse(server != "STRYCOVA", receiver.avg.speed,0)) 
  

#player and opponent acceleration
stry16_df <- stry16_df %>%  
  mutate(p.avg.acceleration = ifelse(server == "STRYCOVA", server.avg.acceleration,0)+ifelse(server != "STRYCOVA", receiver.avg.acceleration,0)) %>%
  mutate(p.peak.acceleration = ifelse(server == "STRYCOVA", server.peak.acceleration,0)+ifelse(server != "STRYCOVA", receiver.peak.acceleration,0)) %>%
  mutate(oppo.peak.speed = ifelse(server != "STRYCOVA", server.peak.speed,0)+ifelse(server == "STRYCOVA", receiver.peak.speed,0)) %>%
  mutate(oppo.avg.speed = ifelse(server != "STRYCOVA", server.avg.speed,0)+ifelse(server == "STRYCOVA", receiver.avg.speed,0)) %>%
  mutate(oppo.avg.acceleration = ifelse(server != "STRYCOVA", server.avg.acceleration,0)+ifelse(server == "STRYCOVA", receiver.avg.acceleration,0)) %>%
  mutate(oppo.peak.acceleration = ifelse(server != "STRYCOVA", server.peak.acceleration,0)+ifelse(server == "STRYCOVA", receiver.peak.acceleration,0))


#player and opponent work
stry16_df <- stry16_df %>%
  mutate(oppo.work = ifelse(server != "STRYCOVA", server.work,0)+ifelse(server == "STRYCOVA", receiver.work,0)) %>%
  mutate(p.work = ifelse(server == "STRYCOVA", server.work,0)+ifelse(server != "STRYCOVA", receiver.work,0)) 

#player and opponent advantage
stry16_df <- stry16_df %>%
  mutate(oppo.advantage =ifelse(server != "STRYCOVA", server.advantage,0)+ifelse(server == "STRYCOVA", receiver.advantage,0))%>%
   mutate(p.advantage =ifelse(server == "STRYCOVA", server.advantage,0)+ifelse(server != "STRYCOVA", receiver.advantage,0))


#player and opponent total changes
stry16_df <- stry16_df %>%
  mutate(oppo.total.changes =ifelse(server != "STRYCOVA", server.total.changes,0)+ifelse(server == "STRYCOVA", receiver.total.changes,0))%>%
   mutate(p.total.changes =ifelse(server == "STRYCOVA", server.total.changes,0)+ifelse(server != "STRYCOVA", receiver.total.changes,0))
  
  
```


```{r}

#player speed and acceleration differences and ratios
stry16_df <- stry16_df %>%
  mutate(avg.player.speed.diff = p.avg.speed-oppo.avg.speed) %>%
  mutate(peak.player.speed.diff = p.peak.speed-oppo.peak.speed) %>%
  mutate(avg.player.speed.ratio = p.avg.speed/oppo.avg.speed) %>%
  mutate(peak.player.speed.ratio = p.peak.speed/oppo.peak.speed) %>%
  mutate(avg.player.acceleration.diff = (p.avg.acceleration)-(oppo.avg.acceleration)) %>%
  mutate(peak.player.acceleration.diff = (p.peak.acceleration)-(oppo.peak.acceleration)) %>%
  mutate(avg.player.acceleration.ratio = (p.avg.acceleration)/(oppo.avg.acceleration)) %>%
  mutate(peak.player.acceleration.ratio = (p.peak.acceleration)/(oppo.peak.acceleration)) 

stry16_df[is.na(stry16_df)] <- 0
  
stry16_df <- stry16_df %>%  
  mutate(p.avg.speed.match = mean(p.avg.speed)) %>%
  mutate(oppo.avg.speed.match = mean(oppo.avg.speed)) %>%
  mutate(p.diff.avg.shot.and.match.movement.speed = p.avg.speed - p.avg.speed.match) %>%
  mutate(oppo.diff.avg.shot.and.match.movement.speed = oppo.avg.speed - oppo.avg.speed.match)
  

#player/opponent side distance for start/end positions
stry16_df <- stry16_df %>%
  mutate(p.start.position.side.dist = 4.115 - abs(p.start.position.y)) %>%
  mutate(p.end.position.side.dist = 4.115 - abs(p.end.position.y)) %>%
  mutate(oppo.start.position.side.dist = 4.115 - abs(oppo.start.position.y)) %>%
  mutate(oppo.end.position.side.dist = 4.115 - abs(oppo.end.position.y))
  
#player/opponent base distances for start/end positions  
stry16_df <- stry16_df %>%
  mutate(p.start.position.base.dist = 11.89 - abs(p.start.position.x)) %>%
  mutate(p.end.position.base.dist = 11.89 - abs(p.end.position.x)) %>%
  mutate(oppo.start.position.base.dist = 11.89 - abs(oppo.start.position.x)) %>%
  mutate(oppo.end.position.base.dist = 11.89 - abs(oppo.end.position.x)) %>%
  mutate(oppo.start.position.base.diff = p.start.position.base.dist - oppo.start.position.base.dist) %>%
  mutate(p.start.position.base.diff = oppo.start.position.base.dist -p.start.position.base.dist) %>%
  mutate(oppo.end.position.base.diff = p.end.position.base.dist - oppo.end.position.base.dist) %>%
  mutate(p.end.position.base.diff = oppo.end.position.base.dist -p.end.position.base.dist) %>%
  mutate(p.start.position.centre.diff = abs(oppo.start.position.y)-abs(p.start.position.y)) %>%
  mutate(p.end.position.centre.diff = abs(oppo.end.position.y)-abs(p.end.position.y)) %>%
  mutate(oppo.start.position.centre.diff = abs(p.start.position.y)-abs(oppo.start.position.y)) %>%
  mutate(oppo.end.position.centre.diff = abs(p.end.position.y)-abs(oppo.end.position.y))
  
  
```



```{r}
#player/ opponent shortest distances for start/end positions 
stry16_df <- stry16_df %>%
  mutate(oppo.start.position.short.dist = min(oppo.start.position.side.dist, oppo.start.position.base.dist)) %>%
   mutate(oppo.end.position.short.dist = min(oppo.end.position.side.dist, oppo.end.position.base.dist)) %>%
  mutate(p.start.position.short.dist = min(p.start.position.side.dist, p.start.position.base.dist)) %>%
   mutate(p.end.position.short.dist = min(p.end.position.side.dist, p.end.position.base.dist)) 
```



```{r}

#Tally of the number of times player and opponent change side during rally
#Defining change of side as having travelled from a location 2.0575 or more metres away from the centre on one side of the court (half the distance between centre and singles lines) to a location 2.0575 or more metres away from the centre on the other side of the court
stry16_df <- stry16_df %>%
  mutate(p.side.change.count = ifelse(p.start.position.y <= -2.0575 & p.end.position.y >= 2.0575, 1, ifelse(p.start.position.y >= 2.0575 & p.end.position.y <= -2.0575, 1, 0))) %>%
  mutate(p.side.change.cumsum = cumsum(p.side.change.count)) %>%
  mutate(oppo.side.change.count = ifelse(oppo.start.position.y <= -2.0575 & oppo.end.position.y >= 2.0575, 1, ifelse(oppo.start.position.y >= 2.0575 & oppo.end.position.y <= -2.0575, 1, 0))) %>%
  mutate(oppo.side.change.cumsum = cumsum(oppo.side.change.count)) 
  


  
  
```

```{r}
#Within rally tally of side change count and distance run
stry16_df <- stry16_df %>%
  group_by(rally.number ) %>%
  dplyr::mutate(p.rally.side.change.count = cumsum(p.side.change.count)) %>%
  dplyr::mutate(oppo.rally.side.change.count = cumsum(oppo.side.change.count)) %>%
  dplyr::mutate(rally.side.change.count.diff = p.rally.side.change.count-oppo.rally.side.change.count) %>%
  dplyr::mutate(oppo.rally.distance.run = cumsum(oppo.distance)) %>%
  dplyr::mutate(p.rally.distance.run = cumsum(p.distance)) %>%
  dplyr::mutate(rally.distance.run.ratio = p.rally.distance.run/oppo.rally.distance.run) %>%
  ungroup
 
```
```{r}
#Seperating height over net of shots for player and opponent.

stry16_df <- stry16_df %>%
  mutate(p.height.off.net = ifelse(impact.player == "STRYCOVA",height.off.net,0)) %>%
  mutate(oppo.height.off.net = ifelse(impact.player != "STRYCOVA", height.off.net,0)) 
  
```


```{r}
#Adding angles for player & opposition movement from start position[i] to end position[i] as well as end position[i] to start position[i+1]. Measuring the angle of movement from the baseline. Directly towards the net is 0 deg. Directly away from the net is 180 deg.


stry16_df <- stry16_df %>%
  mutate(p.movement.angle.1 = NA) %>%
  mutate(p.movement.angle.2 = NA) %>%
  mutate(oppo.movement.angle.1 = NA) %>%
  mutate(oppo.movement.angle.2 = NA) 
  
  
#player start to end movement angle  
for (i in 1:nrow(stry16_df)) {
  a1 <- stry16_df$p.start.position.x[i]
  b1 <- stry16_df$p.start.position.y[i]
  a2 <- stry16_df$p.end.position.x[i]
  b2 <- stry16_df$p.end.position.y[i]
  
  
  p.movement.angle.1 <- atan(
  ((abs(b1)-abs(b2))/(abs(a1)-abs(a2)))* 180/pi) 
  
  stry16_df$p.movement.angle.1[i] = ifelse(p.movement.angle.1 < 0 & (abs(a1)-abs(a2))<0, 180+p.movement.angle.1,
                                          ifelse(p.movement.angle.1 < 0 & (abs(b1)-abs(b2))<0,abs(p.movement.angle.1),
                                                 ifelse(p.movement.angle.1 > 0 & (abs(a1)-abs(a2))<0, 90+p.movement.angle.1,p.movement.angle.1)))
                                                                                                            
}



```
```{r}
#player end position(i) to start position (i+1) movement angle
for (i in 2:nrow(stry16_df)) {
  a1 <- stry16_df$p.end.position.x[i]
  b1 <- stry16_df$p.end.position.y[i]
  a2 <- stry16_df$p.start.position.x[i+1]
  b2 <- stry16_df$p.start.position.y[i+1]
  
  p.movement.angle.2 <- atan(
  ((abs(b1)-abs(b2))/(abs(a1)-abs(a2)))* 180/pi) 
  
  stry16_df$p.movement.angle.2[i] = ifelse(p.movement.angle.2 < 0 & (abs(a1)-abs(a2))<0, 180+p.movement.angle.2,
                                          ifelse(p.movement.angle.2 < 0 & (abs(b1)-abs(b2))<0,abs(p.movement.angle.2),
                                                 ifelse(p.movement.angle.2 > 0 & (abs(a1)-abs(a2))<0, 90+p.movement.angle.2,p.movement.angle.2)))
  
}  
  


```

```{r}
# opposition start to end movement angle

  
for (i in 1:nrow(stry16_df)) {
  a1 <- stry16_df$oppo.start.position.x[i]
  b1 <- stry16_df$oppo.start.position.y[i]
  a2 <- stry16_df$oppo.end.position.x[i]
  b2 <- stry16_df$oppo.end.position.y[i]
  
  oppo.movement.angle.1 <- atan(
  ((abs(b1)-abs(b2))/(abs(a1)-abs(a2)))* 180/pi) 
  
  stry16_df$oppo.movement.angle.1[i] = ifelse(oppo.movement.angle.1 < 0 & (abs(a1)-abs(a2))<0,180+oppo.movement.angle.1,
                                          ifelse(oppo.movement.angle.1 < 0 & (abs(b1)-abs(b2))<0,abs(oppo.movement.angle.1),
                                                 ifelse(oppo.movement.angle.1 > 0 & (abs(a1)-abs(a2))<0,90+oppo.movement.angle.1,p.movement.angle.1)))
  
  
}
```
```{r}
#oppositions end[i] to start [i+1] movement angle
for (i in 2:nrow(stry16_df)) {
  a1 <- stry16_df$oppo.end.position.x[i]
  b1 <- stry16_df$oppo.end.position.y[i]
  a2 <- stry16_df$oppo.start.position.x[i+1]
  b2 <- stry16_df$oppo.start.position.y[i+1]
  
  oppo.movement.angle.2 <- atan(
  ((abs(b1)-abs(b2))/(abs(a1)-abs(a2)))* 180/pi) 
  
  stry16_df$oppo.movement.angle.2[i] = ifelse(oppo.movement.angle.2 < 0 & (abs(a1)-abs(a2))<0, 180+oppo.movement.angle.2,
                                          ifelse(oppo.movement.angle.2 < 0 & (abs(b1)-abs(b2))<0,abs(oppo.movement.angle.2),
                                                 ifelse(oppo.movement.angle.2 > 0 & (abs(a1)-abs(a2))<0, 90+oppo.movement.angle.2,oppo.movement.angle.2)))
}
```

```{r}
#speed of player ad opponent shots in m/s at the start of the shot arc
stry16_df<- stry16_df %>%
  mutate(p.start.shot.speed = ifelse(impact.player == "STRYCOVA", speed.start, 0)) %>%
  mutate(oppo.start.shot.speed = ifelse(impact.player != "STRYCOVA", speed.start, 0)) 
```

```{r}
#code for this chunk relatively unchanged
# replaced ballmark.x with projected.ballmark.x; speed1 replaced by speed.start

stry16_df <- stry16_df %>%
  mutate(speed.diff = NA) %>%
  mutate(oppo.hit.x = NA) %>%
  mutate(oppo.hit.y = NA) %>%
  mutate(oppo.hit.z = NA) %>%
  mutate(oppo.speed = NA) %>%
  mutate(oppo.projected.ballmark.x = NA) %>%
  mutate(oppo.projected.ballmark.y = NA) %>%
  mutate(speed.ratio = NA) 


for (i in 2:nrow(stry16_df)) {
  if(stry16_df$shot[i] != 1) {#so that only non-serves are affected

  stry16_df$speed.diff[i]=stry16_df$speed.start[i]-stry16_df$speed.start[i-1]
  #speed difference
  
  stry16_df$oppo.hit.x[i]=stry16_df$start.x[i-1]
  stry16_df$oppo.hit.y[i]=stry16_df$start.y[i-1]
  stry16_df$oppo.hit.z[i]=stry16_df$start.z[i-1]
  stry16_df$oppo.speed[i]=stry16_df$speed.start[i-1]
  stry16_df$oppo.projected.ballmark.x[i]=stry16_df$projected.ballmark.x[i-1]
  stry16_df$oppo.projected.ballmark.y[i]=stry16_df$projected.ballmark.y[i-1]
  #oppo hit
  
  }
}

stry16_df <- stry16_df %>%
  mutate(speed.ratio = speed.start/oppo.speed) %>% #speed ratio
  mutate(side.dist = 4.115 - abs(oppo.projected.ballmark.y)) %>% #distance of oppo.projected.ballmark from sideline
  mutate(base.dist = 11.89 - abs(oppo.projected.ballmark.x)) %>% #distance of oppo.projected.ballmark from baseline
  mutate(short.dist = min(side.dist, base.dist)) #shortest distance from any line


#Adding angles
stry16_df <- stry16_df %>%
  mutate(p.start.shot.x = NA) %>%
  mutate(p.start.shot.y = NA)

for (i in 3:nrow(stry16_df)) {
  if(stry16_df$impact.player[i] == stry16_df$impact.player[i-2] & stry16_df$shot[i] == stry16_df$shot[i-2] + 2) {
    stry16_df$p.start.shot.x[i]=stry16_df$start.x[i-2]
    stry16_df$p.start.shot.y[i]=stry16_df$start.y[i-2]
  }
}

#adding angle between stry.shot-opp.shot vector and opp.shot-opp.projected.ballmark vector
#doing it in one line because df doesn't want to add vectors
stry16_df <- stry16_df %>%
  mutate(o.angle = NA)
  
for (i in 1:nrow(stry16_df)) {
  x1 <- stry16_df$p.start.shot.x[i]
  y1 <- stry16_df$p.start.shot.y[i]
  x2 <- stry16_df$oppo.hit.x[i]
  y2 <- stry16_df$oppo.hit.y[i]
  x3 <- stry16_df$oppo.projected.ballmark.x[i]
  y3 <- stry16_df$oppo.projected.ballmark.y[i]
  
  o.angle <- acos(
  ((c(x1,y1)-c(x2,y2))/sqrt((x1-x2)^2+(y1-y2)^2)) %*%
    ((c(x2,y2)-c(x3,y3))/sqrt((x2-x3)^2+(y2-y3)^2))) * 180/pi
  
  stry16_df$o.angle[i] = ifelse(o.angle > 90, 180-o.angle, o.angle)
}

#Now adding the angle the player hits
stry16_df <- stry16_df %>%
  mutate(p.angle = NA)
  
for (i in 1:nrow(stry16_df)) {
  x1 <- stry16_df$oppo.hit.x[i]
  y1 <- stry16_df$oppo.hit.y[i]
  x2 <- stry16_df$start.x[i]
  y2 <- stry16_df$start.y[i]
  x3 <- stry16_df$projected.ballmark.x[i]
  y3 <- stry16_df$projected.ballmark.y[i]
  
  p.angle <- acos(
  ((c(x1,y1)-c(x2,y2))/sqrt((x1-x2)^2+(y1-y2)^2)) %*%
    ((c(x2,y2)-c(x3,y3))/sqrt((x2-x3)^2+(y2-y3)^2))) * 180/pi
  
  stry16_df$p.angle[i] = ifelse(p.angle > 90, 180-p.angle, p.angle)
}

stry16_df <- stry16_df %>%
  group_by(rally.number) %>%
  mutate(lag.p.angle = dplyr::lag(p.angle, n = 1, default = NA)) %>%
  mutate(lag.speed.ratio = dplyr::lag(speed.ratio, n = 1, default = NA)) %>%
  mutate(lag.p.movement.angle.1 = dplyr::lag(p.movement.angle.1, n = 1, default = NA)) %>%
  mutate(lag.p.movement.angle.2 = dplyr::lag(p.movement.angle.2, n = 1, default = NA)) %>%
  mutate(lag.oppo.height.off.net = dplyr::lag(oppo.height.off.net, n = 1, default = NA)) %>%
  mutate(lag.p.start.shot.speed = dplyr::lag(p.start.shot.speed, n = 1, default = NA)) %>%
  mutate(lag.oppo.start.shot.speed = dplyr::lag(oppo.start.shot.speed, n = 1, default = NA)) %>%
  ungroup


```





```{r}
stry16_df <- stry16_df %>%
  mutate(oppo.start.server.x = ifelse(server != "STRYCOVA", start.server.x, 0)) 
```



```{r  }

#creating new rows so that every second row start and end player positions are switched
#Also creating new rows so that every second row in start.x,/start.y is projected ballmark
#this allows us to better plot player positions as well as track positions for animations

joinstry16_df <- transform(stry16_df, p.start.position.x=p.end.position.x, p.start.position.y=p.end.position.y, oppo.start.position.x=oppo.end.position.x, oppo.start.position.y=oppo.end.position.y, start.x=projected.ballmark.x, start.y=projected.ballmark.y)

stry16_pos <- bind_rows(stry16_df, setNames(joinstry16_df, names(stry16_df))) %>% 
           arrange(rally.number, shot)

stry16_pos <- stry16_pos %>%
  group_by(rally.number, idx = cumsum(event == 1L)) %>%
  mutate(location.id= row_number()) %>%
  ungroup

stry16_pos <- stry16_pos %>%
  group_by(rally.number) %>%
  mutate(pos.rally.count= 1:n()) %>%
  ungroup
``` 





```{r }
#remove opponents
stry16_no.opp <- stry16_df %>% 
  dplyr::filter(impact.player == "STRYCOVA")

#STRYCOVA only - remove serves
stry16_only <- stry16_no.opp %>%
  filter(hitpoint != "S") %>%
  dplyr::select(-serveid)


#First remove any errors for start, projected.ballmark, so that we are only looking at shots that we hit onto the other side
#To check: ggplot(stry16_only, aes(projected.ballmark.x, projected.ballmark.y)) + geom_point()
stry16_only <- stry16_only %>%
  filter(oppo.hit.x >= 0) %>%
  filter(oppo.projected.ballmark.x <= 0) %>%
  filter(projected.ballmark.x >= 0)

#Adding shot number cumulative count (functions as time)
#check this for new data set .
stry16_only <- stry16_only %>%
  mutate(count = 1)

  for (i in 2:nrow(stry16_only)) {
    if(stry16_only$matchid[i]==stry16_only$matchid[i-1]) {
      stry16_only$count[i] = stry16_only$count[i-1] + 1
    }
  }

  

#Adjusting to remove NAs and replace with 0s for modelling
stry16_only$o.angle[is.na(stry16_only$o.angle)] <- 0
stry16_only$lag.p.angle[is.na(stry16_only$lag.p.angle)] <- 0
stry16_only$lag.speed.ratio[is.na(stry16_only$lag.speed.ratio)] <- 0
stry16_only$p.start.shot.x[is.na(stry16_only$p.start.shot.x)] <- 0
stry16_only$p.start.shot.y[is.na(stry16_only$p.start.shot.y)] <- 0
stry16_only$lag.p.movement.angle.1[is.na(stry16_only$lag.p.movement.angle.1)] <- 0
stry16_only$lag.p.movement.angle.2[is.na(stry16_only$lag.p.movement.angle.2)] <- 0
stry16_only$lag.oppo.height.off.net[is.na(stry16_only$lag.oppo.height.off.net)] <- 0



stry16_only <- stry16_only %>% mutate(player.total.shot.number = row_number())
```


```{r}
#variables for speed of ball at the start of shot arcs

stry16_only <- stry16_only %>%
  mutate(avg.p.start.shot.speed = mean(p.start.shot.speed)) %>%
  mutate(avg.lag.oppo.start.shot.speed = mean(lag.oppo.start.shot.speed)) %>%
  mutate(diff.p.avg.and.current.shot.speed = p.start.shot.speed- avg.p.start.shot.speed) %>%
  mutate(diff.lag.oppo.avg.and.current.shot.speed = lag.oppo.start.shot.speed- avg.lag.oppo.start.shot.speed) 


  
```



```{r}
#making y positions absolute for stry16_only as this is more relevant for the depmix model

stry16_only <- stry16_only %>%
  mutate(p.start.position.y = abs(p.start.position.y)) %>%
  mutate(p.end.position.y = abs(p.end.position.y)) %>%
  mutate(oppo.start.position.y = abs(oppo.start.position.y)) %>%
  mutate(oppo.end.position.y = abs(oppo.end.position.y))%>%
  mutate(p.start.shot.y =abs(p.start.shot.y))
  
  

```
```{r}
#Save output
stry16_only[is.na(stry16_only)] <- 0
write.csv(stry16_only, "data/stry16_only.csv")
```


##Strycova Vs Garcia 2017 Data



```{r  }

#Reorienting shots so that all STRYCOVA's shot are from negative x side of court, and all opponents shots are from positive x side. y coordinates have been flipped as required.
stry17_df <- stry17_df %>% rowwise %>%
  mutate(projected.ballmark.y = ifelse(impact.player == "STRYCOVA" & start.x >= 0, -projected.ballmark.y, projected.ballmark.y)) %>%
  mutate(start.y = ifelse(impact.player == "STRYCOVA" & start.x >= 0, -start.y, start.y))%>%
  mutate(projected.ballmark.x = ifelse(impact.player == "STRYCOVA" & start.x >= 0, -projected.ballmark.x, projected.ballmark.x)) %>%
  mutate(start.x = ifelse(impact.player == "STRYCOVA" & start.x >= 0, -start.x, start.x)) 

#Reorienting opponent shots
stry17_df <- stry17_df %>% rowwise %>%
  mutate(start.y = ifelse(impact.player != "STRYCOVA" & start.x <= 0, -start.y, start.y)) %>%
  mutate(projected.ballmark.y = ifelse(impact.player != "STRYCOVA" & start.x <= 0, -projected.ballmark.y, projected.ballmark.y)) %>%
  mutate(projected.ballmark.x = ifelse(impact.player != "STRYCOVA" & start.x <= 0, -projected.ballmark.x, projected.ballmark.x)) %>%
  mutate(start.x = ifelse(impact.player != "STRYCOVA" & start.x <= 0, -start.x, start.x))
```


```{r }

#Reorienting player positions so that all STRYCOVA's & Opponents start/end positions match reoriented ballmarks
#For STRYCOVA
stry17_df <- stry17_df %>% rowwise %>%
  mutate(start.server.y = ifelse(server == "STRYCOVA" & start.server.x >= 0, -start.server.y, start.server.y)) %>%
  mutate(start.receiver.y = ifelse(receiver == "STRYCOVA" & start.receiver.x >= 0, -start.receiver.y, start.receiver.y))%>%
  mutate(end.server.y = ifelse(server == "STRYCOVA" & end.server.x >= 0, -end.server.y, end.server.y)) %>%
  mutate(end.receiver.y = ifelse(receiver == "STRYCOVA" & end.receiver.x >= 0, -end.receiver.y, end.receiver.y))%>%
  mutate(start.server.x = ifelse(server == "STRYCOVA" & start.server.x >= 0, -start.server.x, start.server.x)) %>%
  mutate(start.receiver.x = ifelse(receiver == "STRYCOVA" & start.receiver.x >= 0, -start.receiver.x, start.receiver.x)) 

stry17_df <- stry17_df %>% rowwise %>%
  mutate(end.server.x = ifelse(server == "STRYCOVA" & end.server.x >= 0, -end.server.x, end.server.x)) %>%
  mutate(end.receiver.x = ifelse(receiver == "STRYCOVA" & end.receiver.x >= 0, -end.receiver.x, end.receiver.x)) 
```

```{r }


#For Opponent
stry17_df <- stry17_df %>% rowwise %>%
  mutate(start.server.y = ifelse(server != "STRYCOVA" & start.server.x <= 0, -start.server.y, start.server.y)) %>%
  mutate(start.receiver.y = ifelse(receiver != "STRYCOVA" & start.receiver.x <= 0, -start.receiver.y, start.receiver.y))%>%
  mutate(end.server.y = ifelse(server != "STRYCOVA" & end.server.x <= 0, -end.server.y, end.server.y)) %>%
  mutate(end.receiver.y = ifelse(receiver != "STRYCOVA" & end.receiver.x <= 0, -end.receiver.y, end.receiver.y))%>%
  mutate(start.server.x = ifelse(server != "STRYCOVA" & start.server.x <= 0, -start.server.x, start.server.x)) %>%
  mutate(start.receiver.x = ifelse(receiver != "STRYCOVA" & start.receiver.x <= 0, -start.receiver.x, start.receiver.x)) 

stry17_df <- stry17_df %>% rowwise %>%
  mutate(end.server.x = ifelse(server != "STRYCOVA" & end.server.x <= 0, -end.server.x, end.server.x)) %>%
  mutate(end.receiver.x = ifelse(receiver != "STRYCOVA" & end.receiver.x <= 0, -end.receiver.x, end.receiver.x)) 
```



```{r}
stry17_df <- stry17_df %>%
  mutate(lastshot = ifelse(shot == final.shot,1,0)) %>%
  mutate(isserver = ifelse(server == impact.player,1,0)) %>%
  mutate(fhand = ifelse(hitpoint == "F",1,0)) %>%
  mutate(opponent = ifelse(server == "STRYCOVA", receiver, server)) 
 

  

```





```{r}

stry17_df <- stry17_df %>%
  mutate(winner = ifelse(is.good == TRUE & lastshot == 1,1,0)) %>%
  mutate(ser1 = ifelse(serve == 1 & serve_classification == 1,1,0)) %>%
  mutate(ser2 = ifelse(serve == 2 & serve_classification == 1,1,0)) 
  
for (i in 1:ncol(stry17_df)) {
  if(is.character(stry17_df[,i]) == TRUE) {
    stry17_df[,i] <- as.factor(stry17_df[,i])
  }
}
```

```{r}
#Combining winner, return into play and error into 1 column for three states in hidden markov model
#If ball is in play and the shot is a winner value of 1
#If ball is in play and the shot is not a winner value of 0
#If the ball is out of play and thus not a winner value of -1

stry17_df <- stry17_df %>%
  mutate(winner.return.error = ifelse(is.good =="TRUE" & winner == "1",1,
                ifelse(is.good =="TRUE" & winner == "0",0,-1)))
```

```{r}
col = c("set","game", "point")
rally.numstry17 = as.data.frame(group_indices_(stry17_df,.dots = col))
colnames(rally.numstry17)<- "rally.number"
```

```{r}


stry17_df <- stry17_df %>%
  cbind(rally.numstry17)
 
```



```{r}

#start/end player positions x/y
stry17_df <- stry17_df %>%
  mutate(oppo.start.position.x = ifelse(server != "STRYCOVA", start.server.x,0)+ifelse(server == "STRYCOVA", start.receiver.x,0))%>%
  mutate(oppo.start.position.y = ifelse(server != "STRYCOVA", start.server.y,0)+ifelse(server == "STRYCOVA", start.receiver.y,0)) %>%
  mutate(oppo.end.position.x = ifelse(server != "STRYCOVA", end.server.x,0)+ifelse(server == "STRYCOVA", end.receiver.x,0)) %>%
  mutate(oppo.end.position.y = ifelse(server != "STRYCOVA", end.server.y,0)+ifelse(server == "STRYCOVA", end.receiver.y,0)) %>%
  mutate(p.start.position.x = ifelse(server == "STRYCOVA", start.server.x,0)+ifelse(server != "STRYCOVA", start.receiver.x,0)) %>%
  mutate(p.start.position.y = ifelse(server == "STRYCOVA", start.server.y,0)+ifelse(server != "STRYCOVA", start.receiver.y,0)) %>%
  mutate(p.end.position.x = ifelse(server == "STRYCOVA", end.server.x,0)+ifelse(server != "STRYCOVA", end.receiver.x,0)) %>%
  mutate(p.end.position.y = ifelse(server == "STRYCOVA", end.server.y,0)+ifelse(server != "STRYCOVA", end.receiver.y,0)) 
  
#player and opponent distances travelled from start of shot to end of next shot
stry17_df <- stry17_df %>%  
  mutate(oppo.distance = ifelse(server != "STRYCOVA", server.distance,0)+ifelse(server == "STRYCOVA", receiver.distance,0)) %>%
  mutate(p.distance = ifelse(server == "STRYCOVA", server.distance,0)+ifelse(server != "STRYCOVA", receiver.distance,0))

#player and opponent speed 
stry17_df <- stry17_df %>%
  mutate(p.peak.speed = ifelse(server == "STRYCOVA", server.peak.speed,0)+ifelse(server != "STRYCOVA", receiver.peak.speed,0)) %>%
  mutate(p.avg.speed = ifelse(server == "STRYCOVA", server.avg.speed,0)+ifelse(server != "STRYCOVA", receiver.avg.speed,0)) 
  

#player and opponent acceleration
stry17_df <- stry17_df %>%  
  mutate(p.avg.acceleration = ifelse(server == "STRYCOVA", server.avg.acceleration,0)+ifelse(server != "STRYCOVA", receiver.avg.acceleration,0)) %>%
  mutate(p.peak.acceleration = ifelse(server == "STRYCOVA", server.peak.acceleration,0)+ifelse(server != "STRYCOVA", receiver.peak.acceleration,0)) %>%
  mutate(oppo.peak.speed = ifelse(server != "STRYCOVA", server.peak.speed,0)+ifelse(server == "STRYCOVA", receiver.peak.speed,0)) %>%
  mutate(oppo.avg.speed = ifelse(server != "STRYCOVA", server.avg.speed,0)+ifelse(server == "STRYCOVA", receiver.avg.speed,0)) %>%
  mutate(oppo.avg.acceleration = ifelse(server != "STRYCOVA", server.avg.acceleration,0)+ifelse(server == "STRYCOVA", receiver.avg.acceleration,0)) %>%
  mutate(oppo.peak.acceleration = ifelse(server != "STRYCOVA", server.peak.acceleration,0)+ifelse(server == "STRYCOVA", receiver.peak.acceleration,0))


#player and opponent work
stry17_df <- stry17_df %>%
  mutate(oppo.work = ifelse(server != "STRYCOVA", server.work,0)+ifelse(server == "STRYCOVA", receiver.work,0)) %>%
  mutate(p.work = ifelse(server == "STRYCOVA", server.work,0)+ifelse(server != "STRYCOVA", receiver.work,0)) 

#player and opponent advantage
stry17_df <- stry17_df %>%
  mutate(oppo.advantage =ifelse(server != "STRYCOVA", server.advantage,0)+ifelse(server == "STRYCOVA", receiver.advantage,0))%>%
   mutate(p.advantage =ifelse(server == "STRYCOVA", server.advantage,0)+ifelse(server != "STRYCOVA", receiver.advantage,0))


#player and opponent total changes
stry17_df <- stry17_df %>%
  mutate(oppo.total.changes =ifelse(server != "STRYCOVA", server.total.changes,0)+ifelse(server == "STRYCOVA", receiver.total.changes,0))%>%
   mutate(p.total.changes =ifelse(server == "STRYCOVA", server.total.changes,0)+ifelse(server != "STRYCOVA", receiver.total.changes,0))
  
  
```


```{r}

#player speed and acceleration differences and ratios
stry17_df <- stry17_df %>%
  mutate(avg.player.speed.diff = p.avg.speed-oppo.avg.speed) %>%
  mutate(peak.player.speed.diff = p.peak.speed-oppo.peak.speed) %>%
  mutate(avg.player.speed.ratio = p.avg.speed/oppo.avg.speed) %>%
  mutate(peak.player.speed.ratio = p.peak.speed/oppo.peak.speed) %>%
  mutate(avg.player.acceleration.diff = (p.avg.acceleration)-(oppo.avg.acceleration)) %>%
  mutate(peak.player.acceleration.diff = (p.peak.acceleration)-(oppo.peak.acceleration)) %>%
  mutate(avg.player.acceleration.ratio = (p.avg.acceleration)/(oppo.avg.acceleration)) %>%
  mutate(peak.player.acceleration.ratio = (p.peak.acceleration)/(oppo.peak.acceleration)) 

stry17_df[is.na(stry17_df)] <- 0
  
stry17_df <- stry17_df %>%  
  mutate(p.avg.speed.match = mean(p.avg.speed)) %>%
  mutate(oppo.avg.speed.match = mean(oppo.avg.speed)) %>%
  mutate(p.diff.avg.shot.and.match.movement.speed = p.avg.speed - p.avg.speed.match) %>%
  mutate(oppo.diff.avg.shot.and.match.movement.speed = oppo.avg.speed - oppo.avg.speed.match)
  

#player/opponent side distance for start/end positions
stry17_df <- stry17_df %>%
  mutate(p.start.position.side.dist = 4.115 - abs(p.start.position.y)) %>%
  mutate(p.end.position.side.dist = 4.115 - abs(p.end.position.y)) %>%
  mutate(oppo.start.position.side.dist = 4.115 - abs(oppo.start.position.y)) %>%
  mutate(oppo.end.position.side.dist = 4.115 - abs(oppo.end.position.y))
  
#player/opponent base distances for start/end positions  
stry17_df <- stry17_df %>%
  mutate(p.start.position.base.dist = 11.89 - abs(p.start.position.x)) %>%
  mutate(p.end.position.base.dist = 11.89 - abs(p.end.position.x)) %>%
  mutate(oppo.start.position.base.dist = 11.89 - abs(oppo.start.position.x)) %>%
  mutate(oppo.end.position.base.dist = 11.89 - abs(oppo.end.position.x)) %>%
  mutate(oppo.start.position.base.diff = p.start.position.base.dist - oppo.start.position.base.dist) %>%
  mutate(p.start.position.base.diff = oppo.start.position.base.dist -p.start.position.base.dist) %>%
  mutate(oppo.end.position.base.diff = p.end.position.base.dist - oppo.end.position.base.dist) %>%
  mutate(p.end.position.base.diff = oppo.end.position.base.dist -p.end.position.base.dist) %>%
  mutate(p.start.position.centre.diff = abs(oppo.start.position.y)-abs(p.start.position.y)) %>%
  mutate(p.end.position.centre.diff = abs(oppo.end.position.y)-abs(p.end.position.y)) %>%
  mutate(oppo.start.position.centre.diff = abs(p.start.position.y)-abs(oppo.start.position.y)) %>%
  mutate(oppo.end.position.centre.diff = abs(p.end.position.y)-abs(oppo.end.position.y))
  
  
```



```{r}
#player/ opponent shortest distances for start/end positions 
stry17_df <- stry17_df %>%
  mutate(oppo.start.position.short.dist = min(oppo.start.position.side.dist, oppo.start.position.base.dist)) %>%
   mutate(oppo.end.position.short.dist = min(oppo.end.position.side.dist, oppo.end.position.base.dist)) %>%
  mutate(p.start.position.short.dist = min(p.start.position.side.dist, p.start.position.base.dist)) %>%
   mutate(p.end.position.short.dist = min(p.end.position.side.dist, p.end.position.base.dist)) 
```



```{r}

#Tally of the number of times player and opponent change side during rally
#Defining change of side as having travelled from a location 2.0575 or more metres away from the centre on one side of the court (half the distance between centre and singles lines) to a location 2.0575 or more metres away from the centre on the other side of the court
stry17_df <- stry17_df %>%
  mutate(p.side.change.count = ifelse(p.start.position.y <= -2.0575 & p.end.position.y >= 2.0575, 1, ifelse(p.start.position.y >= 2.0575 & p.end.position.y <= -2.0575, 1, 0))) %>%
  mutate(p.side.change.cumsum = cumsum(p.side.change.count)) %>%
  mutate(oppo.side.change.count = ifelse(oppo.start.position.y <= -2.0575 & oppo.end.position.y >= 2.0575, 1, ifelse(oppo.start.position.y >= 2.0575 & oppo.end.position.y <= -2.0575, 1, 0))) %>%
  mutate(oppo.side.change.cumsum = cumsum(oppo.side.change.count)) 
  


  
  
```

```{r}
#Within rally tally of side change count and distance run
stry17_df <- stry17_df %>%
  group_by(rally.number ) %>%
  dplyr::mutate(p.rally.side.change.count = cumsum(p.side.change.count)) %>%
  dplyr::mutate(oppo.rally.side.change.count = cumsum(oppo.side.change.count)) %>%
  dplyr::mutate(rally.side.change.count.diff = p.rally.side.change.count-oppo.rally.side.change.count) %>%
  dplyr::mutate(oppo.rally.distance.run = cumsum(oppo.distance)) %>%
  dplyr::mutate(p.rally.distance.run = cumsum(p.distance)) %>%
  dplyr::mutate(rally.distance.run.ratio = p.rally.distance.run/oppo.rally.distance.run) %>%
  ungroup
 
```
```{r}
#Seperating height over net of shots for player and opponent.

stry17_df <- stry17_df %>%
  mutate(p.height.off.net = ifelse(impact.player == "STRYCOVA",height.off.net,0)) %>%
  mutate(oppo.height.off.net = ifelse(impact.player != "STRYCOVA", height.off.net,0)) 
  
```


```{r}
#Adding angles for player & opposition movement from start position[i] to end position[i] as well as end position[i] to start position[i+1]. Measuring the angle of movement from the baseline. Directly towards the net is 0 deg. Directly away from the net is 180 deg.


stry17_df <- stry17_df %>%
  mutate(p.movement.angle.1 = NA) %>%
  mutate(p.movement.angle.2 = NA) %>%
  mutate(oppo.movement.angle.1 = NA) %>%
  mutate(oppo.movement.angle.2 = NA) 
  
  
#player start to end movement angle  
for (i in 1:nrow(stry17_df)) {
  a1 <- stry17_df$p.start.position.x[i]
  b1 <- stry17_df$p.start.position.y[i]
  a2 <- stry17_df$p.end.position.x[i]
  b2 <- stry17_df$p.end.position.y[i]
  
  
  p.movement.angle.1 <- atan(
  ((abs(b1)-abs(b2))/(abs(a1)-abs(a2)))* 180/pi) 
  
  stry17_df$p.movement.angle.1[i] = ifelse(p.movement.angle.1 < 0 & (abs(a1)-abs(a2))<0, 180+p.movement.angle.1,
                                          ifelse(p.movement.angle.1 < 0 & (abs(b1)-abs(b2))<0,abs(p.movement.angle.1),
                                                 ifelse(p.movement.angle.1 > 0 & (abs(a1)-abs(a2))<0, 90+p.movement.angle.1,p.movement.angle.1)))
                                                                                                            
}



```
```{r}
#player end position(i) to start position (i+1) movement angle
for (i in 2:nrow(stry17_df)) {
  a1 <- stry17_df$p.end.position.x[i]
  b1 <- stry17_df$p.end.position.y[i]
  a2 <- stry17_df$p.start.position.x[i+1]
  b2 <- stry17_df$p.start.position.y[i+1]
  
  p.movement.angle.2 <- atan(
  ((abs(b1)-abs(b2))/(abs(a1)-abs(a2)))* 180/pi) 
  
  stry17_df$p.movement.angle.2[i] = ifelse(p.movement.angle.2 < 0 & (abs(a1)-abs(a2))<0, 180+p.movement.angle.2,
                                          ifelse(p.movement.angle.2 < 0 & (abs(b1)-abs(b2))<0,abs(p.movement.angle.2),
                                                 ifelse(p.movement.angle.2 > 0 & (abs(a1)-abs(a2))<0, 90+p.movement.angle.2,p.movement.angle.2)))
  
}  
  


```

```{r}
# opposition start to end movement angle

  
for (i in 1:nrow(stry17_df)) {
  a1 <- stry17_df$oppo.start.position.x[i]
  b1 <- stry17_df$oppo.start.position.y[i]
  a2 <- stry17_df$oppo.end.position.x[i]
  b2 <- stry17_df$oppo.end.position.y[i]
  
  oppo.movement.angle.1 <- atan(
  ((abs(b1)-abs(b2))/(abs(a1)-abs(a2)))* 180/pi) 
  
  stry17_df$oppo.movement.angle.1[i] = ifelse(oppo.movement.angle.1 < 0 & (abs(a1)-abs(a2))<0,180+oppo.movement.angle.1,
                                          ifelse(oppo.movement.angle.1 < 0 & (abs(b1)-abs(b2))<0,abs(oppo.movement.angle.1),
                                                 ifelse(oppo.movement.angle.1 > 0 & (abs(a1)-abs(a2))<0,90+oppo.movement.angle.1,p.movement.angle.1)))
  
  
}
```
```{r}
#oppositions end[i] to start [i+1] movement angle
for (i in 2:nrow(stry17_df)) {
  a1 <- stry17_df$oppo.end.position.x[i]
  b1 <- stry17_df$oppo.end.position.y[i]
  a2 <- stry17_df$oppo.start.position.x[i+1]
  b2 <- stry17_df$oppo.start.position.y[i+1]
  
  oppo.movement.angle.2 <- atan(
  ((abs(b1)-abs(b2))/(abs(a1)-abs(a2)))* 180/pi) 
  
  stry17_df$oppo.movement.angle.2[i] = ifelse(oppo.movement.angle.2 < 0 & (abs(a1)-abs(a2))<0, 180+oppo.movement.angle.2,
                                          ifelse(oppo.movement.angle.2 < 0 & (abs(b1)-abs(b2))<0,abs(oppo.movement.angle.2),
                                                 ifelse(oppo.movement.angle.2 > 0 & (abs(a1)-abs(a2))<0, 90+oppo.movement.angle.2,oppo.movement.angle.2)))
}
```

```{r}
#speed of player ad opponent shots in m/s at the start of the shot arc
stry17_df<- stry17_df %>%
  mutate(p.start.shot.speed = ifelse(impact.player == "STRYCOVA", speed.start, 0)) %>%
  mutate(oppo.start.shot.speed = ifelse(impact.player != "STRYCOVA", speed.start, 0)) 
```

```{r}
#code for this chunk relatively unchanged
# replaced ballmark.x with projected.ballmark.x; speed1 replaced by speed.start

stry17_df <- stry17_df %>%
  mutate(speed.diff = NA) %>%
  mutate(oppo.hit.x = NA) %>%
  mutate(oppo.hit.y = NA) %>%
  mutate(oppo.hit.z = NA) %>%
  mutate(oppo.speed = NA) %>%
  mutate(oppo.projected.ballmark.x = NA) %>%
  mutate(oppo.projected.ballmark.y = NA) %>%
  mutate(speed.ratio = NA) 


for (i in 2:nrow(stry17_df)) {
  if(stry17_df$shot[i] != 1) {#so that only non-serves are affected

  stry17_df$speed.diff[i]=stry17_df$speed.start[i]-stry17_df$speed.start[i-1]
  #speed difference
  
  stry17_df$oppo.hit.x[i]=stry17_df$start.x[i-1]
  stry17_df$oppo.hit.y[i]=stry17_df$start.y[i-1]
  stry17_df$oppo.hit.z[i]=stry17_df$start.z[i-1]
  stry17_df$oppo.speed[i]=stry17_df$speed.start[i-1]
  stry17_df$oppo.projected.ballmark.x[i]=stry17_df$projected.ballmark.x[i-1]
  stry17_df$oppo.projected.ballmark.y[i]=stry17_df$projected.ballmark.y[i-1]
  #oppo hit
  
  }
}

stry17_df <- stry17_df %>%
  mutate(speed.ratio = speed.start/oppo.speed) %>% #speed ratio
  mutate(side.dist = 4.115 - abs(oppo.projected.ballmark.y)) %>% #distance of oppo.projected.ballmark from sideline
  mutate(base.dist = 11.89 - abs(oppo.projected.ballmark.x)) %>% #distance of oppo.projected.ballmark from baseline
  mutate(short.dist = min(side.dist, base.dist)) #shortest distance from any line


#Adding angles
stry17_df <- stry17_df %>%
  mutate(p.start.shot.x = NA) %>%
  mutate(p.start.shot.y = NA)

for (i in 3:nrow(stry17_df)) {
  if(stry17_df$impact.player[i] == stry17_df$impact.player[i-2] & stry17_df$shot[i] == stry17_df$shot[i-2] + 2) {
    stry17_df$p.start.shot.x[i]=stry17_df$start.x[i-2]
    stry17_df$p.start.shot.y[i]=stry17_df$start.y[i-2]
  }
}

#adding angle between stry.shot-opp.shot vector and opp.shot-opp.projected.ballmark vector
#doing it in one line because df doesn't want to add vectors
stry17_df <- stry17_df %>%
  mutate(o.angle = NA)
  
for (i in 1:nrow(stry17_df)) {
  x1 <- stry17_df$p.start.shot.x[i]
  y1 <- stry17_df$p.start.shot.y[i]
  x2 <- stry17_df$oppo.hit.x[i]
  y2 <- stry17_df$oppo.hit.y[i]
  x3 <- stry17_df$oppo.projected.ballmark.x[i]
  y3 <- stry17_df$oppo.projected.ballmark.y[i]
  
  o.angle <- acos(
  ((c(x1,y1)-c(x2,y2))/sqrt((x1-x2)^2+(y1-y2)^2)) %*%
    ((c(x2,y2)-c(x3,y3))/sqrt((x2-x3)^2+(y2-y3)^2))) * 180/pi
  
  stry17_df$o.angle[i] = ifelse(o.angle > 90, 180-o.angle, o.angle)
}

#Now adding the angle the player hits
stry17_df <- stry17_df %>%
  mutate(p.angle = NA)
  
for (i in 1:nrow(stry17_df)) {
  x1 <- stry17_df$oppo.hit.x[i]
  y1 <- stry17_df$oppo.hit.y[i]
  x2 <- stry17_df$start.x[i]
  y2 <- stry17_df$start.y[i]
  x3 <- stry17_df$projected.ballmark.x[i]
  y3 <- stry17_df$projected.ballmark.y[i]
  
  p.angle <- acos(
  ((c(x1,y1)-c(x2,y2))/sqrt((x1-x2)^2+(y1-y2)^2)) %*%
    ((c(x2,y2)-c(x3,y3))/sqrt((x2-x3)^2+(y2-y3)^2))) * 180/pi
  
  stry17_df$p.angle[i] = ifelse(p.angle > 90, 180-p.angle, p.angle)
}

stry17_df <- stry17_df %>%
  group_by(rally.number) %>%
  mutate(lag.p.angle = dplyr::lag(p.angle, n = 1, default = NA)) %>%
  mutate(lag.speed.ratio = dplyr::lag(speed.ratio, n = 1, default = NA)) %>%
  mutate(lag.p.movement.angle.1 = dplyr::lag(p.movement.angle.1, n = 1, default = NA)) %>%
  mutate(lag.p.movement.angle.2 = dplyr::lag(p.movement.angle.2, n = 1, default = NA)) %>%
  mutate(lag.oppo.height.off.net = dplyr::lag(oppo.height.off.net, n = 1, default = NA)) %>%
  mutate(lag.p.start.shot.speed = dplyr::lag(p.start.shot.speed, n = 1, default = NA)) %>%
  mutate(lag.oppo.start.shot.speed = dplyr::lag(oppo.start.shot.speed, n = 1, default = NA)) %>%
  ungroup


```





```{r}
stry17_df <- stry17_df %>%
  mutate(oppo.start.server.x = ifelse(server != "STRYCOVA", start.server.x, 0)) 
```



```{r  }

#creating new rows so that every second row start and end player positions are switched
#Also creating new rows so that every second row in start.x,/start.y is projected ballmark
#this allows us to better plot player positions as well as track positions for animations

joinstry17_df <- transform(stry17_df, p.start.position.x=p.end.position.x, p.start.position.y=p.end.position.y, oppo.start.position.x=oppo.end.position.x, oppo.start.position.y=oppo.end.position.y, start.x=projected.ballmark.x, start.y=projected.ballmark.y)

stry17_pos <- bind_rows(stry17_df, setNames(joinstry17_df, names(stry17_df))) %>% 
           arrange(rally.number, shot)

stry17_pos <- stry17_pos %>%
  group_by(rally.number, idx = cumsum(event == 1L)) %>%
  mutate(location.id= row_number()) %>%
  ungroup

stry17_pos <- stry17_pos %>%
  group_by(rally.number) %>%
  mutate(pos.rally.count= 1:n()) %>%
  ungroup
``` 





```{r }
#remove opponents
stry17_no.opp <- stry17_df %>% 
  dplyr::filter(impact.player == "STRYCOVA")

#STRYCOVA only - remove serves
stry17_only <- stry17_no.opp %>%
  filter(hitpoint != "S") %>%
  dplyr::select(-serveid)


#First remove any errors for start, projected.ballmark, so that we are only looking at shots that we hit onto the other side
#To check: ggplot(stry17_only, aes(projected.ballmark.x, projected.ballmark.y)) + geom_point()
stry17_only <- stry17_only %>%
  filter(oppo.hit.x >= 0) %>%
  filter(oppo.projected.ballmark.x <= 0) %>%
  filter(projected.ballmark.x >= 0)

#Adding shot number cumulative count (functions as time)
#check this for new data set .
stry17_only <- stry17_only %>%
  mutate(count = 1)

  for (i in 2:nrow(stry17_only)) {
    if(stry17_only$matchid[i]==stry17_only$matchid[i-1]) {
      stry17_only$count[i] = stry17_only$count[i-1] + 1
    }
  }

  

#Adjusting to remove NAs and replace with 0s for modelling
stry17_only$o.angle[is.na(stry17_only$o.angle)] <- 0
stry17_only$lag.p.angle[is.na(stry17_only$lag.p.angle)] <- 0
stry17_only$lag.speed.ratio[is.na(stry17_only$lag.speed.ratio)] <- 0
stry17_only$p.start.shot.x[is.na(stry17_only$p.start.shot.x)] <- 0
stry17_only$p.start.shot.y[is.na(stry17_only$p.start.shot.y)] <- 0
stry17_only$lag.p.movement.angle.1[is.na(stry17_only$lag.p.movement.angle.1)] <- 0
stry17_only$lag.p.movement.angle.2[is.na(stry17_only$lag.p.movement.angle.2)] <- 0
stry17_only$lag.oppo.height.off.net[is.na(stry17_only$lag.oppo.height.off.net)] <- 0



stry17_only <- stry17_only %>% mutate(player.total.shot.number = row_number())
```


```{r}
#variables for speed of ball at the start of shot arcs

stry17_only <- stry17_only %>%
  mutate(avg.p.start.shot.speed = mean(p.start.shot.speed)) %>%
  mutate(avg.lag.oppo.start.shot.speed = mean(lag.oppo.start.shot.speed)) %>%
  mutate(diff.p.avg.and.current.shot.speed = p.start.shot.speed- avg.p.start.shot.speed) %>%
  mutate(diff.lag.oppo.avg.and.current.shot.speed = lag.oppo.start.shot.speed- avg.lag.oppo.start.shot.speed) 


  
```



```{r}
#making y positions absolute for stry17_only as this is more relevant for the depmix model

stry17_only <- stry17_only %>%
  mutate(p.start.position.y = abs(p.start.position.y)) %>%
  mutate(p.end.position.y = abs(p.end.position.y)) %>%
  mutate(oppo.start.position.y = abs(oppo.start.position.y)) %>%
  mutate(oppo.end.position.y = abs(oppo.end.position.y))%>%
  mutate(p.start.shot.y =abs(p.start.shot.y))
  
  

```
```{r}
#Save output
stry17_only[is.na(stry17_only)] <- 0
write.csv(stry17_only, "data/stry17_only.csv")
```




#Top down court view

```{r}
library(gganimate)
library(tweenr)
library(transformr)
```
```{r }
#
library(plotly)
#--- Packages Required
# require(ggplot2)
# require(plotly)

#--- Outline of the court
court_trace <- data.frame(x = c(-11.89, -11.89, 0, 0, 0, 11.89, 11.89, -11.89, -11.89, 11.89, 11.89, -11.89, -6.4, -6.4, 6.4, 6.4, 6.4, -6.4),
                          y = c(5.49, -5.49, -5.49, 5.49, -5.49, -5.49, 5.49, 5.49, 4.115, 4.115, -4.115, -4.115, -4.115, 4.115, 4.115, -4.115, 0, 0),
                          z = c(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0))
net_trace <- data.frame(x = c(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0),
                        y = c(-5.49,-5.49, -6.4, -6.4, -5.49, 0, 5.49, 6.4, 6.4, 5.49, 5.49),
                        z = c(1.07, 0, 0, 1.07, 1.07, 0.914, 1.07, 1.07, 0, 0, 1.07))
service_trace <- data.frame(x = c(-8, 0, 0, 0, -6.4, -6.4, 0, -6.4, -6.4, -6.4, -6.4, -6.4,  0, 0, -8),
                            y = c(-5.49, -5.49, -4.115, 4.115, 4.115, 0, 0, 0, -4.115, -5.49, 5.49, -4.115, -4.115, 5.49, 5.49),
                            z = c(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ,0 ,0))
    
axis_labels <- data.frame(x.break = c(-21.89:-11.89, -6.4, 0, 6.4, 11.89),
                          x.label = c("-10m","","","","","-5m","","","","",
                                      "Baseline","Service Line","Net","Service Line","Baseline"),
                          y.break = c(-5.49,-4.115,0,4.115,5.49),
                          y.label = c("Doubles", "Singles","Centre","Singles","Doubles"),
                          z.break = c(0,0.992,2,3,4),
                          z.label = c("Ground", "Net", "2m", "3m", "4m"))
#--- Top down court view
court_topdown <- ggplot() + 
    labs(x = "x direction", y = "y direction") + 
    scale_x_continuous(breaks = axis_labels$x.break,
                       labels = axis_labels$x.label) +
    scale_y_continuous(breaks = axis_labels$y.break,
                       labels = axis_labels$y.label) +
    geom_path(data = court_trace, aes(x = x, y = y), color = 'black', size = 1, alpha = 0.75) +
    geom_path(data = net_trace, aes(x = x, y = y), color = 'grey40', size = 1, lineend = 'round') +
    coord_fixed()



  
```
##Glossary of added variables
Winter Research Project
lastshot - last shot in the point
fedhit - federer hits the shot
isserver - if server hits the shot
winner - if shot is winner (i.e. point doesn’t end in error, as opponent doesn’t reach the ball)
speed.diff - difference in current shot speed vs opponents last shot speed (at impact)
speed.ratio - shot speed/opponent’s previous shot speed
speed1 - speed of shot from impact with racquet
o.angle - angle made by opponents previous shot
p.angle - angle made by player’s current shot
lag.p.angle - angle made by player’s previous shot in rally
lag.speed.ratio - speed ratio of player’s previous shot in rally
oppo.hit - coordinates of opponents previous impact

Summer Research Project
winner.return.error - Classifies whether the current shot ended in winner, was returned into play or ended in error

rally.number - Numerical count of rally number within match

avg.player.speed.diff - difference in player and opponent average speed of movement from start of current shot to end of next in m/s

peak.player.speed.diff - difference in player and opponent peak speed of movement from start of current shot to end of next in m/s

avg.player.speed.ratio - ratio in player and opponent average speed of movement from start of current shot to end of next in m/s

peak.player.speed.ratio - ratio in player and opponent peak speed of movement from start of current shot to end of next in m/s

avg.player.acceleration.diff - difference in player and opponent average speed of movement from start of current shot to end of next in m/s

peak.player.acceleration.diff - difference of player and opponent avg acceleration during shot in m/s2.

avg.player.acceleration.ratio - ratio of player and opponent avg acceleration during shot in m/s2.

peak.player.acceleration.ratio - ratio of player and opponent peak acceleration during shot in m/s2.

p.avg.speed.match - players average speed of movement for the match in m/s

oppo.avg.speed.match - opponents average speed of movement for the match in m/s

p.diff.avg.shot.and.match.movement.speed - difference between players average movement speed for the current shot (from the start of the current shot to the end of the next) compared to their match average in m/s

oppo.diff.avg.shot.and.match.movement.speed - difference between opponents average movement speed for the current shot (from the start of the current shot to the end of the next) compared to their match average in m/s

p.rally.side.change.count - the number of times the player has run from the forehand(backhand) side to the backhand(forehand) side within the rally

oppo.rally.side.change.count - the number of times the opponent has run from the forehand(backhand) side to the backhand(forehand) side within the rally

rally.side.change.count.diff - the difference in the number of times the player and opponent have changed sides within the rally

rally.distance.run.ratio - the ratio player/opponent total distance run within the rally

p.movement.angle.1 - The angle the player runs from the start to the end of their current shot (o.deg directly towards the net 180.deg directly away from the net)

p.movement.angle.2 The angle the player runs from the end of their current shot to the start of their next shot (o.deg directly towards the net 180.deg directly away from the net)

oppo.movement.angle.1 - The angle the opponent runs from the start to the end of their current shot (o.deg directly towards the net 180.deg directly away from the net)

oppo.movement.angle.2 - The angle the opponent runs from the end of their current shot to the start of their next shot (o.deg directly towards the net 180.deg directly away from the net)

lag.oppo.height.off.net - Meters above net of opponents previous shot 

lag.p.start.shot.speed - Speed at the start of the arc in m/s of the players previous shot

lag.oppo.start.shot.speed - Speed at the start of the arc in m/s of the opponents previous shot







##Visualisation
```{r }
#player baseline/centre distance differentials


ggplot(longral_pos, aes(x=shot,y=p.start.position.base.diff)) +
  geom_point() +
  geom_path() + 
  geom_hline(yintercept = 0, linetype = "dotdash") + 
  facet_wrap(~rally.number) + 
  xlab("Shot Number")  + 
  ylab("Difference in distance from baseline Federer Vs Opponent") + 
  ggtitle("Federer vs Opponent difference in baseline distance in rallies 10 shots or more")

ggplot() + 
  geom_path(data=longral_pos, aes(x = shot, y = p.start.position.y, col="blue")) +
  geom_path(data=longral_pos, aes(x = shot, y = oppo.start.position.y, col="red")) +
  geom_hline(yintercept = 0, linetype = "dotdash") + 
  facet_wrap(~rally.number) + 
  xlab("Shot Number")  + 
  ylab("Distance from centre for Federer and Opponent") + 
  ggtitle("Federer vs Opponent distance from centre in rallies 10 shots or more") +
  scale_colour_manual(name = "Player", values=c("blue","red"), labels= c("Federer","Berdych"))
  
  
ggplot() + 
  geom_path(data=longral_pos, aes(x = shot, y = p.start.position.base.dist, 
                                  yend =p.end.position.base.dist, col="blue")) +
  geom_path(data=longral_pos, aes(x = shot, y = oppo.start.position.base.dist,
                                  yend =oppo.end.position.base.dist,col="red")) +
  geom_hline(yintercept = 0, linetype = "dotdash") + 
  facet_wrap(~rally.number) + 
  xlab("Shot Number")  + 
  ylab("Distance from baseline for Federer and Opponent") + 
  ggtitle("Federer vs Opponent distance from baseline in rallies 10 shots or more") +
  scale_colour_manual(name = "Player", values=c("blue","red"), labels= c("Federer","Berdych"))
```
```{r }
#speed/acceleration differentials
ggplot() + 
  geom_path(data=longral_df, aes(x = shot, y = p.avg.speed, col="blue")) +
  geom_path(data=longral_df, aes(x = shot, y = oppo.avg.speed, col="red")) + 
  facet_wrap(~rally.number) + 
  xlab("Shot Number")  + 
  ylab("Avg Movement Speed m/s  Federer and Opponent") + 
  ggtitle("Federer vs Opponent Avg Movement Speed in Rallies 10 shots or more") +
  scale_colour_manual(name = "Player", values=c("blue","red"), labels= c("Federer","Berdych"))

ggplot(longral_pos, aes(x=shot,y=avg.player.speed.diff)) +
  geom_path() + 
  geom_hline(yintercept = 0, linetype = "dotdash") + 
  facet_wrap(~rally.number) + 
  xlab("Shot Number")  + 
  ylab("Difference Avg Movement Speed m/s  Federer vs Opponent") + 
  ggtitle("Federer vs Opponent difference in Avg Movement Speed m/s  Federer and Opponent in rallies 10 shots or more")

```
```{r }
#Shot Type by coordinates
ggplot(dlb_fedonly, aes(x=start.x,y=start.y)) + 
  scale_x_continuous(breaks = axis_labels$x.break) +
    scale_y_continuous(breaks = axis_labels$y.break) +
    geom_path(data = court_trace, aes(x = x, y = y), color = 'black', size = 1, alpha = 0.75) +
    geom_path(data = net_trace, aes(x = x, y = y), color = 'grey40', size = 1, lineend = 'round') +
    coord_fixed() +
  geom_point() + 
  xlab("X Coordinate") + 
  ylab("Y Coordinate") + 
  ggtitle("Federer Down the Line Backhands By Shot Co-Ordinates") 

ggplot(iof_fedonly, aes(x=start.x,y=start.y)) + 
  scale_x_continuous(breaks = axis_labels$x.break) +
    scale_y_continuous(breaks = axis_labels$y.break) +
    geom_path(data = court_trace, aes(x = x, y = y), color = 'black', size = 1, alpha = 0.75) +
    geom_path(data = net_trace, aes(x = x, y = y), color = 'grey40', size = 1, lineend = 'round') +
    coord_fixed() +
  geom_point() + 
  xlab("X Coordinate") + 
  ylab("Y Coordinate") + 
  ggtitle("Federer Inside out Forehands By Shot Co-Ordinates") 

ggplot(dlw_fedonly, aes(x=start.x,y=start.y)) + 
  scale_x_continuous(breaks = axis_labels$x.break) +
    scale_y_continuous(breaks = axis_labels$y.break) +
    geom_path(data = court_trace, aes(x = x, y = y), color = 'black', size = 1, alpha = 0.75) +
    geom_path(data = net_trace, aes(x = x, y = y), color = 'grey40', size = 1, lineend = 'round') +
    coord_fixed() +
  geom_point() + 
  xlab("X Coordinate") + 
  ylab("Y Coordinate") + 
  ggtitle("Federer Down the Line Winners By Shot Co-Ordinates")
```


##Modelling

###Replicating some models from winter project

```{r }
#t1m1
library(depmixS4)
library(dplyr)

t1.mod1 <- depmix(winner ~ 1, transition = ~ oppo.speed + ser1 + ser2 + start.x, data = fed16_only, nstates = 2, family=multinomial("identity"))
t1.fm1 <- fit(t1.mod1)

summary(t1.fm1)
```

```{r}
library(depmixS4)
t2.mod1 <- depmix(list(winner ~ 1, speed.ratio ~ 1), transition = ~ oppo.speed + ser1 + ser2 + start.x + o.angle + oppo.hit.x + lag.p.angle + lag.speed.ratio, data = fed16_only, nstates = 2, family=list(multinomial("identity"), gaussian()))
t2.fm1<- fit(t2.mod1)
 
summary(t2.fm1)
```


#Rallies From Matches at The Australian Open
This project uses Hidden Markov Models to identify player shot intentions from matches at the Australian Open. 

The match data analysed contains information for all rallies 3 shots or longer. Serves and returns of serves have been excluded from the data. The analysis looks at two and three hidden state models to attempt to identify player intentions. 

The two hidden state model extends Jeremy Forbes' research project. The player shot intentions are: attacking or 'winner', where the players aim is to win the point on that shot. And 'return' where the player's aim is just to get the ball back into play. 

The three hidden states model extends this model to include 'errors' where the player unsuccessfully tries to win the point or return the ball into play with that shot.

This analysis is done using the dependent mixture model contained in the depmixS4 package. 

#Modelling
Visual analysis has been used to select a number of new variables from the new data set. For the two hdden state model 'winner' is the response variable. For the 

Covariates are...
The covariates chosen are...(just try out shot index first)

Model training has been used to identify covariates which are useful for predicting the states of many different players.A training model has been created by using a step-wise approach to identify the best combination of covariates in a chosen match data set. This training model has then been tested on a different data set for a comparison of results. The limitation of this step wise approach is that some potentially important covariates have been ommited from the model because of correlation with other covariates. 

#Training Models
The first training model has been made using step-wise for the match data Federer vs Berdych 2016. The best combination of covariates in order of importance are...


#Intepreting the output
##2 state Model
##3 State Models

#Building the Animation

Using the package GGAnimate and a top-down court outline taken from "https://github.com/mvparrot/vis-serve/blob/master/report file helper basic plots".
The variables p.start.position.x, p.end.position.x, oppo.start.position.x, oppo.end.position.x, p.start.position.y, p.end.position.y, oppo.start.position.y, oppo.end.position.y, start.x, start.y, projected.ballmark.x and projected.ballmark.y

transition_reveal has been used for filling in gaps in the player and ball position data. 
To run transition_reveal, a single column was created for the player's start & end position x coordinates, they are grouped by rally number and shot number and alternate between start and end position. The same thing is done for the player's position y coordinates. As well as for the opponent's start and end position x and y coordinates. For animating the ball position, similar columns are created alternating between the start position of the ball and the projected ballmark for both x and y coordinates.

##Visualising player state change in the animation

#Variable creation

#Choosing variables for the model

```{r}
#Confirming choices through visualisation of all variabls described in glossary

```
p.start.position.x-
When compared to similar start position x coordinates, Federer appears more likely to hit a winner as he starts the shot closer to the net. Choosing this variable for HMM as we might expect that the probability of Federer being in an attacking state increases as he moves closer to the net( x value increases). 

p.start.position.y-
Choosing this variable for the HMM as it makes the players start position x coordinates more meaningful when included in the model. We might expect that the probability of Federer being in an attacking state increases as he moves closer to the centre(y value decreases) and to the net. Using absolute value to measure distance from centre.

```{r}

ggplot(fed16_only_plots, aes(x=p.start.position.x,  y=p.start.position.y ))    + 
  geom_path(data = court_trace, aes(x = x, y = y), color = 'black', size = 1, alpha = 0.75) +
  geom_path(data = net_trace, aes(x = x, y = y), color = 'grey40', size = 1, lineend = 'round') +
  coord_fixed() +
  geom_point(aes(alpha = winner))  +   
  xlab("Federer Start Position X ") + ylab("Federer Start Position Y") +
  ggtitle("Federer winners by start position")

ggplot(fed16_only, aes(x=p.start.position.x,winner)) + geom_smooth() + xlab("X Coordinate of Player") + ylab("Proportion of Winners") + ggtitle("Federer Winners By X Co-Ordinate")

ggplot(fed16_only, aes(x=p.start.position.y,winner)) + geom_smooth() + xlab("Distance from Centre of Player") + ylab("Proportion of Winners") + ggtitle("Federer Winners By Distance from Centre")
```



p.start.shot.x-
Similar to Federer's start position x coordinates, the x coordinates of his shot hit point appears more likely to result in a winner compared to similarly distanced shots as he moves closer to the net.

p.start.shot.y-
Including in HMM to make shot x coordinates more meaningful. Using absolute to measures distance from centre. 
```{r}
ggplot(fed16_only_plots, aes(x=p.start.shot.x,  y=p.start.shot.y ))    + 
  geom_path(data = court_trace, aes(x = x, y = y), color = 'black', size = 1, alpha = 0.75) +
  geom_path(data = net_trace, aes(x = x, y = y), color = 'grey40', size = 1, lineend = 'round') +
  coord_fixed() +
  geom_point(aes(alpha = winner))  +   
  xlab("Shot Position X ") + ylab("Shot Position Y") +
  ggtitle("Federer winners by shot location")
```



oppo.start.position.x-
Federer appears more likely to hit a winner as Berdych start position x coordinates are closer to the net. (As we are analysing the rallies with all of Berdych's having positive coordinates in the HMM we would expect a decrease in Berdych's start position x coordinates to increase The probability of Federer being in an attacking state. 
oppo.start.position.y
```{r}
ggplot(fed16_only_plots, aes(x=oppo.start.position.x,  y=oppo.start.position.y ))    + 
  scale_x_continuous(breaks = axis_labels$x.break) +
  scale_y_continuous(breaks = axis_labels$y.break) +
  geom_path(data = court_trace, aes(x = x, y = y), color = 'black', size = 1, alpha = 0.75) +
  geom_path(data = net_trace, aes(x = x, y = y), color = 'grey40', size = 1, lineend = 'round') +
  coord_fixed() +
  geom_point(aes(alpha = winner))  +   
  xlab("Opponent Start Position X ") + ylab("Opponent Start Position Y") +
  ggtitle("Federer winners by Opponent Start Position")

ggplot(fed16_only, aes(x=oppo.start.position.x,winner)) + geom_smooth() + xlab("X Coordinate of Opponent") + ylab("Proportion of Federer Winners") + ggtitle("Federer Winners By Opponent X Co-Ordinate")

ggplot(fed16_only, aes(x=oppo.start.position.y,winner)) + geom_smooth() + xlab("Distance from Centre of Opponent") + ylab("Proportion of Winners") + ggtitle("Federer Winners by Opponent Distance from Centre")
```


p.diff.avg.shot.and.match.movement.speed - 
When Federer runs approximately more than 1m/s above or below his average movement speed for match he tends to hit more winners. This variable therefore appears suitable for the HMM. (Using an absolute value of the difference we would expect an increase in difference to increase the probability of Federer being in a attacking state. (add in more info)
When Considering winners, errors and returns we move back to relative difference as Federer tends to hit more errors than winners when moving approximately 1m/s slower than his average match movement speed 
```{r}
ggplot(fed16_only_plots, aes(x=factor(winner),y=p.diff.avg.shot.and.match.movement.speed, fill=factor(winner))) + geom_boxplot() + ggtitle("Winner by difference in Federer's current and match avg movement speed")

ggplot(fed16_only_plots, aes(x=factor(winner),y=p.diff.avg.shot.and.match.movement.speed, fill=factor(winner))) + geom_violin(scale = "area") + ggtitle("Winner by difference in Federer's current and match avg movement speed")


ggplot(fed16_only_plots, aes(x=factor(winner.return.error),y=(p.diff.avg.shot.and.match.movement.speed), fill=factor(winner.return.error))) + geom_violin(scale = "area") + ggtitle("Winner by absolute difference in Federer's current/match avg movement speed")
```


oppo.diff.avg.shot.and.match.movement.speed - 
Federer tends to hit more winners as Berdych runs more than 1m/s faster than his average match movement speed. This is a suitable variable for the HMM we would expect an increase in the difference to increase Federer's probability of being in an attacking state. 
```{r}
ggplot(fed16_only_plots, aes(x=factor(winner),y=oppo.diff.avg.shot.and.match.movement.speed, fill=factor(winner))) + geom_boxplot() + ggtitle("Winner by difference in Opponent current/match avg movement speed")

ggplot(fed16_only_plots, aes(x=factor(winner),y=oppo.diff.avg.shot.and.match.movement.speed, fill=factor(winner))) + geom_violin(scale = "area") + ggtitle("Winner by difference in Opponent current/match avg movement speed")

# ggplot(fed16_only_plots, aes(x=factor(winner.return.error),y=oppo.diff.avg.shot.and.match.movement.speed, fill=factor(winner.return.error))) + geom_violin(scale = "area") + ggtitle("Winner by difference in Opponent current/match avg movement speed")

```

p.rally.side.change.count - 
Not suitable
```{r}
ggplot(fed16_only_plots, aes(x=p.rally.side.change.count, y=winner)) + geom_bar(stat="identity") + xlab("Rally Side Change Count") + ylab("Proportion of Winners") + ggtitle("Winners By Number of Times Federer Changes Side in Rally")
```


oppo.rally.side.change.count - 
Might be suitable when looking at a greater number of rallies. 
```{r}
ggplot(fed16_only_plots, aes(x=oppo.rally.side.change.count, y=winner)) + geom_bar(stat="identity") + xlab("Rally Side Change Count") + ylab("Proportion of Winners") + ggtitle("Winners By Number of Times Berdych Changes Side in Rally")

```


p.movement.angle.1 - 
 more than 75% of Federer's Winners come when he is running less than 100 degrees in relation to the baseline. This variable appears suitable for HMM we would expect as Federer's movement angle increases beyond 100 degrees the probability the he is an attacking state decreases.
```{r}
ggplot(fed16_only_plots, aes(x=p.movement.angle.1,y=winner)) + geom_smooth() + xlab("Angle Made By Federer's movement") + ylab("Proportion of Winners") + ggtitle("Winners By Federer's start to end movement angle")

ggplot(fed16_only, aes(x=factor(winner),y=p.movement.angle.1, fill=factor(winner))) + geom_boxplot() + ggtitle("Winner by Federer's start to end movement angle")

ggplot(fed16_only, aes(x=factor(winner),y=p.movement.angle.1, fill=factor(winner))) + geom_violin(scale = "area") + ggtitle("Winner by Federer's start to end movement angle")

# ggplot(fed16_only, aes(x=factor(winner.return.error),y=p.movement.angle.1, fill=factor(winner.return.error))) + geom_violin(scale = "area") + ggtitle("Winner by Federer's start to end movement angle")
```


oppo.movement.angle.1 - 
Need more evidence to include in model
```{r}
ggplot(fed16_only_plots, aes(x=oppo.movement.angle.1,y=winner)) + geom_smooth() + xlab("Angle Made By Berdych's movement") + ylab("Proportion of Winners") + ggtitle("Winners By Berdych's start to end movement angle during Federer's shot")

ggplot(fed16_only, aes(x=factor(winner),y=oppo.movement.angle.1, fill=factor(winner))) + geom_boxplot() + ggtitle("Winner by Berdych's start to end movement angle during Federer's shot")

ggplot(fed16_only, aes(x=factor(winner),y=oppo.movement.angle.1, fill=factor(winner))) + geom_violin(scale = "area") + ggtitle("Winner by Berdych's start to end movement angle during Federer's shot")

```


lag.oppo.height.off.net - 
Federer tends to hit more winners when incoming shot approaches 50cm off the height of the net. This decreases as the height of the incoming shot increases or decreases. Including this variable in the HMM. Expect the coefficient to be small. 

```{r}
ggplot(fed16_only_plots, aes(x=lag.oppo.height.off.net,y=winner)) + geom_smooth() + xlab("Height of opponents shot") + ylab("Proportion of Winners") + ggtitle("Winners by Height over Net of Most recent Opponent shot")


```

diff.p.avg.and.current.shot.speed
```{r}


ggplot(fed16_only, aes(x=factor(winner),y=diff.p.avg.and.current.shot.speed, fill=factor(winner))) + geom_boxplot() + ggtitle("Winner by player current/average shot speed difference")



```









#Appendix
##Visualisations of Shot Patterns
###Federer vs Berdych 2016
```{r}
ggplot(longral_pos, aes(x=shot,y=p.start.position.base.diff)) +
  geom_point() +
  geom_path() + 
  geom_hline(yintercept = 0, linetype = "dotdash") + 
  facet_wrap(~rally.number) + 
  xlab("Shot Number")  + 
  ylab("Difference in distance from baseline Federer Vs Opponent") + 
  ggtitle("Federer vs Opponent difference in baseline distance in rallies 10 shots or more")

ggplot() + 
  geom_path(data=longral_pos, aes(x = shot, y = p.start.position.y, col="blue")) +
  geom_path(data=longral_pos, aes(x = shot, y = oppo.start.position.y, col="red")) +
  geom_hline(yintercept = 0, linetype = "dotdash") + 
  facet_wrap(~rally.number) + 
  xlab("Shot Number")  + 
  ylab("Distance from centre for Federer and Opponent") + 
  ggtitle("Federer vs Opponent distance from centre in rallies 10 shots or more") +
  scale_colour_manual(name = "Player", values=c("blue","red"), labels= c("Federer","Berdych"))
  
  
ggplot() + 
  geom_path(data=longral_pos, aes(x = shot, y = p.start.position.base.dist, 
                                  yend =p.end.position.base.dist, col="blue")) +
  geom_path(data=longral_pos, aes(x = shot, y = oppo.start.position.base.dist,
                                  yend =oppo.end.position.base.dist,col="red")) +
  geom_hline(yintercept = 0, linetype = "dotdash") + 
  facet_wrap(~rally.number) + 
  xlab("Shot Number")  + 
  ylab("Distance from baseline for Federer and Opponent") + 
  ggtitle("Federer vs Opponent distance from baseline in rallies 10 shots or more") +
  scale_colour_manual(name = "Player", values=c("blue","red"), labels= c("Federer","Berdych"))
```

```{r }
#Shot Type by coordinates
ggplot(dlb_fedonly, aes(x=start.x,y=start.y)) + 
  scale_x_continuous(breaks = axis_labels$x.break) +
    scale_y_continuous(breaks = axis_labels$y.break) +
    geom_path(data = court_trace, aes(x = x, y = y), color = 'black', size = 1, alpha = 0.75) +
    geom_path(data = net_trace, aes(x = x, y = y), color = 'grey40', size = 1, lineend = 'round') +
    coord_fixed() +
  geom_point() + 
  xlab("X Coordinate") + 
  ylab("Y Coordinate") + 
  ggtitle("Federer Down the Line Backhands By Shot Co-Ordinates") 

ggplot(iof_fedonly, aes(x=start.x,y=start.y)) + 
  scale_x_continuous(breaks = axis_labels$x.break) +
    scale_y_continuous(breaks = axis_labels$y.break) +
    geom_path(data = court_trace, aes(x = x, y = y), color = 'black', size = 1, alpha = 0.75) +
    geom_path(data = net_trace, aes(x = x, y = y), color = 'grey40', size = 1, lineend = 'round') +
    coord_fixed() +
  geom_point() + 
  xlab("X Coordinate") + 
  ylab("Y Coordinate") + 
  ggtitle("Federer Inside out Forehands By Shot Co-Ordinates") 

ggplot(dlw_fedonly, aes(x=start.x,y=start.y)) + 
  scale_x_continuous(breaks = axis_labels$x.break) +
    scale_y_continuous(breaks = axis_labels$y.break) +
    geom_path(data = court_trace, aes(x = x, y = y), color = 'black', size = 1, alpha = 0.75) +
    geom_path(data = net_trace, aes(x = x, y = y), color = 'grey40', size = 1, lineend = 'round') +
    coord_fixed() +
  geom_point() + 
  xlab("X Coordinate") + 
  ylab("Y Coordinate") + 
  ggtitle("Federer Down the Line Winners By Shot Co-Ordinates")
```
```{r}
#Angle of movement
ggplot(fed16_only, aes(x=oppo.movement.angle.1,y=winner)) + geom_smooth() + xlab("Angle Made By Opponents movement") + ylab("Proportion of Winners") + ggtitle("Winners By Opponent movement angle 1")

ggplot(fed16_only, aes(x=p.movement.angle.1,y=winner)) + geom_smooth() + xlab("Angle Made By Federer's movement") + ylab("Proportion of Winners") + ggtitle("Winners By Federer's movement angle 1")

ggplot(fed16_only, aes(x=p.movement.angle.1,y=p.peak.speed)) + geom_smooth() + xlab("Angle Made By Federer's movement") + ylab("Federers Peak Speed") + ggtitle("Winners By Federer's movement angle 1")


```


```{r}
# #Movement and shot position seperated by forehand and backhand
# ggplot(longral_df, aes(x=p.start.position.x,y=p.start.position.y,z=winner))  + stat_summary_hex(fun = function(winner) sum(winner)) + facet_wrap(~factor(hitpoint)) + xlab("Player start Position X ") + ylab("Player start Position Y") + ggtitle("Federer winners by start position seperated by shot type for long rallies")
# 
# ggplot(longral_df, aes(x=p.end.position.x,y=p.end.position.y,z=winner))  + stat_summary_hex(fun = function(winner) sum(winner)) + facet_wrap(~factor(hitpoint)) + xlab("Player end Position X ") + ylab("Player end Position Y") + ggtitle("Federer winners by end position seperated by shot type for long rallies")
# 
# ggplot(longral_df, aes(x=p.start.position.x,y=p.start.position.y,z=is.good))  + stat_summary_hex(fun = function(is.good) sum(is.good)) + facet_wrap(~factor(hitpoint)) + xlab("Player start Position X ") + ylab("Player start Position Y") + ggtitle("Federer errors by start position seperated by shot type for long rallies")
# 
# ggplot(longral_df, aes(x=p.end.position.x,y=p.end.position.y,z=is.good))  + stat_summary_hex(fun = function(is.good) sum(is.good)) + facet_wrap(~factor(hitpoint)) + xlab("Player end Position X ") + ylab("Player end Position Y") + ggtitle("Federer errors by end position seperated by shot type for long rallies")
# 
# ggplot(longral_df, aes(x=p.start.position.x,y=p.start.position.y,z=time.to.net))  + stat_summary_hex(fun = function(time.to.net) sum(time.to.net)) + facet_wrap(~factor(hitpoint)) + xlab("Player start Position X ") + ylab("Player start Position Y") + ggtitle("Federer shot time to net by start position seperated by shot type for long rallies")
# 
# ggplot(longral_df, aes(x=p.end.position.x,y=p.end.position.y,z=time.to.net))  + stat_summary_hex(fun = function(time.to.net) sum(time.to.net)) + facet_wrap(~factor(hitpoint)) + xlab("Player end Position X ") + ylab("Player end Position Y") + ggtitle("Federer shot time to net by end position seperated by shot type for long rallies")

```
```{r}
#Visulaising speed ratio

ggplot(fed16_df, aes(x=base.dist,y=speed.ratio)) + geom_smooth() + xlab("Distance from the baseline") + ylab("Speed Ratio") + ggtitle("Speed ratio by distance from the baseline For match")

ggplot(fed16_only, aes(x=base.dist,y=speed.ratio)) + geom_smooth() + xlab("Distance from the baseline") + ylab("Speed Ratio") + ggtitle("Fed Only Speed ratio by distance from the baseline For match")

ggplot(longral_df, aes(x=base.dist,y=speed.ratio)) + geom_smooth() + xlab("Distance from the baseline") + ylab("Speed Ratio") + ggtitle("Speed ratio by distance from the baseline For Long Rallies")

ggplot(longest_df, aes(x=base.dist,y=speed.ratio)) + geom_smooth() + xlab("Distance from the baseline") + ylab("Speed Ratio") + ggtitle("Speed ratio by distance from the baseline For Longest Rally")




#Visualising player shot angles

ggplot(fed16_df, aes(x=base.dist,y=p.angle)) + geom_smooth() + xlab("Distance from the baseline") + ylab("Angle Made By Federers Shot") + ggtitle("Federer Shot Angle by distance from the baseline")

ggplot(fed16_only, aes(x=base.dist,y=p.angle)) + geom_smooth() + xlab("Distance from the baseline") + ylab("Angle Made By Federers Shot") + ggtitle("Fed only Shot Angle by distance from the baseline")

ggplot(fed16_df, aes(x=base.dist,y=o.angle)) + geom_smooth() + xlab("Distance from the baseline") + ylab("Angle Made By Berdych previous Shot") + ggtitle("Berdych Shot Angle by Federer distance from the baseline")


```


```{r}
##Plots of shot and ballmark co-ordinates, angles made by shots and speed 
library(ggplot2)
#X Co-ordinate of shot
ggplot(fed16_only, aes(x=start.x,winner)) + geom_smooth() + xlab("X Coordinate of Shot") + ylab("Proportion of Winners") + ggtitle("Winners By X Co-Ordinate")

#Opponents shot before
library(hexbin)
ggplot(fed16_only, aes(x=oppo.hit.x,y=oppo.hit.y,z=winner)) + stat_summary_hex(fun = function(winner) sum(winner)) + xlab("X Coordinate of Oppo Shot") + ylab("Y Coordinate of Oppo Shot") + ggtitle("Count of Winners By Opponent's Shot Co-Ordinates")
### Get help transforming this to proportion in each bin instead of raw count

#Fed Shots on x-y plane
ggplot(fed16_only, aes(x=start.x,y=start.y,z=winner)) + stat_summary_hex(fun = function(winner) sum(winner)) + xlab("X Coordinate") + ylab("Y Coordinate") + ggtitle("Winners By Shot Co-Ordinates")

#Fed Ballmark by winner in x-y plane
ggplot(fed16_only, aes(x=projected.ballmark.x,y=projected.ballmark.y,z=winner)) + stat_summary_hex(fun = function(winner) sum(winner)) + xlab("X Coordinate") + ylab("Y Coordinate") + ggtitle("Winners By Shot Ballmark Co-Ordinates")


#Angle of shots
ggplot(fed16_only, aes(x=o.angle,y=winner)) + geom_smooth() + xlab("Angle Made By Opponents Shot With Fed's Previous Shot") + ylab("Proportion of Winners") + ggtitle("Winners By Opponent Shot Angle")

ggplot(fed16_only, aes(x=p.angle,y=winner)) + geom_smooth() + xlab("Angle Made By Federer's Shot") + ylab("Proportion of Winners") + ggtitle("Winners By Federer's Shot Angle")

ggplot(fed16_only) + geom_density(aes(p.angle,group=factor(winner),color=factor(winner))) + ggtitle("Density of Winners by Fed Shot Angles")

ggplot(fed16_only) + geom_density(aes(o.angle,group=factor(winner),color=factor(winner))) + ggtitle("Density of Winners by Opponent Shot Angles")

#Winners by oppo speed
ggplot(fed16_only) + geom_density(aes(oppo.speed, group = factor(winner), color=factor(winner)))

ggplot(fed16_only, aes(x=factor(winner),y=oppo.speed,fill=factor(winner))) + geom_boxplot() + ggtitle("Winner by Opponent Speed")

#Winners by speed ratio
ggplot(fed16_only) + geom_density(aes(speed.ratio, group = factor(winner), color=factor(winner)))

ggplot(fed16_only, aes(x=factor(winner),y=speed.ratio,fill=factor(winner))) + geom_boxplot() + ggtitle("Winner by Speed Ratio")
```
##Depmix Models
Examined three data sets:
Data Set One: Federer vs Berdych 2016
Data Set Two: Federer vs Berdych 2016/17/17
Data Set Three: Strycova vs Garcia 2016/17
###Federer 2016 Data Set 1
Training Model 1 for Data Set 1 (Federer vs Berdych 2016)
Training Model 1 is the best combination of variables found from running step-wise on Data Set 1
```{r}
library(dplyr)

#choosing variables of interest
fed16_dep <- fed16_only[, c( "p.start.position.x", "p.start.position.y", "oppo.start.position.x", "oppo.start.position.y", "p.movement.angle.1", "p.start.shot.x", "p.start.shot.y", "p.diff.avg.shot.and.match.movement.speed",  "oppo.diff.avg.shot.and.match.movement.speed", "diff.p.avg.and.current.shot.speed",  "lag.oppo.height.off.net", "winner.return.error", "p.advantage")]


```


```{r}
#scaling variables from 0 min to 1 max for comparison to hidden states plot
fed16_scale <- fed16_only[, c(  "p.start.position.x", "p.start.position.y", "oppo.start.position.x", "oppo.start.position.y", "p.movement.angle.1", "p.start.shot.x", "p.start.shot.y", "p.diff.avg.shot.and.match.movement.speed",  "oppo.diff.avg.shot.and.match.movement.speed", "diff.p.avg.and.current.shot.speed",  "lag.oppo.height.off.net", "winner.return.error", "p.advantage")]

fed16_scale <- as.data.frame(lapply(fed16_dep[c( "p.start.position.x", "p.start.position.y", "oppo.start.position.x", "oppo.start.position.y", "p.movement.angle.1", "p.start.shot.x", "p.start.shot.y", "p.diff.avg.shot.and.match.movement.speed",  "oppo.diff.avg.shot.and.match.movement.speed", "diff.p.avg.and.current.shot.speed",  "lag.oppo.height.off.net", "winner.return.error", "p.advantage")], function(x) (x-min(x))/(max(x)-min(x))))
#adding winner and total shot number to the df for analysis
fed16_scale <- cbind(fed16_scale, winner = fed16_only$winner)


fed16_scale <- fed16_scale %>% mutate(player.total.shot.number = row_number())
```
```{r}
write.csv(fed16_scale, "data/fed16_scale.csv")
```


```{r}
#Creating correlation matrix for variables of interest. Variables under 50% correlation will show as NA
corMat <- cor(fed16_dep)
corMat_df <- as.data.frame(apply(corMat, 2, function(x) ifelse (abs(x) >=0.5,x,"NA")))
#Removed some variables with significant correlation with other variables above 50%:
#p.end.position.x, p.end.position.y, oppo.end.position.x, oppo.end.position.y, p.rally.side.change.count, p.advantage, p.distance, oppo.distance, fhand, p.advantage, rally.distance.run.ratio, shot
```
####Running Data Set 1 Training Model 1, (2 states)

```{r}
# Variables fitted:
#p.start.position.x, lag.oppo.height.off.net, oppo.diff.avg.shot.and.match.movement.speed, oppo.start.position.x, diff.p.avg.and.current.shot.speed, p.movement.angle.1
 ds1.mod1.2s <- depmix(winner ~ 1, transition = ~ p.start.position.x + lag.oppo.height.off.net + oppo.diff.avg.shot.and.match.movement.speed + oppo.start.position.x + diff.p.avg.and.current.shot.speed + p.movement.angle.1, data = fed16_scale, nstates = 2, family=multinomial("identity"))
 ds1.fm1.2s <- fit(ds1.mod1.2s)
 
 summary(ds1.fm1.2s)
```

```{r}
#Pulling state probabilities from fitted model to add to a dataframe to look for correlation with fitted variables
ds1.fm1.2s_df <- posterior(ds1.fm1.2s)

ds1.fm1.2s_df <- cbind(fed16_scale, ds1.fm1.2s_df)
	
#dropping columns not in the fitted depmix model

 ds1.fm1.2s_df <- ds1.fm1.2s_df[ -c(2, 4, 6:8, 12:14) ]
 
 
```




####Plotting Data Set 1 Training Model 1(2 States)



```{r}
library(dplyr)
#Plotting states for training model fed16
#p.start.position.x, oppo.start.position.x, oppo.diff.avg.shot.and.match.movement.speed, p.diff.avg.shot.and.match.movement.speed, lag.p.angle, oppo.rally.side.change.count, diff.lag.oppo.avg.and.current.shot.speed, diff.p.avg.and.current.shot.speed, p.movement.angle.1, lag.oppo.height.off.net, oppo.start.position.y

probs = posterior(ds1.fm1.2s)

  
 
 	plot(probs$state, type='s', main='Implied States', xlab='', ylab='State')
	
	matplot(probs[,-1], type='l', main='Probabilities', ylab='Probability')
		legend(x='topright', c('State1','State2'),  fill=1:2, bty='n')
		
ggplot() + 
  geom_path(data=fed16_scale, aes(x = player.total.shot.number, y = winner)) +
  xlab("Federer shot Number")  + 
  ylab("Actual State") + 
  ggtitle("Actual state") 	
```

```{r}
#plotting a matrix to identify any correlation between depmix probabilities and chosen variables

library(GGally)
ggduo(ds1.fm1.2s_df, 1:3, 8, showStrips = FALSE)
ggduo(ds1.fm1.2s_df, 4:5, 8, showStrips = FALSE)




```


```{r}
#showing correlation between variables and probaility of being in state 1

cor.ds1.fm1.2s <- cor(ds1.fm1.2s_df)
cor.ds1.fm1.2s_df <- cor.ds1.fm1.2s[ -c(1:5, 7) ]

```
####Running Data Set 1, Training Model 1 (3 states)
```{r}
# Variables fitted:
#p.start.position.x, lag.oppo.height.off.net, oppo.diff.avg.shot.and.match.movement.speed, oppo.start.position.x, diff.p.avg.and.current.shot.speed, p.movement.angle.1
 ds1.mod1.3s <- depmix(winner.return.error ~ 1, transition = ~ p.start.position.x + lag.oppo.height.off.net + oppo.diff.avg.shot.and.match.movement.speed + oppo.start.position.x + diff.p.avg.and.current.shot.speed + p.movement.angle.1, data = fed16_scale, nstates = 3, family=multinomial("identity"))
 ds1.fm1.3s <- fit(ds1.mod1.3s)
 
 summary(ds1.fm1.3s)

```
####Plotting Data Set 1 Training Model 1 (3 states)
```{r}
#plotting Data Set 1 Training Model 1 with 3 states
probs = posterior(ds1.fm1.3s)

	
	
 	plot((probs$state), type='s', main='Implied States', xlab='', ylab='State')
 	
 
	matplot(probs[,-1], type='l', main='Probabilities', ylab='Probability')
		legend(x='topright', c('State1','State2', "State2"),  fill=1:3, bty='n')
		
		
ggplot() + 
  geom_path(data=fed16_scale, aes(x = player.total.shot.number, y = winner.return.error)) +
  xlab("Federer shot Number")  + 
  ylab("Actual State") + 
  ggtitle("Actual state") 


```
###Federer Vs Berdych 2016/17/18
Data Set 2
Training Model two is the best combination of variables from running Step-wise on Data Set 2

#Running Training Model 1 on Data Set 2 (multiple Fed vs Berdych matches 2016, 2017 & 2018)
```{r}
library(dplyr)
#Joining all Federer matches
fed_only <- rbind(fed16_only, fed17_only, fed18_only)
#choosing variables of interest
fed_dep <- fed_only[, c("p.start.position.x", "p.start.position.y", "oppo.start.position.x", "oppo.start.position.y", "p.movement.angle.1", "p.start.shot.x",  "p.start.shot.y", "p.diff.avg.shot.and.match.movement.speed",  "oppo.diff.avg.shot.and.match.movement.speed", "diff.p.avg.and.current.shot.speed",  "lag.oppo.height.off.net", "winner.return.error", "p.advantage")]




```


```{r}


#scaling variables from 0 min to 1 max for comparison to hidden states plot
fed_scale <- fed_only[, c(  "p.start.position.x", "p.start.position.y", "oppo.start.position.x", "oppo.start.position.y", "p.movement.angle.1", "p.start.shot.x",  "p.start.shot.y", "p.diff.avg.shot.and.match.movement.speed",  "oppo.diff.avg.shot.and.match.movement.speed", "diff.p.avg.and.current.shot.speed",  "lag.oppo.height.off.net", "winner.return.error", "p.advantage")]

#error in scaling as two variables not created correcctly in rallies2
fed_scale <- as.data.frame(lapply(fed_dep[c( "p.start.position.x", "p.start.position.y", "oppo.start.position.x", "oppo.start.position.y", "p.movement.angle.1", "p.start.shot.x",  "p.start.shot.y", "p.diff.avg.shot.and.match.movement.speed",  "oppo.diff.avg.shot.and.match.movement.speed", "diff.p.avg.and.current.shot.speed",  "lag.oppo.height.off.net", "winner.return.error")], function(y) (y-min(y))/(max(y)-min(y))))

#adding winner and total shot number to the df for analysis
fed_scale <- cbind(fed_scale, winner = fed_only$winner) 
fed_scale <- fed_scale %>% mutate(player.total.shot.number = row_number())


fed_scale <- fed_scale %>%
  mutate(winner.return.error = ifelse(winner.return.error == 1,3,
                                      ifelse(winner.return.error == 0.5,2,1)))

```


```{r}
#Checking correlation with more observations added
 corMat2 <- cor(fed_dep)
 corMat2_df <- as.data.frame(apply(corMat, 2, function(x) ifelse (abs(x) >=0.5,x,"NA")))

# no correlation found with chosen variables in expanded data set
```


##Data Set 2 Training Model 1 (2 states)


```{r}
# Variables fitted:
#p.start.position.x, lag.oppo.height.off.net, oppo.diff.avg.shot.and.match.movement.speed, oppo.start.position.x, diff.p.avg.and.current.shot.speed, p.movement.angle.1
 ds2.mod1.2s <- depmix(winner ~ 1, transition = ~ p.start.position.x + lag.oppo.height.off.net + oppo.diff.avg.shot.and.match.movement.speed + oppo.start.position.x + diff.p.avg.and.current.shot.speed + p.movement.angle.1, data = fed_scale, nstates = 2, family=multinomial("identity"))
 ds2.fm1.2s <- fit(ds2.mod1.2s)
 
 summary(ds2.fm1.2s)
```

###Plotting Data Set 2 Training Model 1 (2 states)
```{r}
probs = posterior(ds2.fm1.2s)

	
 	plot(probs$state, type='s', main='Implied States', xlab='', ylab='State')
	
	matplot(probs[,-1], type='l', main='Probabilities', ylab='Probability')
		legend(x='topright', c('State1','State2'),  fill=1:2, bty='n')
```


```{r}
#Plotting probability states for test model fed16/17/18
#p.start.position.x, oppo.start.position.x, oppo.diff.avg.shot.and.match.movement.speed, p.diff.avg.shot.and.match.movement.speed, lag.p.angle, oppo.rally.side.change.count, diff.lag.oppo.avg.and.current.shot.speed, diff.p.avg.and.current.shot.speed, p.movement.angle.1, lag.oppo.height.off.net, oppo.start.position.y

#Pulling state probabilities from fitted model to add to a dataframe to look for correlation with fitted variables
ds2.fm1.2s_df <- posterior(ds2.fm1.2s)

ds2.fm1.2s_df <- cbind(fed_scale, ds2.fm1.2s_df)
	
#dropping columns not in the fitted depmix model

# ds2.fm1.2s_df <- ds2.fm1.2s_df[ -c(2, 6) ]


```
```{r}
#plotting a matrix to identify any correlation between depmix probabilities and chosen variables
library(GGally)
# ggduo(ds2.fm1.2s_df, 1:3, 14, showStrips = FALSE)
# ggduo(ds2.fm1.2s_df, 4:6, 14, showStrips = FALSE)
# ggduo(ds2.fm1.2s_df, 7:9, 14, showStrips = FALSE)
# ggduo(ds2.fm1.2s, 10:11, 14, showStrips = FALSE)
```
```{r}
#showing correlation between variables and probaility of being in state 1

# cor.ds2.fm1.2s <- cor(ds2.fm1.2s_df)
# cor.ds2.fm1.2s_df <- as.data.frame(apply(cor.ds2.fm1.2s, 2, function(x) ifelse (abs(x) >=0-1,x,"NA")))
# cor.ds2.fm1.2s_df <- cor.ds2.fm1.2s_df[ -c(1:13, 15) ]


```

##Running Training Model 2 on Data set 2
##Data Set 2 Training Model 2 (2 states)
```{r}
#Training Model 2 has the best variables from stepwise run on Data Set 2
#p.movement.angle.1, oppo.diff.avg.shot.and.match.movement.speed, p.start.position.y, oppo.start.position.x, oppo.start.position.y, p.diff.avg.shot.and.match.movement.speed,  lag.oppo.height.off.net

#running this model on the scaled fed_only data set
ds2.mod2.2s <- depmix(winner ~ 1, transition = ~p.movement.angle.1 + oppo.diff.avg.shot.and.match.movement.speed + p.start.position.y + oppo.start.position.x + oppo.start.position.y + p.diff.avg.shot.and.match.movement.speed + lag.oppo.height.off.net , data = fed_scale, nstates = 2, family=multinomial("identity"))
 ds2.fm2.2s <- fit(ds2.mod2.2s)
 
 summary(ds2.fm2.2s)
```
###Plotting Probabilities Data Set 2 Training Model 2 (2 states)


```{r}
probs = posterior(ds2.fm2.2s)

	
 	plot(probs$state, type='s', main='Implied States', xlab='', ylab='State')
	
	matplot(probs[,-1], type='l', main='Probabilities', ylab='Probability')
		legend(x='topright', c('State1','State2'),  fill=1:2, bty='n')
```

```{r}
#Plotting probability states for test model 2 for fed16/17/18


#Pulling state probabilities from fitted model to add to a dataframe to look for correlation with fitted variables
#ds2.fm2.2s_df <- posterior(ds2.fm2.2s)
 
#ds2.fm2.2s_df <- cbind(fed_scale, ds2.fm2.2s_df)
	
#dropping columns not in the fitted depmix model

#ds2.fm2.2s_df <- ds2.fm2.2s_df[ -c() ]


```
```{r}
#plotting a matrix to identify any correlation between depmix probabilities and chosen variables
# library(GGally)
# ggduo(ds2.fm2.2s_df, 1:3, 13, showStrips = FALSE)
# ggduo(ds2.fm2.2s_df, 4:6, 13, showStrips = FALSE)

```

```{r}
#showing correlation between variables and probaility of being in state 1 for test model 2

# cor.ds2.fm2.2s <- cor(ds2.fm2.2s_df)
# cor.ds2.fm2.2s_df <- as.data.frame(apply(cor.ds2.fm2.2s, 2, function(x) ifelse (abs(x) >=-1,x,"NA")))
# cor.ds2.fm2.2s_df <- cor.ds2.fm2.2s[ -c() ]
```
``
###Data Set 2 Training Model 2 (3 States)

```{r}
#running this model on the scaled fed_only data set
ds2.mod2.3s <- depmix(winner.return.error ~ 1, transition = ~ p.movement.angle.1 + oppo.diff.avg.shot.and.match.movement.speed + p.start.position.y + oppo.start.position.x + oppo.start.position.y + p.diff.avg.shot.and.match.movement.speed + lag.oppo.height.off.net , data = fed_scale, nstates = 3, family=multinomial("identity"))
 ds2.fm2.3s <- fit(ds2.mod2.3s)
 
 summary(ds2.fm2.3s)
```
###Plotting Probabilities for Data Set 2 Training Model 2 (3 States)
```{r}
#plotting Data Set 2 Training Model 2 with 3 states
probs = posterior(ds2.fm2.3s)

	
	
 	plot(probs$state, type='s', main='Implied States', xlab='', ylab='State')
 	
 
	matplot(probs[,-1], type='l', main='Probabilities', ylab='Probability')
		legend(x='topright', c('State1','State2', "State3"),  fill=1:3, bty='n')
		
		
ggplot() + 
  geom_path(data=fed_scale, aes(x = player.total.shot.number, y = winner.return.error)) +
  xlab("Federer shot Number")  + 
  ylab("Actual State") + 
  ggtitle("Actual state") 

```

###Strycova
```{r}
#Joining all Strycova matches
stry_only <- rbind(stry16_only, stry17_only)

#choosing variables of interest
stry_dep <- stry_only[, c( "p.start.position.x", "p.start.position.y", "oppo.start.position.x", "oppo.start.position.y", "p.movement.angle.1", "p.start.shot.x",  "p.start.shot.y", "p.diff.avg.shot.and.match.movement.speed",  "oppo.diff.avg.shot.and.match.movement.speed", "diff.p.avg.and.current.shot.speed",  "lag.oppo.height.off.net", "winner.return.error", "p.advantage")]


```


```{r}
#scaling variables from 0 min to 1 max for comparison to hidden states plot
stry_scale <- stry_only[, c(  "p.start.position.x", "p.start.position.y", "oppo.start.position.x", "oppo.start.position.y", "p.movement.angle.1", "p.start.shot.x",  "p.start.shot.y", "p.diff.avg.shot.and.match.movement.speed",  "oppo.diff.avg.shot.and.match.movement.speed", "diff.p.avg.and.current.shot.speed",  "lag.oppo.height.off.net", "winner.return.error")]

stry_scale <- as.data.frame(lapply(stry_dep[c( "p.start.position.x", "p.start.position.y", "oppo.start.position.x", "oppo.start.position.y", "p.movement.angle.1", "p.start.shot.x", "p.start.shot.y", "p.diff.avg.shot.and.match.movement.speed",  "oppo.diff.avg.shot.and.match.movement.speed", "diff.p.avg.and.current.shot.speed",  "lag.oppo.height.off.net", "winner.return.error")], function(x) (x-min(x))/(max(x)-min(x))))
#adding winner and total shot number to the df for analysis
stry_scale <- cbind(stry_scale, winner = stry_only$winner)
stry_scale <- cbind(stry_scale, p.advantage = stry_only$p.advantage)

#Mutating player advantage to make it suitable as a response variable.Less than -2000 is a large disadvantage between -2000 and 2000 is a small advantage/disadvantage above 2000 is a large advantage
stry_scale <- stry_scale %>%
  mutate(p.advantage.states = ifelse(p.advantage <= (-2000), 1,
                                     ifelse(p.advantage >= 2000,3,1))) %>%
  mutate(winner.return.error = ifelse(winner.return.error == 1,3,
                                      ifelse(winner.return.error == 0.5,2,1)))

stry_scale <- stry_scale %>% mutate(player.total.shot.number = row_number())
```

```{r}
write.csv(stry_scale, "data/stry_scale.csv")
```

```{r}
#Creating correlation matrix for variables of interest. Variables under 50% correlation will show as NA
stry.corMat <- cor(stry_dep)
stry.corMat_df <- as.data.frame(apply(corMat, 2, function(x) ifelse (abs(x) >=0.5,x,"NA")))
#Removed some variables with significant correlation with other variables above 50%:
#p.end.position.x, p.end.position.y, oppo.end.position.x, oppo.end.position.y, p.rally.side.change.count, p.distance, oppo.distance, fhand, p.advantage, rally.distance.run.ratio, shot, p.start.shot.y
```


```{r}
#Comparing Different response variables to find the best model for three states
#Response variable(s):winner.return.error & p.advantage.states
#Combination of the two response variables produces the best three state model
ds3.mod2a.3s <- depmix(list(winner.return.error ~ 1, p.advantage.states ~ 1), transition = ~ p.movement.angle.1 + oppo.diff.avg.shot.and.match.movement.speed + p.start.position.y + oppo.start.position.x + oppo.start.position.y + p.diff.avg.shot.and.match.movement.speed + lag.oppo.height.off.net , data = stry_scale, nstates = 3, family=list(multinomial("identity"),multinomial("identity")))
 ds3.fm2a.3s <- fit(ds3.mod2a.3s)

 summary(ds3.fm2a.3s)
```

```{r}
#Comparing Different response variables to find the best model for three states
#Response variable(s):p.advantage.states
ds3.mod2b.3s <- depmix(p.advantage.states ~ 1, transition = ~ p.movement.angle.1 + oppo.diff.avg.shot.and.match.movement.speed + p.start.position.y + oppo.start.position.x + oppo.start.position.y + p.diff.avg.shot.and.match.movement.speed + lag.oppo.height.off.net , data = stry_scale, nstates = 3, family=multinomial("identity"))
 ds3.fm2b.3s <- fit(ds3.mod2b.3s)

 summary(ds3.fm2b.3s)
```


```{r}
#Commented out because of issue with crashing
#Comparing Different response variables to find the best model for three states
#Response variable(s):winner.return.error & p.advantage.states
#Produces three states but the model sometimes crashes
ds3.mod2c.3s <- depmix(winner.return.error ~ 1, transition = ~ p.movement.angle.1 + oppo.diff.avg.shot.and.match.movement.speed + p.start.position.y + oppo.start.position.x + oppo.start.position.y + p.diff.avg.shot.and.match.movement.speed + lag.oppo.height.off.net , data = stry_scale, nstates = 3, family=multinomial("identity"))
 ds3.fm2c.3s <- fit(ds3.mod2c.3s)

 summary(ds3.fm2c.3s)
```




```{r}
#plotting Data Set 2 Training Model 2 with 3 states
probs = posterior(ds3.fm2a.3s)



 	plot(probs$state, type='s', main='Implied States', xlab='', ylab='State')


	matplot(probs[,-1], type='l', main='Probabilities', ylab='Probability')
		legend(x='topright', c('State1','State2', "State3"),  fill=1:3, bty='n')
```

```{r}


ds3.mod3.3s <- depmix(list(winner.return.error ~ 1, p.advantage.states ~ 1), transition = ~ oppo.diff.avg.shot.and.match.movement.speed + p.start.position.y + p.start.position.x + lag.oppo.height.off.net + p.diff.avg.shot.and.match.movement.speed , data = stry_scale, nstates = 3, family=list(multinomial("identity"),multinomial("identity")))
 ds3.fm3.3s <- fit(ds3.mod3.3s)
 
 summary(ds3.fm3.3s)
```

##Stepwise Analysis
All Chunks for Step-wise have been Commented to running time/size of the file for Knit.
Including the code to show the process. (Comment/Uncomment is Ctrl+Shift+C)
###Stepwise to find best variables for Depmix for Federer vs Berdych 2016 (Data Set 1, Training Model 1)


<!-- ```{r} -->
<!-- ##Stepwise for first best variable -->
<!-- #run through all variables to find highest log lik -->
<!-- fcov1 <- lapply(fed16_scale[c( "p.start.position.x", "p.start.position.y", "oppo.start.position.x", "oppo.start.position.y", "p.movement.angle.1", "p.diff.avg.shot.and.match.movement.speed",  "oppo.diff.avg.shot.and.match.movement.speed", "diff.p.avg.and.current.shot.speed",  "lag.oppo.height.off.net")], function(w) fit((depmix(winner ~ 1, data = fed16_scale, transition = ~ w, nstates = 2, family=multinomial("identity"))), verbose = FALSE, emc=em.control(rand=TRUE))) -->


<!-- #Pulling covergence log likelihoods into a dataframe -->
<!-- fcov1_df <-  as.data.frame( -->
<!--   c(logLik(fcov1$p.start.position.x), logLik(fcov1$p.start.position.y), -->
<!--     logLik(fcov1$oppo.start.position.x), logLik(fcov1$oppo.start.position.y), -->
<!--     logLik(fcov1$p.movement.angle.1), -->
<!--     logLik(fcov1$p.diff.avg.shot.and.match.movement.speed), -->
<!--     logLik(fcov1$oppo.diff.avg.shot.and.match.movement.speed), -->
<!--     logLik(fcov1$diff.p.avg.and.current.shot.speed), -->
<!--     logLik(fcov1$lag.oppo.height.off.net) -->
<!--     ) -->
<!--   ) -->

<!-- fcov1_df$newcolumn<-c( "p.start.position.x", "p.start.position.y", "oppo.start.position.x", "oppo.start.position.y", "p.movement.angle.1", "p.diff.avg.shot.and.match.movement.speed",  "oppo.diff.avg.shot.and.match.movement.speed", "diff.p.avg.and.current.shot.speed",  "lag.oppo.height.off.net") -->

<!-- names(fcov1_df) <- c("convergence.loglik", "Variables") -->

<!-- #print variable with the highest convergence log likelihood -->
<!-- fcov1_df %>% -->
<!--    slice(which.max(convergence.loglik)) -->

<!-- ``` -->





<!-- ```{r} -->
<!-- ###First best variable is p.start.position.x -->
<!-- #Running single variable model of p.start.position.x to look at coefficients -->

<!-- mod1 <- depmix(winner ~ 1, transition = ~ p.start.position.x, data = fed16_scale, nstates = 2, family=multinomial("identity")) -->
<!-- fm1 <- fit(mod1) -->

<!-- summary(fm1) -->


<!-- ``` -->



<!-- ```{r} -->
<!-- #Graphing fitted model states for first best variable -->

<!-- probs = posterior(fm1) -->


<!-- 	plot(probs$state, type='s', main='Implied States', xlab='', ylab='State') -->

<!-- 	matplot(probs[,-1], type='l', main='Probabilities', ylab='Probability') -->
<!-- 		legend(x='topright', c('State1','State2'),  fill=1:2, bty='n') -->
<!-- ``` -->




<!-- ```{r} -->
<!-- ##Stepwise to find second best variable -->
<!-- #run through all variables to find highest log lik -->
<!-- fcov2 <- lapply(fed16_scale[c( "p.start.position.y", "oppo.start.position.x", "oppo.start.position.y", "p.movement.angle.1",  "oppo.diff.avg.shot.and.match.movement.speed", "diff.p.avg.and.current.shot.speed",  "lag.oppo.height.off.net")], function(w) fit((depmix(winner ~ 1, data = fed16_scale, transition = ~ p.start.position.x + w, nstates = 2, family=multinomial("identity"))), verbose = FALSE, emc=em.control(rand=TRUE))) -->


<!-- #Pulling covergence log likelihoods into a dataframe -->
<!-- fcov2_df <-  as.data.frame( -->
<!--   c(logLik(fcov2$p.start.position.y), -->
<!--     logLik(fcov2$oppo.start.position.x), logLik(fcov2$oppo.start.position.y), -->
<!--     logLik(fcov2$p.movement.angle.1), -->
<!--     logLik(fcov2$oppo.diff.avg.shot.and.match.movement.speed), -->
<!--     logLik(fcov2$diff.p.avg.and.current.shot.speed), -->
<!--     logLik(fcov2$lag.oppo.height.off.net) -->
<!--     ) -->
<!--   ) -->

<!-- fcov2_df$newcolumn<-c( "p.start.position.y", "oppo.start.position.x", "oppo.start.position.y", "p.movement.angle.1",  "oppo.diff.avg.shot.and.match.movement.speed", "diff.p.avg.and.current.shot.speed",  "lag.oppo.height.off.net") -->

<!-- names(fcov2_df) <- c("convergence.loglik", "Variables") -->

<!-- #print variable with the highest convergence log likelihood -->
<!-- fcov2_df %>% -->
<!--    slice(which.max(convergence.loglik)) -->

<!-- ``` -->


<!-- ```{r} -->
<!-- ##Stepwise to find the third best variable -->
<!-- #second best variable is lag.oppo.height.off.net -->
<!-- #run through all variables to find highest log lik -->
<!-- fcov3 <- lapply(fed16_scale[c("p.start.position.y", "oppo.start.position.x", "oppo.start.position.y", "p.movement.angle.1",  "oppo.diff.avg.shot.and.match.movement.speed", "diff.p.avg.and.current.shot.speed")], function(w) fit((depmix(winner ~ 1, data = fed16_scale, transition = ~ p.start.position.x + lag.oppo.height.off.net + w, nstates = 2, family=multinomial("identity"))), verbose = FALSE, emc=em.control(rand=TRUE))) -->


<!-- #Pulling covergence log likelihoods into a dataframe -->
<!-- fcov3_df <-  as.data.frame( -->
<!--   c(logLik(fcov3$p.start.position.y), -->
<!--     logLik(fcov3$oppo.start.position.x), logLik(fcov3$oppo.start.position.y), -->
<!--     logLik(fcov3$p.movement.angle.1), -->
<!--     logLik(fcov3$oppo.diff.avg.shot.and.match.movement.speed), -->
<!--     logLik(fcov3$diff.p.avg.and.current.shot.speed)  ) -->
<!--   ) -->

<!-- fcov3_df$newcolumn<-c("p.start.position.y", "oppo.start.position.x", "oppo.start.position.y", "p.movement.angle.1",  "oppo.diff.avg.shot.and.match.movement.speed", "diff.p.avg.and.current.shot.speed") -->

<!-- names(fcov3_df) <- c("convergence.loglik", "Variables") -->

<!-- #print variable with the highest convergence log likelihood -->
<!-- fcov3_df %>% -->
<!--    slice(which.max(convergence.loglik)) -->
<!-- ``` -->


<!-- ```{r} -->
<!-- ##Stepwise to find the fourth best variable -->
<!-- library(depmixS4) -->
<!-- #third best variable is oppo.diff.avg.shot.and.match.movement.speed -->


<!-- #run through all variables to find highest log lik -->
<!-- fcov4 <- lapply(fed16_scale[c("p.start.position.y", "oppo.start.position.x", "oppo.start.position.y", "p.movement.angle.1", "diff.p.avg.and.current.shot.speed")], function(w) fit((depmix(winner ~ 1, data = fed16_scale, transition = ~ p.start.position.x + lag.oppo.height.off.net + oppo.diff.avg.shot.and.match.movement.speed + w, nstates = 2, family=multinomial("identity"))), verbose = FALSE, emc=em.control(rand=TRUE))) -->


<!-- #Pulling covergence log likelihoods into a dataframe -->
<!-- fcov4_df <-  as.data.frame( -->
<!--   c(logLik(fcov4$p.start.position.y), -->
<!--     logLik(fcov4$oppo.start.position.x), logLik(fcov4$oppo.start.position.y), -->
<!--     logLik(fcov4$p.movement.angle.1), -->
<!--     logLik(fcov4$diff.p.avg.and.current.shot.speed)  ) -->
<!--   ) -->

<!-- fcov4_df$newcolumn<-c("p.start.position.y", "oppo.start.position.x", "oppo.start.position.y", "p.movement.angle.1", "diff.p.avg.and.current.shot.speed") -->

<!-- names(fcov4_df) <- c("convergence.loglik", "Variables") -->

<!-- #print variable with the highest convergence log likelihood -->
<!-- fcov4_df %>% -->
<!--    slice(which.max(convergence.loglik)) -->
<!-- ``` -->





<!-- ```{r} -->
<!-- ##Stepwise to find fifth best variable -->
<!-- #Fourth best variable is oppo.start.position.x -->


<!-- #run through all variables to find highest log lik -->
<!-- fcov5 <- lapply(fed16_scale[c( "p.start.position.y", "oppo.start.position.y",  "p.movement.angle.1", "diff.p.avg.and.current.shot.speed")], function(w) fit((depmix(winner ~ 1, data = fed16_scale, transition = ~ p.start.position.x + lag.oppo.height.off.net + oppo.diff.avg.shot.and.match.movement.speed + oppo.start.position.x + w, nstates = 2, family=multinomial("identity"))), verbose = FALSE, emc=em.control(rand=TRUE))) -->


<!-- #Pulling covergence log likelihoods into a dataframe -->
<!-- fcov5_df <-  as.data.frame( -->
<!--   c(logLik(fcov5$p.start.position.y), logLik(fcov5$oppo.start.position.y), -->
<!--     logLik(fcov5$p.movement.angle.1), -->
<!--     logLik(fcov5$diff.p.avg.and.current.shot.speed)  ) -->
<!--   ) -->

<!-- fcov5_df$newcolumn<-c("p.start.position.y", "oppo.start.position.y", "p.movement.angle.1", "diff.p.avg.and.current.shot.speed") -->

<!-- names(fcov5_df) <- c("convergence.loglik", "Variables") -->

<!-- #print variable with the highest convergence log likelihood -->
<!-- fcov5_df %>% -->
<!--    slice(which.max(convergence.loglik)) -->
<!-- ``` -->

<!-- ```{r} -->
<!-- ##Stepwise to find sixth best variable -->
<!-- #fifth best variable is diff.p.avg.and.current.shot.speed -->
<!-- #run through all variables to find highest log lik -->
<!-- fcov6 <- lapply(fed16_scale[c( "p.start.position.y", "oppo.start.position.y",  "p.movement.angle.1")], function(w) fit((depmix(winner ~ 1, data = fed16_scale, transition = ~ p.start.position.x + lag.oppo.height.off.net + oppo.diff.avg.shot.and.match.movement.speed + oppo.start.position.x + diff.p.avg.and.current.shot.speed + w, nstates = 2, family=multinomial("identity"))), verbose = FALSE, emc=em.control(rand=TRUE))) -->


<!-- #Pulling covergence log likelihoods into a dataframe -->
<!-- fcov6_df <-  as.data.frame( -->
<!--   c(logLik(fcov6$p.start.position.y), logLik(fcov6$oppo.start.position.y), -->
<!--     logLik(fcov6$p.movement.angle.1)  ) -->
<!--   ) -->

<!-- fcov6_df$newcolumn<-c("p.start.position.y", "oppo.start.position.y", "p.movement.angle.1") -->

<!-- names(fcov6_df) <- c("convergence.loglik", "Variables") -->

<!-- #print variable with the highest convergence log likelihood -->
<!-- fcov6_df %>% -->
<!--    slice(which.max(convergence.loglik)) -->

<!-- #Model stops improving last variable added to the model is p.movement.angle.1 -->
<!-- ``` -->

###Running stepwise for Federer vs Berdych 2016/17/18 (Data Set 2 Training Model 2)

<!-- ```{r} -->
<!-- #run through all variables to find highest log lik -->
<!-- #tm2.fcov1 is training model 2 fitted covariates 1 -->
<!-- tm2.fcov1 <- lapply(fed_scale[c( "p.start.position.x", "p.start.position.y", "oppo.start.position.x", "oppo.start.position.y", "p.movement.angle.1", "p.diff.avg.shot.and.match.movement.speed",  "oppo.diff.avg.shot.and.match.movement.speed", "diff.p.avg.and.current.shot.speed",  "lag.oppo.height.off.net")], function(w) fit((depmix(winner ~ 1, data = fed_scale, transition = ~ w, nstates = 2, family=multinomial("identity"))), verbose = FALSE, emc=em.control(rand=TRUE))) -->


<!-- #Pulling covergence log likelihoods into a dataframe -->
<!-- tm2.fcov1_df <-  as.data.frame( -->
<!--   c(logLik(tm2.fcov1$p.start.position.x), logLik(tm2.fcov1$p.start.position.y), -->
<!--     logLik(tm2.fcov1$oppo.start.position.x), logLik(tm2.fcov1$oppo.start.position.y), -->
<!--     logLik(tm2.fcov1$p.movement.angle.1), -->
<!--     logLik(tm2.fcov1$p.diff.avg.shot.and.match.movement.speed), -->
<!--     logLik(tm2.fcov1$oppo.diff.avg.shot.and.match.movement.speed), -->
<!--     logLik(tm2.fcov1$diff.p.avg.and.current.shot.speed), -->
<!--     logLik(tm2.fcov1$lag.oppo.height.off.net)  ) -->
<!--   ) -->

<!-- tm2.fcov1_df$newcolumn<-c( "p.start.position.x", "p.start.position.y", "oppo.start.position.x", "oppo.start.position.y", "p.movement.angle.1", "p.diff.avg.shot.and.match.movement.speed",  "oppo.diff.avg.shot.and.match.movement.speed", "diff.p.avg.and.current.shot.speed",  "lag.oppo.height.off.net") -->

<!-- names(tm2.fcov1_df) <- c("convergence.loglik", "Variables") -->

<!-- #print variable with the highest convergence log likelihood -->
<!-- tm2.fcov1_df %>%  -->
<!--    slice(which.max(convergence.loglik)) -->
<!-- ``` -->
<!-- ```{r} -->
<!-- #first best variable p.movement.angle.1 -->

<!-- #run through all variables to find highest log lik -->
<!-- tm2.fcov2 <- lapply(fed_scale[c( "p.start.position.x", "p.start.position.y", "oppo.start.position.x", "oppo.start.position.y", "p.diff.avg.shot.and.match.movement.speed",  "oppo.diff.avg.shot.and.match.movement.speed", "diff.p.avg.and.current.shot.speed",  "lag.oppo.height.off.net")], function(w) fit((depmix(winner ~ 1, data = fed_scale, transition = ~ p.movement.angle.1 + w, nstates = 2, family=multinomial("identity"))), verbose = FALSE, emc=em.control(rand=TRUE))) -->


<!-- #Pulling covergence log likelihoods into a dataframe -->
<!-- tm2.fcov2_df <-  as.data.frame( -->
<!--   c(logLik(tm2.fcov2$p.start.position.x), logLik(tm2.fcov2$p.start.position.y), -->
<!--     logLik(tm2.fcov2$oppo.start.position.x), logLik(tm2.fcov2$oppo.start.position.y), -->
<!--     logLik(tm2.fcov2$p.diff.avg.shot.and.match.movement.speed), -->
<!--     logLik(tm2.fcov2$oppo.diff.avg.shot.and.match.movement.speed), -->
<!--     logLik(tm2.fcov2$diff.p.avg.and.current.shot.speed), -->
<!--     logLik(tm2.fcov2$lag.oppo.height.off.net)  ) -->
<!--   ) -->

<!-- tm2.fcov2_df$newcolumn<-c( "p.start.position.x", "p.start.position.y", "oppo.start.position.x", "oppo.start.position.y", "p.diff.avg.shot.and.match.movement.speed",  "oppo.diff.avg.shot.and.match.movement.speed", "diff.p.avg.and.current.shot.speed",  "lag.oppo.height.off.net") -->

<!-- names(tm2.fcov2_df) <- c("convergence.loglik", "Variables") -->

<!-- #print variable with the highest convergence log likelihood -->
<!-- tm2.fcov2_df %>%  -->
<!--    slice(which.max(convergence.loglik)) -->
<!-- ``` -->
<!-- ```{r} -->
<!-- #second best variable is oppo.diff.avg.shot.and.match.movement.speed -->

<!-- #run through all variables to find highest log lik -->
<!-- tm2.fcov3 <- lapply(fed_scale[c( "p.start.position.x", "p.start.position.y", "oppo.start.position.x", "oppo.start.position.y", "p.diff.avg.shot.and.match.movement.speed", "diff.p.avg.and.current.shot.speed",  "lag.oppo.height.off.net")], function(w) fit((depmix(winner ~ 1, data = fed_scale, transition = ~ p.movement.angle.1 + oppo.diff.avg.shot.and.match.movement.speed + w, nstates = 2, family=multinomial("identity"))), verbose = FALSE, emc=em.control(rand=TRUE))) -->


<!-- #Pulling covergence log likelihoods into a dataframe -->
<!-- tm2.fcov3_df <-  as.data.frame( -->
<!--   c(logLik(tm2.fcov3$p.start.position.x), logLik(tm2.fcov3$p.start.position.y), -->
<!--     logLik(tm2.fcov3$oppo.start.position.x), logLik(tm2.fcov3$oppo.start.position.y), -->
<!--     logLik(tm2.fcov3$p.diff.avg.shot.and.match.movement.speed), -->
<!--     logLik(tm2.fcov3$diff.p.avg.and.current.shot.speed), -->
<!--     logLik(tm2.fcov3$lag.oppo.height.off.net)  ) -->
<!--   ) -->

<!-- tm2.fcov3_df$newcolumn<-c( "p.start.position.x", "p.start.position.y", "oppo.start.position.x", "oppo.start.position.y", "p.diff.avg.shot.and.match.movement.speed", "diff.p.avg.and.current.shot.speed",  "lag.oppo.height.off.net") -->

<!-- names(tm2.fcov3_df) <- c("convergence.loglik", "Variables") -->

<!-- #print variable with the highest convergence log likelihood -->
<!-- tm2.fcov3_df %>%  -->
<!--    slice(which.max(convergence.loglik)) -->
<!-- ``` -->
<!-- ```{r} -->
<!-- #third best variable is p.start.position.y -->
<!-- #run through all variables to find highest log lik -->
<!-- tm2.fcov4 <- lapply(fed_scale[c( "p.start.position.x", "oppo.start.position.x", "oppo.start.position.y", "p.diff.avg.shot.and.match.movement.speed", "diff.p.avg.and.current.shot.speed",  "lag.oppo.height.off.net")], function(w) fit((depmix(winner ~ 1, data = fed_scale, transition = ~ p.movement.angle.1 + oppo.diff.avg.shot.and.match.movement.speed + p.start.position.y + w, nstates = 2, family=multinomial("identity"))), verbose = FALSE, emc=em.control(rand=TRUE))) -->


<!-- #Pulling covergence log likelihoods into a dataframe -->
<!-- tm2.fcov4_df <-  as.data.frame( -->
<!--   c(logLik(tm2.fcov4$p.start.position.x), -->
<!--     logLik(tm2.fcov4$oppo.start.position.x), logLik(tm2.fcov4$oppo.start.position.y), -->
<!--     logLik(tm2.fcov4$p.diff.avg.shot.and.match.movement.speed), -->
<!--     logLik(tm2.fcov4$diff.p.avg.and.current.shot.speed), -->
<!--     logLik(tm2.fcov4$lag.oppo.height.off.net)  ) -->
<!--   ) -->

<!-- tm2.fcov4_df$newcolumn<-c( "p.start.position.x", "oppo.start.position.x", "oppo.start.position.y", "p.diff.avg.shot.and.match.movement.speed", "diff.p.avg.and.current.shot.speed",  "lag.oppo.height.off.net") -->

<!-- names(tm2.fcov4_df) <- c("convergence.loglik", "Variables") -->

<!-- #print variable with the highest convergence log likelihood -->
<!-- tm2.fcov4_df %>%  -->
<!--    slice(which.max(convergence.loglik)) -->
<!-- ``` -->
<!-- ```{r} -->
<!-- #fourth best variable is oppo.start.position.x -->
<!-- #run through all variables to find highest log lik -->
<!-- tm2.fcov5 <- lapply(fed_scale[c( "p.start.position.x", "oppo.start.position.x", "oppo.start.position.y", "p.diff.avg.shot.and.match.movement.speed", "diff.p.avg.and.current.shot.speed",  "lag.oppo.height.off.net")], function(w) fit((depmix(winner ~ 1, data = fed_scale, transition = ~ p.movement.angle.1 + oppo.diff.avg.shot.and.match.movement.speed + p.start.position.y + oppo.start.position.x + w, nstates = 2, family=multinomial("identity"))), verbose = FALSE, emc=em.control(rand=TRUE))) -->


<!-- #Pulling covergence log likelihoods into a dataframe -->
<!-- tm2.fcov5_df <-  as.data.frame( -->
<!--   c(logLik(tm2.fcov5$p.start.position.x), logLik(tm2.fcov5$oppo.start.position.y), -->
<!--     logLik(tm2.fcov5$p.diff.avg.shot.and.match.movement.speed), -->
<!--     logLik(tm2.fcov5$diff.p.avg.and.current.shot.speed), -->
<!--     logLik(tm2.fcov5$lag.oppo.height.off.net)  ) -->
<!--   ) -->

<!-- tm2.fcov5_df$newcolumn<-c( "p.start.position.x", "oppo.start.position.y", "p.diff.avg.shot.and.match.movement.speed", "diff.p.avg.and.current.shot.speed",  "lag.oppo.height.off.net") -->

<!-- names(tm2.fcov5_df) <- c("convergence.loglik", "Variables") -->

<!-- #print variable with the highest convergence log likelihood -->
<!-- tm2.fcov5_df %>%  -->
<!--    slice(which.max(convergence.loglik)) -->

<!-- #model stops improving at this point -->
<!-- ``` -->
<!-- ```{r} -->
<!-- #5th best variable alternates between oppo.start.position.y and p.diff.avg.shot.and.match.movement.speed. Adding both. -->
<!-- #run through all variables to find highest log lik -->
<!-- tm2.fcov6 <- lapply(fed_scale[c( "p.start.position.x", "oppo.start.position.x", "diff.p.avg.and.current.shot.speed",  "lag.oppo.height.off.net")], function(w) fit((depmix(winner ~ 1, data = fed_scale, transition = ~ p.movement.angle.1 + oppo.diff.avg.shot.and.match.movement.speed + p.start.position.y + oppo.start.position.x + oppo.start.position.y + p.diff.avg.shot.and.match.movement.speed + w, nstates = 2, family=multinomial("identity"))), verbose = FALSE, emc=em.control(rand=TRUE))) -->


<!-- #Pulling covergence log likelihoods into a dataframe -->
<!-- tm2.fcov6_df <-  as.data.frame( -->
<!--   c(logLik(tm2.fcov6$p.start.position.x), -->
<!--     logLik(tm2.fcov6$diff.p.avg.and.current.shot.speed), -->
<!--     logLik(tm2.fcov6$lag.oppo.height.off.net)  ) -->
<!--   ) -->

<!-- tm2.fcov6_df$newcolumn<-c( "p.start.position.x", "diff.p.avg.and.current.shot.speed",  "lag.oppo.height.off.net") -->

<!-- names(tm2.fcov6_df) <- c("convergence.loglik", "Variables") -->

<!-- #print variable with the highest convergence log likelihood -->
<!-- tm2.fcov6_df %>%  -->
<!--    slice(which.max(convergence.loglik)) -->
<!-- #The model stops improving after this point. Last variable added to the model is lag.oppo.height.off.net -->

<!-- ``` -->


####Running Stepwise for Data Set 3 (Strycova vs Garcia 2016/2017)

<!-- ```{r} -->
<!-- #Looking for first best variable -->
<!-- tm3.fcov1 <- lapply(stry_scale[c( "p.start.position.x", "p.start.position.y", "oppo.start.position.x", "oppo.start.position.y", "p.diff.avg.shot.and.match.movement.speed",  "oppo.diff.avg.shot.and.match.movement.speed", "diff.p.avg.and.current.shot.speed",  "lag.oppo.height.off.net")], function(w) fit((depmix(list(winner.return.error ~ 1, p.advantage.states ~ 1), data = stry_scale, transition = ~ w, nstates = 2, family=list(multinomial("identity"), multinomial("identity")))), verbose = FALSE, emc=em.control(rand=TRUE))) -->


<!-- #Pulling covergence log likelihoods into a dataframe -->
<!-- tm3.fcov1_df <-  as.data.frame( -->
<!--   c(logLik(tm3.fcov1$p.start.position.x), logLik(tm3.fcov1$p.start.position.y), -->
<!--     logLik(tm3.fcov1$oppo.start.position.x), logLik(tm3.fcov1$oppo.start.position.y), -->
<!--     logLik(tm3.fcov1$p.diff.avg.shot.and.match.movement.speed), -->
<!--     logLik(tm3.fcov1$oppo.diff.avg.shot.and.match.movement.speed), -->
<!--     logLik(tm3.fcov1$diff.p.avg.and.current.shot.speed), -->
<!--     logLik(tm3.fcov1$lag.oppo.height.off.net)  ) -->
<!--   ) -->

<!-- tm3.fcov1_df$newcolumn<-c( "p.start.position.x", "p.start.position.y", "oppo.start.position.x", "oppo.start.position.y",  "p.diff.avg.shot.and.match.movement.speed",  "oppo.diff.avg.shot.and.match.movement.speed", "diff.p.avg.and.current.shot.speed",  "lag.oppo.height.off.net") -->

<!-- names(tm3.fcov1_df) <- c("convergence.loglik", "Variables") -->

<!-- #print variable with the highest convergence log likelihood -->
<!-- tm3.fcov1_df %>%  -->
<!--    slice(which.max(convergence.loglik)) -->
<!-- ``` -->

<!-- ```{r} -->
<!-- #First best variable is oppo.diff.avg.shot.and.match.movement.speed -->
<!-- tm3.fcov2 <- lapply(stry_scale[c( "p.start.position.x", "p.start.position.y", "oppo.start.position.x", "oppo.start.position.y", "p.diff.avg.shot.and.match.movement.speed", "diff.p.avg.and.current.shot.speed",  "lag.oppo.height.off.net")], function(w) fit((depmix(list(winner.return.error ~ 1, p.advantage.states ~ 1), data = stry_scale, transition = ~  oppo.diff.avg.shot.and.match.movement.speed + w, nstates = 2, family=list(multinomial("identity"), multinomial("identity")))), verbose = FALSE, emc=em.control(rand=TRUE))) -->


<!-- #Pulling covergence log likelihoods into a dataframe -->
<!-- tm3.fcov2_df <-  as.data.frame( -->
<!--   c(logLik(tm3.fcov2$p.start.position.x), logLik(tm3.fcov2$p.start.position.y), -->
<!--     logLik(tm3.fcov2$oppo.start.position.x), logLik(tm3.fcov2$oppo.start.position.y), -->
<!--     logLik(tm3.fcov2$p.diff.avg.shot.and.match.movement.speed), -->
<!--     logLik(tm3.fcov2$diff.p.avg.and.current.shot.speed), -->
<!--     logLik(tm3.fcov2$lag.oppo.height.off.net)  ) -->
<!--   ) -->

<!-- tm3.fcov2_df$newcolumn<-c( "p.start.position.x", "p.start.position.y", "oppo.start.position.x", "oppo.start.position.y",  "p.diff.avg.shot.and.match.movement.speed", "diff.p.avg.and.current.shot.speed",  "lag.oppo.height.off.net") -->

<!-- names(tm3.fcov2_df) <- c("convergence.loglik", "Variables") -->

<!-- #print variable with the highest convergence log likelihood -->
<!-- tm3.fcov2_df %>%  -->
<!--    slice(which.max(convergence.loglik)) -->
<!-- ``` -->
<!-- ```{r} -->
<!-- #Second Best variable is p.start.position.y -->
<!-- tm3.fcov3 <- lapply(stry_scale[c( "p.start.position.x", "oppo.start.position.x", "oppo.start.position.y", "p.diff.avg.shot.and.match.movement.speed", "diff.p.avg.and.current.shot.speed",  "lag.oppo.height.off.net")], function(w) fit((depmix(list(winner.return.error ~ 1, p.advantage.states ~ 1), data = stry_scale, transition = ~  oppo.diff.avg.shot.and.match.movement.speed + p.start.position.y + w, nstates = 2, family=list(multinomial("identity"), multinomial("identity")))), verbose = FALSE, emc=em.control(rand=TRUE))) -->


<!-- #Pulling covergence log likelihoods into a dataframe -->
<!-- tm3.fcov3_df <-  as.data.frame( -->
<!--   c(logLik(tm3.fcov3$p.start.position.x), -->
<!--     logLik(tm3.fcov3$oppo.start.position.x), logLik(tm3.fcov3$oppo.start.position.y), -->
<!--     logLik(tm3.fcov3$p.diff.avg.shot.and.match.movement.speed), -->
<!--     logLik(tm3.fcov3$diff.p.avg.and.current.shot.speed), -->
<!--     logLik(tm3.fcov3$lag.oppo.height.off.net)  ) -->
<!--   ) -->

<!-- tm3.fcov3_df$newcolumn<-c( "p.start.position.x", "oppo.start.position.x", "oppo.start.position.y",  "p.diff.avg.shot.and.match.movement.speed", "diff.p.avg.and.current.shot.speed",  "lag.oppo.height.off.net") -->

<!-- names(tm3.fcov3_df) <- c("convergence.loglik", "Variables") -->

<!-- #print variable with the highest convergence log likelihood -->
<!-- tm3.fcov3_df %>%  -->
<!--    slice(which.max(convergence.loglik)) -->
<!-- ``` -->
<!-- ```{r} -->
<!-- #third best variable is p.start.posotion.x -->
<!-- tm3.fcov4 <- lapply(stry_scale[c( "oppo.start.position.x", "oppo.start.position.y", "p.diff.avg.shot.and.match.movement.speed", "diff.p.avg.and.current.shot.speed",  "lag.oppo.height.off.net")], function(w) fit((depmix(list(winner.return.error ~ 1, p.advantage.states ~ 1), data = stry_scale, transition = ~  oppo.diff.avg.shot.and.match.movement.speed + p.start.position.y + p.start.position.x + w, nstates = 2, family=list(multinomial("identity"), multinomial("identity")))), verbose = FALSE, emc=em.control(rand=TRUE))) -->


<!-- #Pulling covergence log likelihoods into a dataframe -->
<!-- tm3.fcov4_df <-  as.data.frame( -->
<!--   c(logLik(tm3.fcov4$oppo.start.position.x), logLik(tm3.fcov4$oppo.start.position.y), -->
<!--     logLik(tm3.fcov4$p.diff.avg.shot.and.match.movement.speed), -->
<!--     logLik(tm3.fcov4$diff.p.avg.and.current.shot.speed), -->
<!--     logLik(tm3.fcov4$lag.oppo.height.off.net)  ) -->
<!--   ) -->

<!-- tm3.fcov4_df$newcolumn<-c("oppo.start.position.x", "oppo.start.position.y",  "p.diff.avg.shot.and.match.movement.speed", "diff.p.avg.and.current.shot.speed",  "lag.oppo.height.off.net") -->

<!-- names(tm3.fcov4_df) <- c("convergence.loglik", "Variables") -->

<!-- #print variable with the highest convergence log likelihood -->
<!-- tm3.fcov4_df %>%  -->
<!--    slice(which.max(convergence.loglik)) -->
<!-- ``` -->
<!-- ```{r} -->
<!-- #fourth best variable is lag.oppo.height.off.net -->
<!-- tm3.fcov5 <- lapply(stry_scale[c( "oppo.start.position.x", "oppo.start.position.y", "p.diff.avg.shot.and.match.movement.speed", "diff.p.avg.and.current.shot.speed")], function(w) fit((depmix(list(winner.return.error ~ 1, p.advantage.states ~ 1), data = stry_scale, transition = ~  oppo.diff.avg.shot.and.match.movement.speed + p.start.position.y + p.start.position.x + lag.oppo.height.off.net + w, nstates = 2, family=list(multinomial("identity"), multinomial("identity")))), verbose = FALSE, emc=em.control(rand=TRUE))) -->


<!-- #Pulling covergence log likelihoods into a dataframe -->
<!-- tm3.fcov5_df <-  as.data.frame( -->
<!--   c(logLik(tm3.fcov5$oppo.start.position.x), logLik(tm3.fcov5$oppo.start.position.y), -->
<!--     logLik(tm3.fcov5$p.diff.avg.shot.and.match.movement.speed), -->
<!--     logLik(tm3.fcov5$diff.p.avg.and.current.shot.speed)  ) -->
<!--   ) -->

<!-- tm3.fcov5_df$newcolumn<-c("oppo.start.position.x", "oppo.start.position.y",  "p.diff.avg.shot.and.match.movement.speed", "diff.p.avg.and.current.shot.speed") -->

<!-- names(tm3.fcov5_df) <- c("convergence.loglik", "Variables") -->

<!-- #print variable with the highest convergence log likelihood -->
<!-- tm3.fcov5_df %>%  -->
<!--    slice(which.max(convergence.loglik)) -->
<!-- ``` -->
<!-- ```{r} -->
<!-- #fifth best varaible is oppo.start.position.y -->
<!-- tm3.fcov6 <- lapply(stry_scale[c( "oppo.start.position.x", "p.diff.avg.shot.and.match.movement.speed", "diff.p.avg.and.current.shot.speed")], function(w) fit((depmix(list(winner.return.error ~ 1, p.advantage.states ~ 1), data = stry_scale, transition = ~  oppo.diff.avg.shot.and.match.movement.speed + p.start.position.y + p.start.position.x + lag.oppo.height.off.net + w, nstates = 2, family=list(multinomial("identity"), multinomial("identity")))), verbose = FALSE, emc=em.control(rand=TRUE))) -->


<!-- #Pulling covergence log likelihoods into a dataframe -->
<!-- tm3.fcov6_df <-  as.data.frame( -->
<!--   c(logLik(tm3.fcov6$oppo.start.position.x), -->
<!--     logLik(tm3.fcov6$p.diff.avg.shot.and.match.movement.speed), -->
<!--     logLik(tm3.fcov6$diff.p.avg.and.current.shot.speed)  ) -->
<!--   ) -->

<!-- tm3.fcov6_df$newcolumn<-c("oppo.start.position.x", "p.diff.avg.shot.and.match.movement.speed", "diff.p.avg.and.current.shot.speed") -->

<!-- names(tm3.fcov6_df) <- c("convergence.loglik", "Variables") -->

<!-- #print variable with the highest convergence log likelihood -->
<!-- tm3.fcov6_df %>%  -->
<!--    slice(which.max(convergence.loglik)) -->
<!-- ``` -->
<!-- ```{r} -->
<!-- #sixth best variable is p.diff.avg.shot.and.match.movement.speed -->
<!-- tm3.fcov7 <- lapply(stry_scale[c( "oppo.start.position.x", "diff.p.avg.and.current.shot.speed")], function(w) fit((depmix(list(winner.return.error ~ 1, p.advantage.states ~ 1), data = stry_scale, transition = ~  oppo.diff.avg.shot.and.match.movement.speed + p.start.position.y + p.start.position.x + lag.oppo.height.off.net + p.diff.avg.shot.and.match.movement.speed + w, nstates = 2, family=list(multinomial("identity"), multinomial("identity")))), verbose = FALSE, emc=em.control(rand=TRUE))) -->


<!-- #Pulling covergence log likelihoods into a dataframe -->
<!-- tm3.fcov7_df <-  as.data.frame( -->
<!--   c(logLik(tm3.fcov7$oppo.start.position.x), -->
<!--     logLik(tm3.fcov7$diff.p.avg.and.current.shot.speed)  ) -->
<!--   ) -->

<!-- tm3.fcov7_df$newcolumn<-c("oppo.start.position.x", "diff.p.avg.and.current.shot.speed") -->

<!-- names(tm3.fcov7_df) <- c("convergence.loglik", "Variables") -->

<!-- #print variable with the highest convergence log likelihood -->
<!-- tm3.fcov7_df %>%  -->
<!--    slice(which.max(convergence.loglik)) -->

<!-- #Model Stops improving at this point -->
<!-- ``` -->

##Animations
###Exploring visualisations of player movement
```{r}
library(grid)

# ggplot(longest_df, aes(x=p.start.position.x, xend=p.end.position.x, y=p.start.position.y, yend=p.end.position.y, z=winner))   + stat_summary_hex(fun = function(winner) sum(winner)) + geom_segment(arrow = arrow(angle = 15,))  + xlab("Federer Position X ") + ylab("Federer Position Y") + ggtitle("Federer positions in longest rally") 

 # ggplot(longest_df, aes(x=p.start.position.x, xend=p.end.position.x, y=p.start.position.y, yend=p.end.position.y, z=winner))   + 
 #   stat_summary_hex(fun = function(winner) sum(winner)) + 
 #   geom_text(aes(label=shot)) +
 #   geom_path(arrow = arrow(angle = 15))  + 
 #   xlab("Federer Position X ") + 
 #   ylab("Federer Position Y") + 
 #   ggtitle("Federer positions in longest rally") 
```

```{r }

#static player positions
trial_df <- filter(fed16_pos, final.shot >= 14)

 p.rally.paths <- ggplot(trial_df, aes(x=p.start.position.x,  y=p.start.position.y))    + 
   scale_x_continuous(breaks = axis_labels$x.break) +
    scale_y_continuous(breaks = axis_labels$y.break) +
    geom_path(data = court_trace, aes(x = x, y = y), color = 'black', size = 1, alpha = 0.75) +
    geom_path(data = net_trace, aes(x = x, y = y), color = 'grey40', size = 1, lineend = 'round') +
    coord_fixed() +
   geom_point(aes(alpha = shot))  + 
   geom_path(  arrow = arrow(angle = 15)) + 
   facet_wrap(~rally.number) + 
   xlab("Federer Position X ") + 
   ylab("Federer Position Y") + 
   ggtitle("Federer start and end positions for rallies 14 shots or longer") 
 p.rally.paths <- ggplotly(p.rally.paths)
   
 p.rally.paths


```

```{r}
 
oppo.rally.paths <- ggplot(trial_df, aes(x=oppo.start.position.x,  y=oppo.start.position.y ))    + 
  scale_x_continuous(breaks = axis_labels$x.break) +
  scale_y_continuous(breaks = axis_labels$y.break) +
  geom_path(data = court_trace, aes(x = x, y = y), color = 'black', size = 1, alpha = 0.75) +
  geom_path(data = net_trace, aes(x = x, y = y), color = 'grey40', size = 1, lineend = 'round') +
  coord_fixed() +
  geom_point(aes(alpha = shot))  + 
  geom_path(  arrow = arrow(angle = 15)) +   
  facet_wrap(~rally.number) + xlab("Opponent Position X ") + ylab("Opponent Position Y") +
  ggtitle("Opponent start and end positions for for rallies 14 shots or longer")  
oppo.rally.paths <- ggplotly(oppo.rally.paths)
oppo.rally.paths
```