---
title: "rallies"
author: "Pat Healy"
date: "17 November 2018"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
library(devtools)
library(ggplot2)
library(tidyr)
library(dplyr)
library(tidyverse)
```
```{r}
load("data/rallies.RData")
library(readr)
```
Shaping data to recreate the variables used in ("Federer AO 2017.Rmd")'Federer vs Berych 2017' for the AO matches 'Djokovic v Chung 2016', 'Djokovic v Chung 2018', 'Federer v Berdych 2016', 'Federer v Berdych 2018', 'Makarova v Konta 2016','Makarova v Konta 2017','Strycova v Garcia 2016' 'Strycova v Garcia 2017', 'Siegemund v Jankovic 2016','Siegemund v Jankovic 2017', 'Goffin v Thiem 2016''Goffin v Thiem 2017'""

'Siegemund v Jankovic 2017' goes from set 3 to set 6?? 

#Seperating and shaping matches

```{r }
djo16_df <- filter(rallies, year == 2016, h2h == "DJOKOVIC CHUNG" )
djo16_df <- arrange(djo16_df, matchid, set, game, point, shot)

djo18_df <- filter(rallies, year == 2018, h2h == "DJOKOVIC CHUNG" )
djo18_df <- arrange(djo18_df, matchid, set, game, point, shot)

fed16_df <- filter(rallies, year == 2016, h2h == "FEDERER BERDYCH" )
fed16_df <- arrange(fed16_df, matchid, set, game, point, shot)

fed17_df <- filter(rallies, year == 2017, h2h == "FEDERER BERDYCH" )
fed17_df <- arrange(fed17_df, matchid, set, game, point, shot)

fed18_df <- filter(rallies, year == 2018, h2h == "FEDERER BERDYCH" )
fed18_df <- arrange(fed18_df, matchid, set, game, point, shot)

mak16_df <- filter(rallies, year == 2016, h2h == "MAKAROVA KONTA" )
mak16_df <- arrange(mak16_df, matchid, set, game, point, shot)

mak17_df <- filter(rallies, year == 2017, h2h == "MAKAROVA KONTA" )
mak17_df <- arrange(mak17_df, matchid, set, game, point, shot)

stry16_df <- filter(rallies, year == 2016, h2h == "STRYCOVA GARCIA" )
stry16_df <- arrange(stry16_df, matchid, set, game, point, shot)

stry17_df <- filter(rallies, year == 2017, h2h == "STRYCOVA GARCIA" )
stry17_df <- arrange(stry17_df, matchid, set, game, point, shot)

sie16_df <- filter(rallies, year == 2016, h2h == "SIEGEMUND JANKOVIC" )
sie16_df <- arrange(sie16_df, matchid, set, game, point, shot)

sie17_df <- filter(rallies, year == 2017, h2h == "SIEGEMUND JANKOVIC" )
sie17_df <- arrange(sie17_df, matchid, set, game, point, shot)

thi16_df <- filter(rallies, year == 2016, h2h == "THIEM GOFFIN" )
thi16_df <- arrange(thi16_df, matchid, set, game, point, shot)

thi17_df <- filter(rallies, year == 2017, h2h == "THIEM GOFFIN" )
thi17_df <- arrange(thi17_df, matchid, set, game, point, shot)
```
##Federer Vs Berdych
(some columns in rallies data have a different classification than in federer2017 data. Such as 'is.good' replaces 'ended.in.error')(With Aces dropped we also now cannot recreate retser, retser1 or retser2 )
Starting with Federer vs Berdych 2016


###Federer 2016 
```{r  }

#Reorienting shots so that all Federer's shot are from negative x side of court, and all opponents shots are from positive x side. y coordinates have been flipped as required.
fed16_df <- fed16_df %>% rowwise %>%
  mutate(projected.ballmark.y = ifelse(impact.player == "FEDERER" & start.x >= 0, -projected.ballmark.y, projected.ballmark.y)) %>%
  mutate(start.y = ifelse(impact.player == "FEDERER" & start.x >= 0, -start.y, start.y))%>%
  mutate(projected.ballmark.x = ifelse(impact.player == "FEDERER" & start.x >= 0, -projected.ballmark.x, projected.ballmark.x)) %>%
  mutate(start.x = ifelse(impact.player == "FEDERER" & start.x >= 0, -start.x, start.x)) 

#Reorienting opponent shots
fed16_df <- fed16_df %>% rowwise %>%
  mutate(start.y = ifelse(impact.player != "FEDERER" & start.x <= 0, -start.y, start.y)) %>%
  mutate(projected.ballmark.y = ifelse(impact.player != "FEDERER" & start.x <= 0, -projected.ballmark.y, projected.ballmark.y)) %>%
  mutate(projected.ballmark.x = ifelse(impact.player != "FEDERER" & start.x <= 0, -projected.ballmark.x, projected.ballmark.x)) %>%
  mutate(start.x = ifelse(impact.player != "FEDERER" & start.x <= 0, -start.x, start.x))
```


```{r }

#Reorienting player positions so that all Federer's & Opponents start/end positions match reoriented ballmarks
#For Federer
fed16_df <- fed16_df %>% rowwise %>%
  mutate(start.server.y = ifelse(server == "FEDERER" & start.server.x >= 0, -start.server.y, start.server.y)) %>%
  mutate(start.receiver.y = ifelse(receiver == "FEDERER" & start.receiver.x >= 0, -start.receiver.y, start.receiver.y))%>%
  mutate(end.server.y = ifelse(server == "FEDERER" & end.server.x >= 0, -end.server.y, end.server.y)) %>%
  mutate(end.receiver.y = ifelse(receiver == "FEDERER" & end.receiver.x >= 0, -end.receiver.y, end.receiver.y))%>%
  mutate(start.server.x = ifelse(server == "FEDERER" & start.server.x >= 0, -start.server.x, start.server.x)) %>%
  mutate(start.receiver.x = ifelse(receiver == "FEDERER" & start.receiver.x >= 0, -start.receiver.x, start.receiver.x)) 

fed16_df <- fed16_df %>% rowwise %>%
  mutate(end.server.x = ifelse(server == "FEDERER" & end.server.x >= 0, -end.server.x, end.server.x)) %>%
  mutate(end.receiver.x = ifelse(receiver == "FEDERER" & end.receiver.x >= 0, -end.receiver.x, end.receiver.x)) 
```

```{r }


#For Opponent
fed16_df <- fed16_df %>% rowwise %>%
  mutate(start.server.y = ifelse(server != "FEDERER" & start.server.x <= 0, -start.server.y, start.server.y)) %>%
  mutate(start.receiver.y = ifelse(receiver != "FEDERER" & start.receiver.x <= 0, -start.receiver.y, start.receiver.y))%>%
  mutate(end.server.y = ifelse(server != "FEDERER" & end.server.x <= 0, -end.server.y, end.server.y)) %>%
  mutate(end.receiver.y = ifelse(receiver != "FEDERER" & end.receiver.x <= 0, -end.receiver.y, end.receiver.y))%>%
  mutate(start.server.x = ifelse(server != "FEDERER" & start.server.x <= 0, -start.server.x, start.server.x)) %>%
  mutate(start.receiver.x = ifelse(receiver != "FEDERER" & start.receiver.x <= 0, -start.receiver.x, start.receiver.x)) 

fed16_df <- fed16_df %>% rowwise %>%
  mutate(end.server.x = ifelse(server != "FEDERER" & end.server.x <= 0, -end.server.x, end.server.x)) %>%
  mutate(end.receiver.x = ifelse(receiver != "FEDERER" & end.receiver.x <= 0, -end.receiver.x, end.receiver.x)) 
```





```{r}
fed16_df <- fed16_df %>%
  mutate(lastshot = ifelse(shot == final.shot,1,0)) %>%
  mutate(isserver = ifelse(server == impact.player,1,0)) %>%
  mutate(fhand = ifelse(hitpoint == "F",1,0)) %>%
  mutate(opponent = ifelse(server == "FEDERER", receiver, server)) 
 

  

```

```{r}
#Serve, return and winner classifications


#Create variables for winner, 1st serve and second serve
fed16_df <- fed16_df %>%
  mutate(winner = ifelse(is.good == TRUE & lastshot == 1,1,0)) %>%
  mutate(ser1 = ifelse(serve == 1 & serve_classification == 1,1,0)) %>%
  mutate(ser2 = ifelse(serve == 2 & serve_classification == 1,1,0)) 
  
for (i in 1:ncol(fed16_df)) {
  if(is.character(fed16_df[,i]) == TRUE) {
    fed16_df[,i] <- as.factor(fed16_df[,i])
  }
}
```

```{r}
#Combining winner, return into play and error into 1 column for three states in hidden markov model
#If ball is in play and the shot is a winner value of 1
#If ball is in play and the shot is not a winner value of 0
#If the ball is out of play and thus not a winner value of -1

fed16_df <- fed16_df %>%
  mutate(winner.return.error = ifelse(is.good =="TRUE" & winner == "1",1,
                ifelse(is.good =="TRUE" & winner == "0",0,-1)))
```


```{r}
#Creating variable for rally number
col = c("set","game", "point")
rally.num = as.data.frame(group_indices_(fed16_df,.dots = col))
colnames(rally.num)<- "rally.number"
```

```{r}
#joining rally.number to federer16 data frame

fed16_df <- fed16_df %>%
  cbind(rally.num)
 
```



```{r}
#New Variables for player and opponent: start/end positions,  speed &acceleration, distance run within shot, work, advantage, total changes  

#start/end player positions x/y
fed16_df <- fed16_df %>%
  mutate(oppo.start.position.x = ifelse(server != "FEDERER", start.server.x,0)+ifelse(server == "FEDERER", start.receiver.x,0))%>%
  mutate(oppo.start.position.y = ifelse(server != "FEDERER", start.server.y,0)+ifelse(server == "FEDERER", start.receiver.y,0)) %>%
  mutate(oppo.end.position.x = ifelse(server != "FEDERER", end.server.x,0)+ifelse(server == "FEDERER", end.receiver.x,0)) %>%
  mutate(oppo.end.position.y = ifelse(server != "FEDERER", end.server.y,0)+ifelse(server == "FEDERER", end.receiver.y,0)) %>%
  mutate(p.start.position.x = ifelse(server == "FEDERER", start.server.x,0)+ifelse(server != "FEDERER", start.receiver.x,0)) %>%
  mutate(p.start.position.y = ifelse(server == "FEDERER", start.server.y,0)+ifelse(server != "FEDERER", start.receiver.y,0)) %>%
  mutate(p.end.position.x = ifelse(server == "FEDERER", end.server.x,0)+ifelse(server != "FEDERER", end.receiver.x,0)) %>%
  mutate(p.end.position.y = ifelse(server == "FEDERER", end.server.y,0)+ifelse(server != "FEDERER", end.receiver.y,0)) 
  
#player and opponent distances travelled from start of shot to end of next shot
fed16_df <- fed16_df %>%  
  mutate(oppo.distance = ifelse(server != "FEDERER", server.distance,0)+ifelse(server == "FEDERER", receiver.distance,0)) %>%
  mutate(p.distance = ifelse(server == "FEDERER", server.distance,0)+ifelse(server != "FEDERER", receiver.distance,0))

#player and opponent speed 
fed16_df <- fed16_df %>%
  mutate(p.peak.speed = ifelse(server == "FEDERER", server.peak.speed,0)+ifelse(server != "FEDERER", receiver.peak.speed,0)) %>%
  mutate(p.avg.speed = ifelse(server == "FEDERER", server.avg.speed,0)+ifelse(server != "FEDERER", receiver.avg.speed,0)) 
  

#player and opponent acceleration
fed16_df <- fed16_df %>%  
  mutate(p.avg.acceleration = ifelse(server == "FEDERER", server.avg.acceleration,0)+ifelse(server != "FEDERER", receiver.avg.acceleration,0)) %>%
  mutate(p.peak.acceleration = ifelse(server == "FEDERER", server.peak.acceleration,0)+ifelse(server != "FEDERER", receiver.peak.acceleration,0)) %>%
  mutate(oppo.peak.speed = ifelse(server != "FEDERER", server.peak.speed,0)+ifelse(server == "FEDERER", receiver.peak.speed,0)) %>%
  mutate(oppo.avg.speed = ifelse(server != "FEDERER", server.avg.speed,0)+ifelse(server == "FEDERER", receiver.avg.speed,0)) %>%
  mutate(oppo.avg.acceleration = ifelse(server != "FEDERER", server.avg.acceleration,0)+ifelse(server == "FEDERER", receiver.avg.acceleration,0)) %>%
  mutate(oppo.peak.acceleration = ifelse(server != "FEDERER", server.peak.acceleration,0)+ifelse(server == "FEDERER", receiver.peak.acceleration,0))


#player and opponent work
fed16_df <- fed16_df %>%
  mutate(oppo.work = ifelse(server != "FEDERER", server.work,0)+ifelse(server == "FEDERER", receiver.work,0)) %>%
  mutate(p.work = ifelse(server == "FEDERER", server.work,0)+ifelse(server != "FEDERER", receiver.work,0)) 

#player and opponent advantage
fed16_df <- fed16_df %>%
  mutate(oppo.advantage =ifelse(server != "FEDERER", server.advantage,0)+ifelse(server == "FEDERER", receiver.advantage,0))%>%
   mutate(p.advantage =ifelse(server == "FEDERER", server.advantage,0)+ifelse(server != "FEDERER", receiver.advantage,0))


#player and opponent total changes
fed16_df <- fed16_df %>%
  mutate(oppo.total.changes =ifelse(server != "FEDERER", server.total.changes,0)+ifelse(server == "FEDERER", receiver.total.changes,0))%>%
   mutate(p.total.changes =ifelse(server == "FEDERER", server.total.changes,0)+ifelse(server != "FEDERER", receiver.total.changes,0))
  
  
```

```{r}

#player speed and acceleration differences and ratios
fed16_df <- fed16_df %>%
  mutate(avg.player.speed.diff = p.avg.speed-oppo.avg.speed) %>%
  mutate(peak.player.speed.diff = p.peak.speed-oppo.peak.speed) %>%
  mutate(avg.player.speed.ratio = p.avg.speed/oppo.avg.speed) %>%
  mutate(peak.player.speed.ratio = p.peak.speed/oppo.peak.speed) %>%
  mutate(avg.player.acceleration.diff = (p.avg.acceleration)-(oppo.avg.acceleration)) %>%
  mutate(peak.player.acceleration.diff = (p.peak.acceleration)-(oppo.peak.acceleration)) %>%
  mutate(avg.player.acceleration.ratio = (p.avg.acceleration)/(oppo.avg.acceleration)) %>%
  mutate(peak.player.acceleration.ratio = (p.peak.acceleration)/(oppo.peak.acceleration)) %>%
  mutate(p.avg.speed.match = mean(p.avg.speed)) %>%
  mutate(oppo.avg.speed.match = mean(oppo.avg.speed)) %>%
  mutate(p.diff.avg.shot.and.match.movement.speed = p.avg.speed - p.avg.speed.match) %>%
  mutate(oppo.diff.avg.shot.and.match.movement.speed = oppo.avg.speed - oppo.avg.speed.match)
  

#player/opponent side distance for start/end positions
fed16_df <- fed16_df %>%
  mutate(p.start.position.side.dist = 4.115 - abs(p.start.position.y)) %>%
  mutate(p.end.position.side.dist = 4.115 - abs(p.end.position.y)) %>%
  mutate(oppo.start.position.side.dist = 4.115 - abs(oppo.start.position.y)) %>%
  mutate(oppo.end.position.side.dist = 4.115 - abs(oppo.end.position.y))
  
#player/opponent base distances for start/end positions  
fed16_df <- fed16_df %>%
  mutate(p.start.position.base.dist = 11.89 - abs(p.start.position.x)) %>%
  mutate(p.end.position.base.dist = 11.89 - abs(p.end.position.x)) %>%
  mutate(oppo.start.position.base.dist = 11.89 - abs(oppo.start.position.x)) %>%
  mutate(oppo.end.position.base.dist = 11.89 - abs(oppo.end.position.x)) %>%
  mutate(oppo.start.position.base.diff = p.start.position.base.dist - oppo.start.position.base.dist) %>%
  mutate(p.start.position.base.diff = oppo.start.position.base.dist -p.start.position.base.dist) %>%
  mutate(oppo.end.position.base.diff = p.end.position.base.dist - oppo.end.position.base.dist) %>%
  mutate(p.end.position.base.diff = oppo.end.position.base.dist -p.end.position.base.dist) %>%
  mutate(p.start.position.centre.diff = abs(oppo.start.position.y)-abs(p.start.position.y)) %>%
  mutate(p.end.position.centre.diff = abs(oppo.end.position.y)-abs(p.end.position.y)) %>%
  mutate(oppo.start.position.centre.diff = abs(p.start.position.y)-abs(oppo.start.position.y)) %>%
  mutate(oppo.end.position.centre.diff = abs(p.end.position.y)-abs(oppo.end.position.y))
  
  
```
```{r}
#player/ opponent shortest distances for start/end positions 
fed16_df <- fed16_df %>%
  mutate(oppo.start.position.short.dist = min(oppo.start.position.side.dist, oppo.start.position.base.dist)) %>%
   mutate(oppo.end.position.short.dist = min(oppo.end.position.side.dist, oppo.end.position.base.dist)) %>%
  mutate(p.start.position.short.dist = min(p.start.position.side.dist, p.start.position.base.dist)) %>%
   mutate(p.end.position.short.dist = min(p.end.position.side.dist, p.end.position.base.dist)) 
```



```{r}

#Tally of the number of times player and opponent change side during rally
#Defining change of side as having travelled from a location 2.0575 or more metres away from the centre on one side of the court (half the distance between centre and singles lines) to a location 2.0575 or more metres away from the centre on the other side of the court
fed16_df <- fed16_df %>%
  mutate(p.side.change.count = ifelse(p.start.position.y <= -2.0575 & p.end.position.y >= 2.0575, 1, ifelse(p.start.position.y >= 2.0575 & p.end.position.y <= -2.0575, 1, 0))) %>%
  mutate(p.side.change.cumsum = cumsum(p.side.change.count)) %>%
  mutate(oppo.side.change.count = ifelse(oppo.start.position.y <= -2.0575 & oppo.end.position.y >= 2.0575, 1, ifelse(oppo.start.position.y >= 2.0575 & oppo.end.position.y <= -2.0575, 1, 0))) %>%
  mutate(oppo.side.change.cumsum = cumsum(oppo.side.change.count)) 
  


  
  
```

```{r}
#Within rally tally of side change count and distance run
fed16_df <- fed16_df %>%
  group_by(rally.number ) %>%
  dplyr::mutate(p.rally.side.change.count = cumsum(p.side.change.count)) %>%
  dplyr::mutate(oppo.rally.side.change.count = cumsum(oppo.side.change.count)) %>%
  dplyr::mutate(rally.side.change.count.diff = p.rally.side.change.count-oppo.rally.side.change.count) %>%
  dplyr::mutate(oppo.rally.distance.run = cumsum(oppo.distance)) %>%
  dplyr::mutate(p.rally.distance.run = cumsum(p.distance)) %>%
  dplyr::mutate(rally.distance.run.ratio = p.rally.distance.run/oppo.rally.distance.run) %>%
  ungroup
 
```
```{r}
#Seperating height over net of shots for player and opponent.

fed16_df <- fed16_df %>%
  mutate(p.height.off.net = ifelse(impact.player == "FEDERER",height.off.net,0)) %>%
  mutate(oppo.height.off.net = ifelse(impact.player != "FEDERER", height.off.net,0)) 
  
```


```{r}
#Adding angles for player & opposition movement from start position[i] to end position[i] as well as end position[i] to start position[i+1]. Measuring the angle of movement from the baseline. Directly towards the net is 0 deg. Directly away from the net is 180 deg.


fed16_df <- fed16_df %>%
  mutate(p.movement.angle.1 = NA) %>%
  mutate(p.movement.angle.2 = NA) %>%
  mutate(oppo.movement.angle.1 = NA) %>%
  mutate(oppo.movement.angle.2 = NA) 
  
  
#player start to end movement angle  
for (i in 1:nrow(fed16_df)) {
  a1 <- fed16_df$p.start.position.x[i]
  b1 <- fed16_df$p.start.position.y[i]
  a2 <- fed16_df$p.end.position.x[i]
  b2 <- fed16_df$p.end.position.y[i]
  
  
  p.movement.angle.1 <- atan(
  ((abs(b1)-abs(b2))/(abs(a1)-abs(a2)))* 180/pi) 
  
  fed16_df$p.movement.angle.1[i] = ifelse(p.movement.angle.1 < 0 & (abs(a1)-abs(a2))<0, 180+p.movement.angle.1,
                                          ifelse(p.movement.angle.1 < 0 & (abs(b1)-abs(b2))<0,abs(p.movement.angle.1),
                                                 ifelse(p.movement.angle.1 > 0 & (abs(a1)-abs(a2))<0, 90+p.movement.angle.1,p.movement.angle.1)))
                                                                                                            
}



```
```{r}
#player end position(i) to start position (i+1) movement angle
for (i in 2:nrow(fed16_df)) {
  a1 <- fed16_df$p.end.position.x[i]
  b1 <- fed16_df$p.end.position.y[i]
  a2 <- fed16_df$p.start.position.x[i+1]
  b2 <- fed16_df$p.start.position.y[i+1]
  
  p.movement.angle.2 <- atan(
  ((abs(b1)-abs(b2))/(abs(a1)-abs(a2)))* 180/pi) 
  
  fed16_df$p.movement.angle.2[i] = ifelse(p.movement.angle.2 < 0 & (abs(a1)-abs(a2))<0, 180+p.movement.angle.2,
                                          ifelse(p.movement.angle.2 < 0 & (abs(b1)-abs(b2))<0,abs(p.movement.angle.2),
                                                 ifelse(p.movement.angle.2 > 0 & (abs(a1)-abs(a2))<0, 90+p.movement.angle.2,p.movement.angle.2)))
  
}  
  


```

```{r}
# opposition start to end movement angle

  
for (i in 1:nrow(fed16_df)) {
  a1 <- fed16_df$oppo.start.position.x[i]
  b1 <- fed16_df$oppo.start.position.y[i]
  a2 <- fed16_df$oppo.end.position.x[i]
  b2 <- fed16_df$oppo.end.position.y[i]
  
  oppo.movement.angle.1 <- atan(
  ((abs(b1)-abs(b2))/(abs(a1)-abs(a2)))* 180/pi) 
  
  fed16_df$oppo.movement.angle.1[i] = ifelse(oppo.movement.angle.1 < 0 & (abs(a1)-abs(a2))<0,180+oppo.movement.angle.1,
                                          ifelse(oppo.movement.angle.1 < 0 & (abs(b1)-abs(b2))<0,abs(oppo.movement.angle.1),
                                                 ifelse(oppo.movement.angle.1 > 0 & (abs(a1)-abs(a2))<0,90+oppo.movement.angle.1,p.movement.angle.1)))
  
  
}
```
```{r}
#oppositions end[i] to start [i+1] movement angle
for (i in 2:nrow(fed16_df)) {
  a1 <- fed16_df$oppo.end.position.x[i]
  b1 <- fed16_df$oppo.end.position.y[i]
  a2 <- fed16_df$oppo.start.position.x[i+1]
  b2 <- fed16_df$oppo.start.position.y[i+1]
  
  oppo.movement.angle.2 <- atan(
  ((abs(b1)-abs(b2))/(abs(a1)-abs(a2)))* 180/pi) 
  
  fed16_df$oppo.movement.angle.2[i] = ifelse(oppo.movement.angle.2 < 0 & (abs(a1)-abs(a2))<0, 180+oppo.movement.angle.2,
                                          ifelse(oppo.movement.angle.2 < 0 & (abs(b1)-abs(b2))<0,abs(oppo.movement.angle.2),
                                                 ifelse(oppo.movement.angle.2 > 0 & (abs(a1)-abs(a2))<0, 90+oppo.movement.angle.2,oppo.movement.angle.2)))
}
```
```{r}
##speed of player ad opponent shots in m/s at the start of the shot arc
fed16_df <- fed16_df %>%
  mutate(p.start.shot.speed = ifelse(impact.player == "FEDERER", speed.start, 0)) %>%
  mutate(oppo.start.shot.speed = ifelse(impact.player != "FEDERER", speed.start, 0)) 
```


```{r}
#code for this chunk relatively unchanged
# replaced ballmark.x with projected.ballmark.x; speed1 replaced by speed.start

fed16_df <- fed16_df %>%
  mutate(speed.diff = NA) %>%
  mutate(oppo.hit.x = NA) %>%
  mutate(oppo.hit.y = NA) %>%
  mutate(oppo.hit.z = NA) %>%
  mutate(oppo.speed = NA) %>%
  mutate(oppo.projected.ballmark.x = NA) %>%
  mutate(oppo.projected.ballmark.y = NA) %>%
  mutate(speed.ratio = NA) 


for (i in 2:nrow(fed16_df)) {
  if(fed16_df$shot[i] != 1) {#so that only non-serves are affected

  fed16_df$speed.diff[i]=fed16_df$speed.start[i]-fed16_df$speed.start[i-1]
  #speed difference
  
  fed16_df$oppo.hit.x[i]=fed16_df$start.x[i-1]
  fed16_df$oppo.hit.y[i]=fed16_df$start.y[i-1]
  fed16_df$oppo.hit.z[i]=fed16_df$start.z[i-1]
  fed16_df$oppo.speed[i]=fed16_df$speed.start[i-1]
  fed16_df$oppo.projected.ballmark.x[i]=fed16_df$projected.ballmark.x[i-1]
  fed16_df$oppo.projected.ballmark.y[i]=fed16_df$projected.ballmark.y[i-1]
  #oppo hit
  
  }
}

fed16_df <- fed16_df %>%
  mutate(speed.ratio = speed.start/oppo.speed) %>% #speed ratio
  mutate(side.dist = 4.115 - abs(oppo.projected.ballmark.y)) %>% #distance of oppo.projected.ballmark from sideline
  mutate(base.dist = 11.89 - abs(oppo.projected.ballmark.x)) %>% #distance of oppo.projected.ballmark from baseline
  mutate(short.dist = min(side.dist, base.dist)) #shortest distance from any line


#Adding angles
fed16_df <- fed16_df %>%
  mutate(p.start.shot.x = NA) %>%
  mutate(p.start.shot.y = NA)

for (i in 3:nrow(fed16_df)) {
  if(fed16_df$impact.player[i] == fed16_df$impact.player[i-2] & fed16_df$shot[i] == fed16_df$shot[i-2] + 2) {
    fed16_df$p.start.shot.x[i]=fed16_df$start.x[i-2]
    fed16_df$p.start.shot.y[i]=fed16_df$start.y[i-2]
  }
}

#adding angle between fed.shot-opp.shot vector and opp.shot-opp.projected.ballmark vector
#doing it in one line because df doesn't want to add vectors
fed16_df <- fed16_df %>%
  mutate(o.angle = NA)
  
for (i in 1:nrow(fed16_df)) {
  x1 <- fed16_df$p.start.shot.x[i]
  y1 <- fed16_df$p.start.shot.y[i]
  x2 <- fed16_df$oppo.hit.x[i]
  y2 <- fed16_df$oppo.hit.y[i]
  x3 <- fed16_df$oppo.projected.ballmark.x[i]
  y3 <- fed16_df$oppo.projected.ballmark.y[i]
  
  o.angle <- acos(
  ((c(x1,y1)-c(x2,y2))/sqrt((x1-x2)^2+(y1-y2)^2)) %*%
    ((c(x2,y2)-c(x3,y3))/sqrt((x2-x3)^2+(y2-y3)^2))) * 180/pi
  
  fed16_df$o.angle[i] = ifelse(o.angle > 90, 180-o.angle, o.angle)
}

#Now adding the angle the player hits
fed16_df <- fed16_df %>%
  mutate(p.angle = NA)
  
for (i in 1:nrow(fed16_df)) {
  x1 <- fed16_df$oppo.hit.x[i]
  y1 <- fed16_df$oppo.hit.y[i]
  x2 <- fed16_df$start.x[i]
  y2 <- fed16_df$start.y[i]
  x3 <- fed16_df$projected.ballmark.x[i]
  y3 <- fed16_df$projected.ballmark.y[i]
  
  p.angle <- acos(
  ((c(x1,y1)-c(x2,y2))/sqrt((x1-x2)^2+(y1-y2)^2)) %*%
    ((c(x2,y2)-c(x3,y3))/sqrt((x2-x3)^2+(y2-y3)^2))) * 180/pi
  
  fed16_df$p.angle[i] = ifelse(p.angle > 90, 180-p.angle, p.angle)
}

fed16_df <- fed16_df %>%
  group_by(rally.number) %>%
  mutate(lag.p.angle = dplyr::lag(p.angle, n = 1, default = NA)) %>%
  mutate(lag.speed.ratio = dplyr::lag(speed.ratio, n = 1, default = NA)) %>%
  mutate(lag.p.movement.angle.1 = dplyr::lag(p.movement.angle.1, n = 1, default = NA)) %>%
  mutate(lag.p.movement.angle.2 = dplyr::lag(p.movement.angle.2, n = 1, default = NA)) %>%
  mutate(lag.oppo.height.off.net = dplyr::lag(oppo.height.off.net, n = 1, default = NA)) %>%
  mutate(lag.p.start.shot.speed = dplyr::lag(p.start.shot.speed, n = 1, default = NA)) %>%
  mutate(lag.oppo.start.shot.speed = dplyr::lag(oppo.start.shot.speed, n = 1, default = NA)) %>%
  ungroup


```




```{r}
fed16_df <- fed16_df %>%
  mutate(oppo.start.server.x = ifelse(server != "FEDERER", start.server.x, 0)) 
```



```{r  }
#Creating Columns of player, opponent and ball positions for Animations
#creating new rows so that every second row start and end player positions are switched
#Also creating new rows so that every second row in start.x,/start.y is projected ballmark
#this allows us to better plot player positions as well as track positions for animations

join_df <- transform(fed16_df, p.start.position.x=p.end.position.x, p.start.position.y=p.end.position.y, oppo.start.position.x=oppo.end.position.x, oppo.start.position.y=oppo.end.position.y, start.x=projected.ballmark.x, start.y=projected.ballmark.y)

fed16_pos <- bind_rows(fed16_df, setNames(join_df, names(fed16_df))) %>% 
           arrange(rally.number, shot)

fed16_pos <- fed16_pos %>%
  group_by(rally.number, idx = cumsum(event == 1L)) %>%
  mutate(location.id= row_number()) %>%
  ungroup

fed16_pos <- fed16_pos %>%
  group_by(rally.number) %>%
  mutate(pos.rally.count= 1:n()) %>%
  ungroup
``` 





```{r }

#Removing opponent shots from data as we want to look at Federer for the Hidden Markov Model
#remove opponents
fed_no.opp <- fed16_df %>% 
  dplyr::filter(impact.player == "FEDERER")

#federer only - remove serves
fed16_only <- fed_no.opp %>%
  filter(hitpoint != "S") %>%
  dplyr::select(-serveid)


#First remove any errors for start, projected.ballmark, so that we are only looking at shots that we hit onto the other side
#To check: ggplot(fed16_only, aes(projected.ballmark.x, projected.ballmark.y)) + geom_point()
fed16_only <- fed16_only %>%
  filter(oppo.hit.x >= 0) %>%
  filter(oppo.projected.ballmark.x <= 0) %>%
  filter(projected.ballmark.x >= 0)

#Adding shot number cumulative count (functions as time)
#check this for new data set .
fed16_only <- fed16_only %>%
  mutate(count = 1)

  for (i in 2:nrow(fed16_only)) {
    if(fed16_only$matchid[i]==fed16_only$matchid[i-1]) {
      fed16_only$count[i] = fed16_only$count[i-1] + 1
    }
  }

  

#Adjusting to remove NAs and replace with 0s for modelling
fed16_only$o.angle[is.na(fed16_only$o.angle)] <- 0
fed16_only$lag.p.angle[is.na(fed16_only$lag.p.angle)] <- 0
fed16_only$lag.speed.ratio[is.na(fed16_only$lag.speed.ratio)] <- 0
fed16_only$p.start.shot.x[is.na(fed16_only$p.start.shot.x)] <- 0
fed16_only$p.start.shot.y[is.na(fed16_only$p.start.shot.y)] <- 0
fed16_only$lag.p.movement.angle.1[is.na(fed16_only$lag.p.movement.angle.1)] <- 0
fed16_only$lag.p.movement.angle.2[is.na(fed16_only$lag.p.movement.angle.2)] <- 0
fed16_only$lag.oppo.height.off.net[is.na(fed16_only$lag.oppo.height.off.net)] <- 0



fed16_only <- fed16_only %>% mutate(player.total.shot.number = row_number())
```
```{r}
fed16_only_plots <- fed16_only
```

```{r}
#making y positions absolute for fed16_only as this is more relevant for the depmix model

fed16_only <- fed16_only %>%
  mutate(p.start.position.y = abs(p.start.position.y)) %>%
  mutate(p.end.position.y = abs(p.end.position.y)) %>%
  mutate(oppo.start.position.y = abs(oppo.start.position.y)) %>%
  mutate(oppo.end.position.y = abs(oppo.end.position.y))%>%
  mutate(p.start.shot.y =abs(p.start.shot.y))
  
  

```


```{r }
#Creating seperate data frames for shot types useful for visualisation of shot patterns
dlb_pos <- filter(fed16_pos, down.line.backhand == "TRUE")

dlb_df <- filter(fed16_df, down.line.backhand == "TRUE")

dlb_fedonly <- filter(fed16_only, down.line.backhand == "TRUE")

iof_fedonly <- filter(fed16_only, inside.out.forehand == "TRUE")

dlw_fedonly <- filter(fed16_only, down.line.winner == "TRUE")
```




```{r}
#variables for speed of ball at the start of shot arcs

fed16_only <- fed16_only %>%
  mutate(avg.p.start.shot.speed = mean(p.start.shot.speed)) %>%
  mutate(avg.lag.oppo.start.shot.speed = mean(lag.oppo.start.shot.speed)) %>%
  mutate(diff.p.avg.and.current.shot.speed = p.start.shot.speed- avg.p.start.shot.speed) %>%
  mutate(diff.lag.oppo.avg.and.current.shot.speed = lag.oppo.start.shot.speed- avg.lag.oppo.start.shot.speed) 


  
```







```{r}
##Plots of shot and ballmark co-ordinates, angles made by shots and speed 
library(ggplot2)
#X Co-ordinate of shot
ggplot(fed16_only, aes(x=start.x,winner)) + geom_smooth() + xlab("X Coordinate of Shot") + ylab("Proportion of Winners") + ggtitle("Winners By X Co-Ordinate")

#Opponents shot before
library(hexbin)
ggplot(fed16_only, aes(x=oppo.hit.x,y=oppo.hit.y,z=winner)) + stat_summary_hex(fun = function(winner) sum(winner)) + xlab("X Coordinate of Oppo Shot") + ylab("Y Coordinate of Oppo Shot") + ggtitle("Count of Winners By Opponent's Shot Co-Ordinates")
### Get help transforming this to proportion in each bin instead of raw count

#Fed Shots on x-y plane
ggplot(fed16_only, aes(x=start.x,y=start.y,z=winner)) + stat_summary_hex(fun = function(winner) sum(winner)) + xlab("X Coordinate") + ylab("Y Coordinate") + ggtitle("Winners By Shot Co-Ordinates")

#Fed Ballmark by winner in x-y plane
ggplot(fed16_only, aes(x=projected.ballmark.x,y=projected.ballmark.y,z=winner)) + stat_summary_hex(fun = function(winner) sum(winner)) + xlab("X Coordinate") + ylab("Y Coordinate") + ggtitle("Winners By Shot Ballmark Co-Ordinates")


#Angle of shots
ggplot(fed16_only, aes(x=o.angle,y=winner)) + geom_smooth() + xlab("Angle Made By Opponents Shot With Fed's Previous Shot") + ylab("Proportion of Winners") + ggtitle("Winners By Opponent Shot Angle")

ggplot(fed16_only, aes(x=p.angle,y=winner)) + geom_smooth() + xlab("Angle Made By Federer's Shot") + ylab("Proportion of Winners") + ggtitle("Winners By Federer's Shot Angle")

ggplot(fed16_only) + geom_density(aes(p.angle,group=factor(winner),color=factor(winner))) + ggtitle("Density of Winners by Fed Shot Angles")

ggplot(fed16_only) + geom_density(aes(o.angle,group=factor(winner),color=factor(winner))) + ggtitle("Density of Winners by Opponent Shot Angles")

#Winners by oppo speed
ggplot(fed16_only) + geom_density(aes(oppo.speed, group = factor(winner), color=factor(winner)))

ggplot(fed16_only, aes(x=factor(winner),y=oppo.speed,fill=factor(winner))) + geom_boxplot() + ggtitle("Winner by Opponent Speed")

#Winners by speed ratio
ggplot(fed16_only) + geom_density(aes(speed.ratio, group = factor(winner), color=factor(winner)))

ggplot(fed16_only, aes(x=factor(winner),y=speed.ratio,fill=factor(winner))) + geom_boxplot() + ggtitle("Winner by Speed Ratio")
```
 
```{r }
#Seperating out the longest rallies from this match to visualise them through animation
#examining rallies to look at side to side movement within rallies. Starting with the longest rally.
longral_df <- filter(fed16_pos, final.shot >= 10)
```
```{r}
longest_df <- filter(fed16_pos, final.shot == 17)
```

```{r}
#Visulaising speed ratio

ggplot(fed16_df, aes(x=base.dist,y=speed.ratio)) + geom_smooth() + xlab("Distance from the baseline") + ylab("Speed Ratio") + ggtitle("Speed ratio by distance from the baseline For match")

ggplot(fed16_only, aes(x=base.dist,y=speed.ratio)) + geom_smooth() + xlab("Distance from the baseline") + ylab("Speed Ratio") + ggtitle("Fed Only Speed ratio by distance from the baseline For match")

ggplot(longral_df, aes(x=base.dist,y=speed.ratio)) + geom_smooth() + xlab("Distance from the baseline") + ylab("Speed Ratio") + ggtitle("Speed ratio by distance from the baseline For Long Rallies")

ggplot(longest_df, aes(x=base.dist,y=speed.ratio)) + geom_smooth() + xlab("Distance from the baseline") + ylab("Speed Ratio") + ggtitle("Speed ratio by distance from the baseline For Longest Rally")




#Visualising player shot angles

ggplot(fed16_df, aes(x=base.dist,y=p.angle)) + geom_smooth() + xlab("Distance from the baseline") + ylab("Angle Made By Federers Shot") + ggtitle("Federer Shot Angle by distance from the baseline")

ggplot(fed16_only, aes(x=base.dist,y=p.angle)) + geom_smooth() + xlab("Distance from the baseline") + ylab("Angle Made By Federers Shot") + ggtitle("Fed only Shot Angle by distance from the baseline")

ggplot(fed16_df, aes(x=base.dist,y=o.angle)) + geom_smooth() + xlab("Distance from the baseline") + ylab("Angle Made By Berdych previous Shot") + ggtitle("Berdych Shot Angle by Federer distance from the baseline")


```
#Top down court view
```{r }
#
library(plotly)
#--- Packages Required
# require(ggplot2)
# require(plotly)

#--- Outline of the court
court_trace <- data.frame(x = c(-11.89, -11.89, 0, 0, 0, 11.89, 11.89, -11.89, -11.89, 11.89, 11.89, -11.89, -6.4, -6.4, 6.4, 6.4, 6.4, -6.4),
                          y = c(5.49, -5.49, -5.49, 5.49, -5.49, -5.49, 5.49, 5.49, 4.115, 4.115, -4.115, -4.115, -4.115, 4.115, 4.115, -4.115, 0, 0),
                          z = c(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0))
net_trace <- data.frame(x = c(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0),
                        y = c(-5.49,-5.49, -6.4, -6.4, -5.49, 0, 5.49, 6.4, 6.4, 5.49, 5.49),
                        z = c(1.07, 0, 0, 1.07, 1.07, 0.914, 1.07, 1.07, 0, 0, 1.07))
service_trace <- data.frame(x = c(-8, 0, 0, 0, -6.4, -6.4, 0, -6.4, -6.4, -6.4, -6.4, -6.4,  0, 0, -8),
                            y = c(-5.49, -5.49, -4.115, 4.115, 4.115, 0, 0, 0, -4.115, -5.49, 5.49, -4.115, -4.115, 5.49, 5.49),
                            z = c(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ,0 ,0))
    
axis_labels <- data.frame(x.break = c(-21.89:-11.89, -6.4, 0, 6.4, 11.89),
                          x.label = c("-10m","","","","","-5m","","","","",
                                      "Baseline","Service Line","Net","Service Line","Baseline"),
                          y.break = c(-5.49,-4.115,0,4.115,5.49),
                          y.label = c("Doubles", "Singles","Centre","Singles","Doubles"),
                          z.break = c(0,0.992,2,3,4),
                          z.label = c("Ground", "Net", "2m", "3m", "4m"))
#--- Top down court view
court_topdown <- ggplot() + 
    labs(x = "x direction", y = "y direction") + 
    scale_x_continuous(breaks = axis_labels$x.break,
                       labels = axis_labels$x.label) +
    scale_y_continuous(breaks = axis_labels$y.break,
                       labels = axis_labels$y.label) +
    geom_path(data = court_trace, aes(x = x, y = y), color = 'black', size = 1, alpha = 0.75) +
    geom_path(data = net_trace, aes(x = x, y = y), color = 'grey40', size = 1, lineend = 'round') +
    coord_fixed()



  
```


```{r}
#Using Data visualisation to explore new variables
```
```{r}
#Angle of movement
ggplot(fed16_only, aes(x=oppo.movement.angle.1,y=winner)) + geom_smooth() + xlab("Angle Made By Opponents movement") + ylab("Proportion of Winners") + ggtitle("Winners By Opponent movement angle 1")

ggplot(fed16_only, aes(x=p.movement.angle.1,y=winner)) + geom_smooth() + xlab("Angle Made By Federer's movement") + ylab("Proportion of Winners") + ggtitle("Winners By Federer's movement angle 1")

ggplot(fed16_only, aes(x=p.movement.angle.1,y=p.peak.speed)) + geom_smooth() + xlab("Angle Made By Federer's movement") + ylab("Federers Peak Speed") + ggtitle("Winners By Federer's movement angle 1")


```


```{r}
# #Movement and shot position seperated by forehand and backhand
# ggplot(longral_df, aes(x=p.start.position.x,y=p.start.position.y,z=winner))  + stat_summary_hex(fun = function(winner) sum(winner)) + facet_wrap(~factor(hitpoint)) + xlab("Player start Position X ") + ylab("Player start Position Y") + ggtitle("Federer winners by start position seperated by shot type for long rallies")
# 
# ggplot(longral_df, aes(x=p.end.position.x,y=p.end.position.y,z=winner))  + stat_summary_hex(fun = function(winner) sum(winner)) + facet_wrap(~factor(hitpoint)) + xlab("Player end Position X ") + ylab("Player end Position Y") + ggtitle("Federer winners by end position seperated by shot type for long rallies")
# 
# ggplot(longral_df, aes(x=p.start.position.x,y=p.start.position.y,z=is.good))  + stat_summary_hex(fun = function(is.good) sum(is.good)) + facet_wrap(~factor(hitpoint)) + xlab("Player start Position X ") + ylab("Player start Position Y") + ggtitle("Federer errors by start position seperated by shot type for long rallies")
# 
# ggplot(longral_df, aes(x=p.end.position.x,y=p.end.position.y,z=is.good))  + stat_summary_hex(fun = function(is.good) sum(is.good)) + facet_wrap(~factor(hitpoint)) + xlab("Player end Position X ") + ylab("Player end Position Y") + ggtitle("Federer errors by end position seperated by shot type for long rallies")
# 
# ggplot(longral_df, aes(x=p.start.position.x,y=p.start.position.y,z=time.to.net))  + stat_summary_hex(fun = function(time.to.net) sum(time.to.net)) + facet_wrap(~factor(hitpoint)) + xlab("Player start Position X ") + ylab("Player start Position Y") + ggtitle("Federer shot time to net by start position seperated by shot type for long rallies")
# 
# ggplot(longral_df, aes(x=p.end.position.x,y=p.end.position.y,z=time.to.net))  + stat_summary_hex(fun = function(time.to.net) sum(time.to.net)) + facet_wrap(~factor(hitpoint)) + xlab("Player end Position X ") + ylab("Player end Position Y") + ggtitle("Federer shot time to net by end position seperated by shot type for long rallies")

```
```{r}
# Federer backhands are played on the baseline the majority of the time. All errors and winners for Federer backhands in long rallies are starting on negative y side of court. Examine this further to see what type of backhands are being played to identify any risks. 
#For running backhand in long rallies, with a slower speed to net more errors appear to occur


```





```{r}
library(grid)

# ggplot(longest_df, aes(x=p.start.position.x, xend=p.end.position.x, y=p.start.position.y, yend=p.end.position.y, z=winner))   + stat_summary_hex(fun = function(winner) sum(winner)) + geom_segment(arrow = arrow(angle = 15,))  + xlab("Federer Position X ") + ylab("Federer Position Y") + ggtitle("Federer positions in longest rally") 

 # ggplot(longest_df, aes(x=p.start.position.x, xend=p.end.position.x, y=p.start.position.y, yend=p.end.position.y, z=winner))   + 
 #   stat_summary_hex(fun = function(winner) sum(winner)) + 
 #   geom_text(aes(label=shot)) +
 #   geom_path(arrow = arrow(angle = 15))  + 
 #   xlab("Federer Position X ") + 
 #   ylab("Federer Position Y") + 
 #   ggtitle("Federer positions in longest rally") 
```

```{r }

#static player positions
trial_df <- filter(fed16_pos, final.shot >= 14)

 p.rally.paths <- ggplot(trial_df, aes(x=p.start.position.x,  y=p.start.position.y))    + 
   scale_x_continuous(breaks = axis_labels$x.break) +
    scale_y_continuous(breaks = axis_labels$y.break) +
    geom_path(data = court_trace, aes(x = x, y = y), color = 'black', size = 1, alpha = 0.75) +
    geom_path(data = net_trace, aes(x = x, y = y), color = 'grey40', size = 1, lineend = 'round') +
    coord_fixed() +
   geom_point(aes(alpha = shot))  + 
   geom_path(  arrow = arrow(angle = 15)) + 
   facet_wrap(~rally.number) + 
   xlab("Federer Position X ") + 
   ylab("Federer Position Y") + 
   ggtitle("Federer start and end positions for rallies 14 shots or longer") 
 p.rally.paths <- ggplotly(p.rally.paths)
   
 p.rally.paths


```

```{r}
 
oppo.rally.paths <- ggplot(trial_df, aes(x=oppo.start.position.x,  y=oppo.start.position.y ))    + 
  scale_x_continuous(breaks = axis_labels$x.break) +
  scale_y_continuous(breaks = axis_labels$y.break) +
  geom_path(data = court_trace, aes(x = x, y = y), color = 'black', size = 1, alpha = 0.75) +
  geom_path(data = net_trace, aes(x = x, y = y), color = 'grey40', size = 1, lineend = 'round') +
  coord_fixed() +
  geom_point(aes(alpha = shot))  + 
  geom_path(  arrow = arrow(angle = 15)) +   
  facet_wrap(~rally.number) + xlab("Opponent Position X ") + ylab("Opponent Position Y") +
  ggtitle("Opponent start and end positions for for rallies 14 shots or longer")  
oppo.rally.paths <- ggplotly(oppo.rally.paths)
oppo.rally.paths
```

```{r}
library(gganimate)
library(tweenr)
library(transformr)
```
#player rally animation



```{r}
check_df <- filter(fed16_pos, rally.number == "9")
```

```{r}
longest_pos <- filter(fed16_pos, final.shot == 17)
longral_pos <- filter(fed16_pos, final.shot >= 10)
```


```{r}
seventythree_df <- filter(longral_pos, rally.number=="73")

```




```{r}
fed16_only[is.na(fed16_only)] <- 0

write.csv(longral_pos,"longral.csv")
write.csv(seventythree_df,"longest.csv")
write.csv(fed16_only, "data/fed16_only.csv")
```

##Glossary of added variables
Winter Research Project
lastshot - last shot in the point
fedhit - federer hits the shot
isserver - if server hits the shot
winner - if shot is winner (i.e. point doesn’t end in error, as opponent doesn’t reach the ball)
speed.diff - difference in current shot speed vs opponents last shot speed (at impact)
speed.ratio - shot speed/opponent’s previous shot speed
speed1 - speed of shot from impact with racquet
o.angle - angle made by opponents previous shot
p.angle - angle made by player’s current shot
lag.p.angle - angle made by player’s previous shot in rally
lag.speed.ratio - speed ratio of player’s previous shot in rally
oppo.hit - coordinates of opponents previous impact

Summer Research Project
winner.return.error - Classifies whether the current shot ended in winner, was returned into play or ended in error

rally.number - Numerical count of rally number within match

avg.player.speed.diff - difference in player and opponent average speed of movement from start of current shot to end of next in m/s

peak.player.speed.diff - difference in player and opponent peak speed of movement from start of current shot to end of next in m/s

avg.player.speed.ratio - ratio in player and opponent average speed of movement from start of current shot to end of next in m/s

peak.player.speed.ratio - ratio in player and opponent peak speed of movement from start of current shot to end of next in m/s

avg.player.acceleration.diff - difference in player and opponent average speed of movement from start of current shot to end of next in m/s

peak.player.acceleration.diff - difference of player and opponent avg acceleration during shot in m/s2.

avg.player.acceleration.ratio - ratio of player and opponent avg acceleration during shot in m/s2.

peak.player.acceleration.ratio - ratio of player and opponent peak acceleration during shot in m/s2.

p.avg.speed.match - players average speed of movement for the match in m/s

oppo.avg.speed.match - opponents average speed of movement for the match in m/s

p.diff.avg.shot.and.match.movement.speed - difference between players avereage movement speed for the current shot (from the start of the current shot to the end of the next) compared to their match average in m/s

oppo.diff.avg.shot.and.match.movement.speed - difference between opponents avereage movement speed for the current shot (from the start of the current shot to the end of the next) compared to their match average in m/s

p.rally.side.change.count - the number of times the player has run from the forehand(backhand) side to the backhand(forehand) side within the rally

oppo.rally.side.change.count - the number of times the opponent has run from the forehand(backhand) side to the backhand(forehand) side within the rally

rally.side.change.count.diff - the difference in the number of times the player and opponent have changed sides within the rally

rally.distance.run.ratio - the ratio player/opponent total distance run within the rally

p.movement.angle.1 - The angle the player runs from the start to the end of their current shot (o.deg directly towards the net 180.deg directly away from the net)

p.movement.angle.2 The angle the player runs from the end of their current shot to the start of their next shot (o.deg directly towards the net 180.deg directly away from the net)

oppo.movement.angle.1 - The angle the opponent runs from the start to the end of their current shot (o.deg directly towards the net 180.deg directly away from the net)

oppo.movement.angle.2 - The angle the opponent runs from the end of their current shot to the start of their next shot (o.deg directly towards the net 180.deg directly away from the net)

lag.oppo.height.off.net - Meters above net of opponents previous shot 

lag.p.start.shot.speed - Speed at the start of the arc in m/s of the players previous shot

lag.oppo.start.shot.speed - Speed at the start of the arc in m/s of the opponents previous shot







##Visualisation
```{r }
#player baseline/centre distance differentials


ggplot(longral_pos, aes(x=shot,y=p.start.position.base.diff)) +
  geom_point() +
  geom_path() + 
  geom_hline(yintercept = 0, linetype = "dotdash") + 
  facet_wrap(~rally.number) + 
  xlab("Shot Number")  + 
  ylab("Difference in distance from baseline Federer Vs Opponent") + 
  ggtitle("Federer vs Opponent difference in baseline distance in rallies 10 shots or more")

ggplot() + 
  geom_path(data=longral_pos, aes(x = shot, y = p.start.position.y, col="blue")) +
  geom_path(data=longral_pos, aes(x = shot, y = oppo.start.position.y, col="red")) +
  geom_hline(yintercept = 0, linetype = "dotdash") + 
  facet_wrap(~rally.number) + 
  xlab("Shot Number")  + 
  ylab("Distance from centre for Federer and Opponent") + 
  ggtitle("Federer vs Opponent distance from centre in rallies 10 shots or more") +
  scale_colour_manual(name = "Player", values=c("blue","red"), labels= c("Federer","Berdych"))
  
  
ggplot() + 
  geom_path(data=longral_pos, aes(x = shot, y = p.start.position.base.dist, 
                                  yend =p.end.position.base.dist, col="blue")) +
  geom_path(data=longral_pos, aes(x = shot, y = oppo.start.position.base.dist,
                                  yend =oppo.end.position.base.dist,col="red")) +
  geom_hline(yintercept = 0, linetype = "dotdash") + 
  facet_wrap(~rally.number) + 
  xlab("Shot Number")  + 
  ylab("Distance from baseline for Federer and Opponent") + 
  ggtitle("Federer vs Opponent distance from baseline in rallies 10 shots or more") +
  scale_colour_manual(name = "Player", values=c("blue","red"), labels= c("Federer","Berdych"))
```
```{r }
#speed/acceleration differentials
ggplot() + 
  geom_path(data=longral_df, aes(x = shot, y = p.avg.speed, col="blue")) +
  geom_path(data=longral_df, aes(x = shot, y = oppo.avg.speed, col="red")) + 
  facet_wrap(~rally.number) + 
  xlab("Shot Number")  + 
  ylab("Avg Movement Speed m/s  Federer and Opponent") + 
  ggtitle("Federer vs Opponent Avg Movement Speed in Rallies 10 shots or more") +
  scale_colour_manual(name = "Player", values=c("blue","red"), labels= c("Federer","Berdych"))

ggplot(longral_pos, aes(x=shot,y=avg.player.speed.diff)) +
  geom_path() + 
  geom_hline(yintercept = 0, linetype = "dotdash") + 
  facet_wrap(~rally.number) + 
  xlab("Shot Number")  + 
  ylab("Difference Avg Movement Speed m/s  Federer vs Opponent") + 
  ggtitle("Federer vs Opponent difference in Avg Movement Speed m/s  Federer and Opponent in rallies 10 shots or more")

```
```{r }
#Shot Type by coordinates
ggplot(dlb_fedonly, aes(x=start.x,y=start.y)) + 
  scale_x_continuous(breaks = axis_labels$x.break) +
    scale_y_continuous(breaks = axis_labels$y.break) +
    geom_path(data = court_trace, aes(x = x, y = y), color = 'black', size = 1, alpha = 0.75) +
    geom_path(data = net_trace, aes(x = x, y = y), color = 'grey40', size = 1, lineend = 'round') +
    coord_fixed() +
  geom_point() + 
  xlab("X Coordinate") + 
  ylab("Y Coordinate") + 
  ggtitle("Federer Down the Line Backhands By Shot Co-Ordinates") 

ggplot(iof_fedonly, aes(x=start.x,y=start.y)) + 
  scale_x_continuous(breaks = axis_labels$x.break) +
    scale_y_continuous(breaks = axis_labels$y.break) +
    geom_path(data = court_trace, aes(x = x, y = y), color = 'black', size = 1, alpha = 0.75) +
    geom_path(data = net_trace, aes(x = x, y = y), color = 'grey40', size = 1, lineend = 'round') +
    coord_fixed() +
  geom_point() + 
  xlab("X Coordinate") + 
  ylab("Y Coordinate") + 
  ggtitle("Federer Inside out Forehands By Shot Co-Ordinates") 

ggplot(dlw_fedonly, aes(x=start.x,y=start.y)) + 
  scale_x_continuous(breaks = axis_labels$x.break) +
    scale_y_continuous(breaks = axis_labels$y.break) +
    geom_path(data = court_trace, aes(x = x, y = y), color = 'black', size = 1, alpha = 0.75) +
    geom_path(data = net_trace, aes(x = x, y = y), color = 'grey40', size = 1, lineend = 'round') +
    coord_fixed() +
  geom_point() + 
  xlab("X Coordinate") + 
  ylab("Y Coordinate") + 
  ggtitle("Federer Down the Line Winners By Shot Co-Ordinates")
```


##Modelling

###Replicating some models from winter project

```{r }
#t1m1
library(depmixS4)
library(dplyr)

t1.mod1 <- depmix(winner ~ 1, transition = ~ oppo.speed + ser1 + ser2 + start.x, data = fed16_only, nstates = 2, family=multinomial("identity"))
t1.fm1 <- fit(t1.mod1)

summary(t1.fm1)
```

```{r}
library(depmixS4)
t2.mod1 <- depmix(list(winner ~ 1, speed.ratio ~ 1), transition = ~ oppo.speed + ser1 + ser2 + start.x + o.angle + oppo.hit.x + lag.p.angle + lag.speed.ratio, data = fed16_only, nstates = 2, family=list(multinomial("identity"), gaussian()))
t2.fm1<- fit(t2.mod1)
 
summary(t2.fm1)
```



#Modelling
Visual analysis has been used to select a number of new variables from the new data set. To extend upon the research conducted by Jeremy Forbes, winner has been chosen as the initial response variable.

Covariates are...
The covariates chosen are...(just try out shot index first)

Model training has been used to identify covariates which are useful for predicting the states of many different players.A training model has been created by using a stepwise approach to identify the best combination of covariates in a chosen match data set. This training model has then been tested on a different data set for a comparison of results. The limitation of this stepwise approach is that some potentially important covariates have been ommited from the model because of correlation with other covariates. 

#Training Models
The first training model has been made using stepwise for the match data Feder vs Berdych 2016. The best combination of covariates in order of importance are...


#Intepreting the output
##2 state Model
##3 State Models

#Building the Animation

Using the package GGAnimate and a topdown court outline taken from "https://github.com/mvparrot/vis-serve/blob/master/report file helper basic plots".
The variables p.start.positionition.x, p.end.position.x, oppo.start.position.x, oppo.end.position.x, p.start.positionition.y, p.end.position.y, oppo.start.position.y, oppo.end.position.y, start.x, start.y, projected.ballmark.x and projected.ballmark.y

transition_reveal has been used for filling in gaps in the player and ball position data. 
To run transition_reveal, a single column was created for the player's start & end postition x coordinates, they are grouped by rally number and shot number and alternate between start and end position. The same thing is done for the player's position y coordinates. As well as for the opponent's start and end position x and y coordinates. For animating the ball position, similar columns are created alternating between the start position of the ball and the projected ballmark for both x and y coordinates.

##Visualising player state change in the animation

#Variable creation

#Choosing variables for the model

```{r}
#Confirming choices through visualisation of all variabls described in glossary

```
p.start.position.x-
When compared to similar start position x coordinates, Federer appears more likely to hit a winner as he starts the shot closer to the net. Choosing this variable for HMM as we might expect that the probability of Federer being in an attacking state increases as he moves closer to the net( x value increases). 

p.start.position.y-
Choosing this variable for the HMM as it makes the players start position x coordinates more meaningful when included in the model. We might expect that the probability of Federer being in an attacking state increases as he moves closer to the centre(y value decreases) and to the net. Using absolute value to measure distance from centre.

```{r}

ggplot(fed16_only_plots, aes(x=p.start.position.x,  y=p.start.position.y ))    + 
  geom_path(data = court_trace, aes(x = x, y = y), color = 'black', size = 1, alpha = 0.75) +
  geom_path(data = net_trace, aes(x = x, y = y), color = 'grey40', size = 1, lineend = 'round') +
  coord_fixed() +
  geom_point(aes(alpha = winner))  +   
  xlab("Federer Start Position X ") + ylab("Federer Start Position Y") +
  ggtitle("Federer winners by start position")

ggplot(fed16_only, aes(x=p.start.position.x,winner)) + geom_smooth() + xlab("X Coordinate of Player") + ylab("Proportion of Winners") + ggtitle("Federer Winners By X Co-Ordinate")

ggplot(fed16_only, aes(x=p.start.position.y,winner)) + geom_smooth() + xlab("Distance from Centre of Player") + ylab("Proportion of Winners") + ggtitle("Federer Winners By Distance from Centre")
```



p.start.shot.x-
Similar to Federer's start position x coordinates, the x coordinates of his shot hitpoint appears more likely to result in a winner compared to similarly distanced shots as he moves closer to the net.

p.start.shot.y-
Including in HMM to make shot x coordinates more meaningful. Using absolute to measures distance from centre. 
```{r}
ggplot(fed16_only_plots, aes(x=p.start.shot.x,  y=p.start.shot.y ))    + 
  geom_path(data = court_trace, aes(x = x, y = y), color = 'black', size = 1, alpha = 0.75) +
  geom_path(data = net_trace, aes(x = x, y = y), color = 'grey40', size = 1, lineend = 'round') +
  coord_fixed() +
  geom_point(aes(alpha = winner))  +   
  xlab("Shot Position X ") + ylab("Shot Position Y") +
  ggtitle("Federer winners by shot location")
```



oppo.start.position.x-
Federer appears more likely to hit a winner as Berdych start position x coordinates are closer to the net. (As we are analysing the rallies with all of Berdychs having positive coordinates in the HMM we would expect a decrease in Berdychs start position x coordinates to increase The probability of Federer being in an attacking state. 
oppo.start.position.y
```{r}
ggplot(fed16_only_plots, aes(x=oppo.start.position.x,  y=oppo.start.position.y ))    + 
  scale_x_continuous(breaks = axis_labels$x.break) +
  scale_y_continuous(breaks = axis_labels$y.break) +
  geom_path(data = court_trace, aes(x = x, y = y), color = 'black', size = 1, alpha = 0.75) +
  geom_path(data = net_trace, aes(x = x, y = y), color = 'grey40', size = 1, lineend = 'round') +
  coord_fixed() +
  geom_point(aes(alpha = winner))  +   
  xlab("Opponent Start Position X ") + ylab("Opponent Start Position Y") +
  ggtitle("Federer winners by Opponent Start Position")

ggplot(fed16_only, aes(x=oppo.start.position.x,winner)) + geom_smooth() + xlab("X Coordinate of Opponent") + ylab("Proportion of Federer Winners") + ggtitle("Federer Winners By Opponent X Co-Ordinate")

ggplot(fed16_only, aes(x=oppo.start.position.y,winner)) + geom_smooth() + xlab("Distance from Centre of Opponent") + ylab("Proportion of Winners") + ggtitle("Federer Winners by Opponent Distance from Centre")
```


p.diff.avg.shot.and.match.movement.speed - 
When Federer runs approximately more than 1m/s above or below his average movement speed for match he tends to hit more winners. This variable therefore appears suitable for the HMM. (Using an absolute value of the difference we would expect an increase in difference to increase the probability of Federer being in a attacking state. (add in more info)
When Considering winners, errors and returns we move back to relative difference as Federer tends to hit more errors than winners when moving approximately 1m/s slower than his avereage match movement speed 
```{r}
ggplot(fed16_only_plots, aes(x=factor(winner),y=p.diff.avg.shot.and.match.movement.speed, fill=factor(winner))) + geom_boxplot() + ggtitle("Winner by difference in Federer's current and match avg movement speed")

ggplot(fed16_only_plots, aes(x=factor(winner),y=p.diff.avg.shot.and.match.movement.speed, fill=factor(winner))) + geom_violin(scale = "area") + ggtitle("Winner by difference in Federer's current and match avg movement speed")


ggplot(fed16_only_plots, aes(x=factor(winner.return.error),y=(p.diff.avg.shot.and.match.movement.speed), fill=factor(winner.return.error))) + geom_violin(scale = "area") + ggtitle("Winner by absolute difference in Federer's current/match avg movement speed")
```


oppo.diff.avg.shot.and.match.movement.speed - 
Federer tends to hit more winners as Berdych runs more than 1m/s faster than his average match movement speed. This is a suitable variable for the HMM we would expect an increase in the difference to increae Federers probability of being in an attacking state. 
```{r}
ggplot(fed16_only_plots, aes(x=factor(winner),y=oppo.diff.avg.shot.and.match.movement.speed, fill=factor(winner))) + geom_boxplot() + ggtitle("Winner by difference in Opponent current/match avg movement speed")

ggplot(fed16_only_plots, aes(x=factor(winner),y=oppo.diff.avg.shot.and.match.movement.speed, fill=factor(winner))) + geom_violin(scale = "area") + ggtitle("Winner by difference in Opponent current/match avg movement speed")

# ggplot(fed16_only_plots, aes(x=factor(winner.return.error),y=oppo.diff.avg.shot.and.match.movement.speed, fill=factor(winner.return.error))) + geom_violin(scale = "area") + ggtitle("Winner by difference in Opponent current/match avg movement speed")

```

p.rally.side.change.count - 
Not suitable
```{r}
ggplot(fed16_only_plots, aes(x=p.rally.side.change.count, y=winner)) + geom_bar(stat="identity") + xlab("Rally Side Change Count") + ylab("Proportion of Winners") + ggtitle("Winners By Number of Times Federer Changes Side in Rally")
```


oppo.rally.side.change.count - 
Might be suitable when looking at a greater number of rallies. 
```{r}
ggplot(fed16_only_plots, aes(x=oppo.rally.side.change.count, y=winner)) + geom_bar(stat="identity") + xlab("Rally Side Change Count") + ylab("Proportion of Winners") + ggtitle("Winners By Number of Times Berdych Changes Side in Rally")

```


p.movement.angle.1 - 
 more than 75% of Federers Winners come when he is running less than 100 degrees in relation to the baseline. This varaiable appears suitable for HMM we would expect as Federers movement angle increases beyond 100 degrees the probability the he is an attacking state decreases.
```{r}
ggplot(fed16_only_plots, aes(x=p.movement.angle.1,y=winner)) + geom_smooth() + xlab("Angle Made By Federer's movement") + ylab("Proportion of Winners") + ggtitle("Winners By Federer's start to end movement angle")

ggplot(fed16_only, aes(x=factor(winner),y=p.movement.angle.1, fill=factor(winner))) + geom_boxplot() + ggtitle("Winner by Federer's start to end movement angle")

ggplot(fed16_only, aes(x=factor(winner),y=p.movement.angle.1, fill=factor(winner))) + geom_violin(scale = "area") + ggtitle("Winner by Federer's start to end movement angle")

# ggplot(fed16_only, aes(x=factor(winner.return.error),y=p.movement.angle.1, fill=factor(winner.return.error))) + geom_violin(scale = "area") + ggtitle("Winner by Federer's start to end movement angle")
```


oppo.movement.angle.1 - 
Need more evidence to include in model
```{r}
ggplot(fed16_only_plots, aes(x=oppo.movement.angle.1,y=winner)) + geom_smooth() + xlab("Angle Made By Berdych's movement") + ylab("Proportion of Winners") + ggtitle("Winners By Berdych's start to end movement angle during Federer's shot")

ggplot(fed16_only, aes(x=factor(winner),y=oppo.movement.angle.1, fill=factor(winner))) + geom_boxplot() + ggtitle("Winner by Berdych's start to end movement angle during Federer's shot")

ggplot(fed16_only, aes(x=factor(winner),y=oppo.movement.angle.1, fill=factor(winner))) + geom_violin(scale = "area") + ggtitle("Winner by Berdych's start to end movement angle during Federer's shot")

```


lag.oppo.height.off.net - 
Federer tends to hit more winners when incoming shot approaches 50cm off the height of the net. This decreases as the height of the incoming shot increases or decreases. Including this variable in the HMM. Expect the coeficcient to be small. 

```{r}
ggplot(fed16_only_plots, aes(x=lag.oppo.height.off.net,y=winner)) + geom_smooth() + xlab("Height of opponents shot") + ylab("Proportion of Winners") + ggtitle("Winners by Height over Net of Most recent Opponent shot")


```

diff.p.avg.and.current.shot.speed
```{r}


ggplot(fed16_only, aes(x=factor(winner),y=diff.p.avg.and.current.shot.speed, fill=factor(winner))) + geom_boxplot() + ggtitle("Winner by player current/average shot speed difference")



```






```{r}
ggplot(longral_pos, aes(x=shot,y=p.start.position.base.diff)) +
  geom_point() +
  geom_path() + 
  geom_hline(yintercept = 0, linetype = "dotdash") + 
  facet_wrap(~rally.number) + 
  xlab("Shot Number")  + 
  ylab("Difference in distance from baseline Federer Vs Opponent") + 
  ggtitle("Federer vs Opponent difference in baseline distance in rallies 10 shots or more")

ggplot() + 
  geom_path(data=longral_pos, aes(x = shot, y = p.start.position.y, col="blue")) +
  geom_path(data=longral_pos, aes(x = shot, y = oppo.start.position.y, col="red")) +
  geom_hline(yintercept = 0, linetype = "dotdash") + 
  facet_wrap(~rally.number) + 
  xlab("Shot Number")  + 
  ylab("Distance from centre for Federer and Opponent") + 
  ggtitle("Federer vs Opponent distance from centre in rallies 10 shots or more") +
  scale_colour_manual(name = "Player", values=c("blue","red"), labels= c("Federer","Berdych"))
  
  
ggplot() + 
  geom_path(data=longral_pos, aes(x = shot, y = p.start.position.base.dist, 
                                  yend =p.end.position.base.dist, col="blue")) +
  geom_path(data=longral_pos, aes(x = shot, y = oppo.start.position.base.dist,
                                  yend =oppo.end.position.base.dist,col="red")) +
  geom_hline(yintercept = 0, linetype = "dotdash") + 
  facet_wrap(~rally.number) + 
  xlab("Shot Number")  + 
  ylab("Distance from baseline for Federer and Opponent") + 
  ggtitle("Federer vs Opponent distance from baseline in rallies 10 shots or more") +
  scale_colour_manual(name = "Player", values=c("blue","red"), labels= c("Federer","Berdych"))
```

```{r }
#Shot Type by coordinates
ggplot(dlb_fedonly, aes(x=start.x,y=start.y)) + 
  scale_x_continuous(breaks = axis_labels$x.break) +
    scale_y_continuous(breaks = axis_labels$y.break) +
    geom_path(data = court_trace, aes(x = x, y = y), color = 'black', size = 1, alpha = 0.75) +
    geom_path(data = net_trace, aes(x = x, y = y), color = 'grey40', size = 1, lineend = 'round') +
    coord_fixed() +
  geom_point() + 
  xlab("X Coordinate") + 
  ylab("Y Coordinate") + 
  ggtitle("Federer Down the Line Backhands By Shot Co-Ordinates") 

ggplot(iof_fedonly, aes(x=start.x,y=start.y)) + 
  scale_x_continuous(breaks = axis_labels$x.break) +
    scale_y_continuous(breaks = axis_labels$y.break) +
    geom_path(data = court_trace, aes(x = x, y = y), color = 'black', size = 1, alpha = 0.75) +
    geom_path(data = net_trace, aes(x = x, y = y), color = 'grey40', size = 1, lineend = 'round') +
    coord_fixed() +
  geom_point() + 
  xlab("X Coordinate") + 
  ylab("Y Coordinate") + 
  ggtitle("Federer Inside out Forehands By Shot Co-Ordinates") 

ggplot(dlw_fedonly, aes(x=start.x,y=start.y)) + 
  scale_x_continuous(breaks = axis_labels$x.break) +
    scale_y_continuous(breaks = axis_labels$y.break) +
    geom_path(data = court_trace, aes(x = x, y = y), color = 'black', size = 1, alpha = 0.75) +
    geom_path(data = net_trace, aes(x = x, y = y), color = 'grey40', size = 1, lineend = 'round') +
    coord_fixed() +
  geom_point() + 
  xlab("X Coordinate") + 
  ylab("Y Coordinate") + 
  ggtitle("Federer Down the Line Winners By Shot Co-Ordinates")
```