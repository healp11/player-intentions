---
title: "Rallies Depmix Models"
author: "Pat Healy"
date: "30 January 2019"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
#Run rallies.Rmd before reading fed16_only.csv
library(readr)
library(ggplot2)
fed16_only <-  read.csv(file = "data/fed16_only.csv")
```

#Stepwise function to find best variables for Depmix model
```{r}
library(dplyr)

#choosing variables of interest
fed16_dep <- fed16_only[, c( "p.start.position.x", "p.start.position.y", "oppo.start.position.x", "oppo.start.position.y", "p.movement.angle.1", "p.start.shot.x", "p.start.shot.y", "lag.p.angle", "rally.side.change.count.diff", "p.diff.avg.shot.and.match.movement.speed",  "oppo.diff.avg.shot.and.match.movement.speed", "diff.p.avg.and.current.shot.speed", "lag.diff.oppo.avg.and.current.shot.speed")]




```


```{r}
#scaling variables from 0 min to 1 max for comparison to hidden states plot
fed16_scale <- fed16_only[, c(  "p.start.position.x", "p.start.position.y", "oppo.start.position.x", "oppo.start.position.y", "p.movement.angle.1", "p.start.shot.x", "p.start.shot.y", "lag.p.angle", "rally.side.change.count.diff", "p.diff.avg.shot.and.match.movement.speed",  "oppo.diff.avg.shot.and.match.movement.speed", "diff.p.avg.and.current.shot.speed", "lag.diff.oppo.avg.and.current.shot.speed")]

fed16_scale <- as.data.frame(lapply(fed16_dep[c( "p.start.position.x", "p.start.position.y", "oppo.start.position.x", "oppo.start.position.y", "p.movement.angle.1", "p.start.shot.x", "p.start.shot.y", "lag.p.angle", "rally.side.change.count.diff", "p.diff.avg.shot.and.match.movement.speed",  "oppo.diff.avg.shot.and.match.movement.speed", "diff.p.avg.and.current.shot.speed", "lag.diff.oppo.avg.and.current.shot.speed")], function(x) (x-min(x))/(max(x)-min(x))))

fed16_scale <- cbind(fed16_scale, winner = fed16_only$winner)

fed16_scale <- fed16_scale %>% mutate(player.total.shot.number = row_number())
```



```{r}
library(depmixS4)
library(purrr)
library(MmgraphR)

```

#Looking for any correlation between chosen variables greater than 50%
```{r}
corMat <- cor(fed16_dep)
corMat_df <- as.data.frame(apply(corMat, 2, function(x) ifelse (abs(x) >=0.5,x,"NA")))
#Removed some variables with significant correlation with other variables above 50%:
#p.end.position.x, p.end.position.y, oppo.end.position.x, oppo.end.position.y, p.rally.side.change.count,oppo.rally.side.change.count, p.advantage, p.distance, oppo.distance, fhand, p.advantage, rally.distance.run.ratio, shot
```

```{r}

#check significance if any correlation found
 # cor.test(formula = ~ p.diff.avg.shot.and.match.movement.speed + oppo.diff.avg.shot.and.match.movement.speed,
 #          data = fed16_only)


```
#Glossary of chosen variables

"p.start.position.x": Numeric x location of player at the start of the shot.
"p.start.position.y": Numeric y location of player at the start of the shot.    
"oppo.start.position.x": Numeric x location of opponent at the start of the shot. 
"oppo.start.position.y": Numeric y location of opponent at the start of the shot.
: 
"p.diff.avg.shot.and.match.movement.speed": 
"p.movement.angle.1": 
"p.start.shot.x": Numerical x coordinate of the ball at the start of its arc for players shot.
"p.start.shot.y": Numerical y coordinate of the ball at the start of its arc for players shot.
"lag.p.angle": Angle made by player’s previous shot in rally.
"lag.speed.ratio": Speed ratio of player’s previous shot in rally.
"rally.side.change.count.diff":

#Stepwise to find best variables for Depmix
##Stepwise for first best variable

```{r}

#run through all variables to find highest log lik
fcov1 <- lapply(fed16_scale[c( "p.start.position.x", "p.start.position.y", "oppo.start.position.x", "oppo.start.position.y", "p.diff.avg.shot.and.match.movement.speed", "p.movement.angle.1", "p.start.shot.x", "p.start.shot.y", "lag.p.angle", "lag.speed.ratio", "rally.side.change.count.diff")], function(w) fit((depmix(winner ~ 1, data = fed16_only, transition = ~ w, nstates = 2, family=multinomial("identity"))), verbose = FALSE, emc=em.control(rand=TRUE)))

fcov1_df <-  as.data.frame(
  c(logLik(fcov1$p.start.position.x), logLik(fcov1$p.start.position.y),
    logLik(fcov1$oppo.start.position.x), logLik(fcov1$oppo.start.position.y),
     logLik(fcov1$p.diff.avg.shot.and.match.movement.speed),
    logLik(fcov1$p.movement.angle.1), logLik(fcov1$p.start.shot.x), logLik(fcov1$p.start.shot.y),
    logLik(fcov1$lag.p.angle), logLik(fcov1$lag.speed.ratio),
    logLik(fcov1$rally.side.change.count.diff))
  )

fcov1_df$newcolumn<-c( "p.start.position.x", "p.start.position.y", "oppo.start.position.x", "oppo.start.position.y", "p.diff.avg.shot.and.match.movement.speed", "p.movement.angle.1", "p.start.shot.x", "p.start.shot.y", "lag.p.angle", "lag.speed.ratio", "rally.side.change.count.diff")

names(fcov1_df) <- c("convergence.loglik", "Variables")


fcov1_df %>% 
   slice(which.max(convergence.loglik))

```




###First best variable is p.start.position.x
```{r}
#Running single variable model of p.start.position.x to look at coefficients

mod1 <- depmix(winner ~ 1, transition = ~ p.start.position.x, data = fed16_scale, nstates = 2, family=multinomial("identity"))
fm1 <- fit(mod1)

summary(fm1)


```



```{r}
#Graphing fitted model states for first best variables

probs = posterior(fm1)

	layout(1:2)
	plot(probs$state, type='s', main='Implied States', xlab='', ylab='State')
	
	matplot(probs[,-1], type='l', main='Probabilities', ylab='Probability')
		legend(x='topright', c('State1','State2'),  fill=1:2, bty='n')
```


##Stepwise to find second best variable

```{r}
library(depmixS4)
fcov2 <- lapply(fed16_dep[c( "p.start.position.y", "oppo.start.position.x", "oppo.start.position.y", "p.diff.avg.shot.and.match.movement.speed", "p.movement.angle.1", "p.start.shot.x", "p.start.shot.y", "lag.p.angle", "lag.speed.ratio", "rally.side.change.count.diff")], function(w) fit((depmix(winner ~ 1, data = fed16_only, transition = ~ p.start.position.x + w, nstates = 2, family=multinomial("identity"))), verbose = FALSE, emc=em.control(rand=TRUE)))

fcov2_df <-  as.data.frame(
  c(logLik(fcov2$shot), logLik(fcov1$p.start.position.y),
    logLik(fcov1$oppo.start.position.x), logLik(fcov1$oppo.start.position.y),
     logLik(fcov1$p.diff.avg.shot.and.match.movement.speed),
    logLik(fcov1$p.movement.angle.1), logLik(fcov1$p.start.shot.x), logLik(fcov1$p.start.shot.y),
    logLik(fcov1$lag.p.angle), logLik(fcov1$lag.speed.ratio),
    logLik(fcov1$rally.side.change.count.diff))
  )

fcov2_df$newcolumn<-c( "p.start.position.y", "oppo.start.position.x", "oppo.start.position.y", "p.diff.avg.shot.and.match.movement.speed", "p.movement.angle.1", "p.start.shot.x", "p.start.shot.y", "lag.p.angle", "lag.speed.ratio", "rally.side.change.count.diff")

names(fcov2_df) <- c("convergence.loglik", "Variables")

fcov2_df %>% 
   slice(which.max(convergence.loglik))


```

##Stepwise to find the third best variable
```{r}
#second best variable is oppo.start.position.x
library(depmixS4)
fcov3 <- lapply(fed16_dep[c( "p.start.position.y", "oppo.start.position.y", "p.diff.avg.shot.and.match.movement.speed", "p.movement.angle.1", "p.start.shot.x", "p.start.shot.y", "lag.p.angle", "lag.speed.ratio", "rally.side.change.count.diff")], function(w) fit((depmix(winner ~ 1, data = fed16_only, transition = ~ p.start.position.x + oppo.start.position.x + w, nstates = 2, family=multinomial("identity"))), verbose = FALSE, emc=em.control(rand=TRUE)))

fcov3_df <-  as.data.frame(
  c( logLik(fcov1$p.start.position.y), logLik(fcov1$oppo.start.position.y),
     logLik(fcov1$p.diff.avg.shot.and.match.movement.speed),
    logLik(fcov1$p.movement.angle.1), logLik(fcov1$p.start.shot.x), logLik(fcov1$p.start.shot.y),
    logLik(fcov1$lag.p.angle), logLik(fcov1$lag.speed.ratio),
    logLik(fcov1$rally.side.change.count.diff))
  )

fcov3_df$newcolumn<-c( "p.start.position.y", "oppo.start.position.y", "p.diff.avg.shot.and.match.movement.speed", "p.movement.angle.1", "p.start.shot.x", "p.start.shot.y", "lag.p.angle", "lag.speed.ratio", "rally.side.change.count.diff")

names(fcov3_df) <- c("convergence.loglik", "Variables")

fcov3_df %>% 
   slice(which.max(convergence.loglik))
```
##Stepwise to find the fourth best variable

```{r}
library(depmixS4)
#third best variable is 
fcov4 <- lapply(fed16_dep[c( "p.start.position.y", "oppo.start.position.y", "p.movement.angle.1", "p.start.shot.x", "p.start.shot.y", "lag.p.angle", "lag.speed.ratio", "rally.side.change.count.diff")], function(w) fit((depmix(winner ~ 1, data = fed16_only, transition = ~ p.start.position.x + oppo.start.position.x +  w, nstates = 2, family=multinomial("identity"))), verbose = FALSE, emc=em.control(rand=TRUE)))
```
##Stepwise to find fifth best variable
```{r}
#fourth best variable is rally.side.change.count.diff



fcov5 <- lapply(fed16_dep[c( "p.start.position.y", "oppo.start.position.y", "p.movement.angle.1", "p.start.shot.x", "p.start.shot.y", "lag.p.angle", "lag.speed.ratio")], function(w) fit((depmix(winner ~ 1, data = fed16_only, transition = ~ p.start.position.x + oppo.start.position.x +  rally.side.change.count.diff + w, nstates = 2, family=multinomial("identity"))), verbose = FALSE, emc=em.control(rand=TRUE)))
```




##Stepwise to find sixth best variable
```{r}
#fifth best variable is p.start.shot.x


fcov6 <- lapply(fed16_dep[c( "p.start.position.y", "oppo.start.position.y", "p.movement.angle.1", "p.start.shot.y", "lag.p.angle", "lag.speed.ratio")], function(w) fit((depmix(winner ~ 1, data = fed16_only, transition = ~ p.start.position.x + oppo.start.position.x +  rally.side.change.count.diff + p.start.shot.x + w, nstates = 2, family=multinomial("identity"))), verbose = FALSE, emc=em.control(rand=TRUE)))
```


##Stepwise to find seventh best variable
```{r}
#sixth best variable is p.movement.angle.1


fcov7 <- lapply(fed16_dep[c( "p.start.position.y", "oppo.start.position.y", "p.start.shot.y", "lag.p.angle", "lag.speed.ratio")], function(w) fit((depmix(winner ~ 1, data = fed16_only, transition = ~ p.start.position.x + oppo.start.position.x +  rally.side.change.count.diff + p.start.shot.x + p.movement.angle.1 + w, nstates = 2, family=multinomial("identity"))), verbose = FALSE, emc=em.control(rand=TRUE)))
```





##Stepwise to find eighth best variable
```{r}
#seventh best variable is p.start.position.y


fcov8 <- lapply(fed16_dep[c( "oppo.start.position.y", "p.start.shot.y", "lag.p.angle", "lag.speed.ratio")], function(w) fit((depmix(winner ~ 1, data = fed16_only, transition = ~ p.start.position.x + oppo.start.position.x +  rally.side.change.count.diff + p.start.shot.x + p.movement.angle.1 + p.start.position.y + w, nstates = 2, family=multinomial("identity"))), verbose = FALSE, emc=em.control(rand=TRUE)))
```

##Stepwise to find ninth best variable
```{r}
#eigth best variable is lag.p.angle


fcov9 <- lapply(fed16_dep[c( "oppo.start.position.y", "p.start.shot.y", "lag.speed.ratio")], function(w) fit((depmix(winner ~ 1, data = fed16_only, transition = ~ p.start.position.x + oppo.start.position.x +  rally.side.change.count.diff + p.start.shot.x + p.movement.angle.1 + p.start.position.y + lag.p.angle + w, nstates = 2, family=multinomial("identity"))), verbose = FALSE, emc=em.control(rand=TRUE)))
```

##Stepwise to find tenth best variable
```{r}
#ninth best variable is avg.player.speed.ratio


fcov10 <- lapply(fed16_dep[c( "oppo.start.position.y", "p.start.shot.y", "lag.speed.ratio")], function(w) fit((depmix(winner ~ 1, data = fed16_only, transition = ~ p.start.position.x + oppo.start.position.x +  rally.side.change.count.diff + p.start.shot.x + p.movement.angle.1 + p.start.position.y + lag.p.angle +  w, nstates = 2, family=multinomial("identity"))), verbose = FALSE, emc=em.control(rand=TRUE)))
```
##Stepwise to find eleventh best variable
```{r}
#tenth best variable is removed


fcov11 <- lapply(fed16_dep[c("oppo.start.position.y", "p.start.shot.y", "lag.speed.ratio")], function(w) fit((depmix(winner ~ 1, data = fed16_only, transition = ~ p.start.position.x + oppo.start.position.x +  rally.side.change.count.diff + p.start.shot.x + p.movement.angle.1 + p.start.position.y + lag.p.angle +   w, nstates = 2, family=multinomial("identity"))), verbose = FALSE, emc=em.control(rand=TRUE)))
```

##stepwise to find twelth best variable
```{r}
#eleventh best variable is lag.speed.ratio


fcov12 <- lapply(fed16_dep[c("oppo.start.position.y", "p.start.shot.y")], function(w) fit((depmix(winner ~ 1, data = fed16_only, transition = ~ p.start.position.x + oppo.start.position.x +  rally.side.change.count.diff + p.start.shot.x + p.movement.angle.1 + p.start.position.y + lag.p.angle +   lag.speed.ratio + w, nstates = 2, family=multinomial("identity"))), verbose = FALSE, emc=em.control(rand=TRUE)))

#12th best is oppo.start.position.y 13th best is p.start.shot.y
```




#Fitted Depmix Model for the best thirteen variable model
```{r}
#
#

mod3 <- depmix(winner ~ 1, transition = ~p.start.position.x + oppo.start.position.x +  rally.side.change.count.diff + p.start.shot.x + p.movement.angle.1 + p.start.position.y + lag.p.angle +   lag.speed.ratio , data = fed16_scale, nstates = 2, family=multinomial("identity"))
fm3 <- fit(mod3)

summary(fm3)
```

###Graphing fitted models of best stepwise variables



```{r}
#Fitted states for best thirteen variable model
#p.start.position.x + oppo.start.position.x +  rally.side.change.count.diff + p.start.shot.x + p.movement.angle.1 + p.start.position.y + lag.p.angle +   lag.speed.ratio + oppo.start.position.y + p.start.shot.y
probs = posterior(fm3)

	layout(1:2)
	plot(probs$state, type='s', main='Implied States', xlab='', ylab='State')
	
	matplot(probs[,-1], type='l', main='Probabilities', ylab='Probability')
		legend(x='topright', c('State1','State2'),  fill=1:2, bty='n')
		
	
```


###Visualising chosen variables to compare to hidden states model

```{r}

#question max in the game is note max  possible (ie 1 is a few metres back from the net)
	
attach(fed16_scale)
par(mfrow=c(2,1))

ggplot() + 
  geom_path(data=fed16_scale, aes(x = player.total.shot.number, y = p.start.position.x)) +
  xlab("Federer shot Number")  + 
  ylab(" Federer start position x coordinates for Federer shots") + 
  ggtitle("Federer 2016 start position x coordinates scaled") 
  

ggplot() + 
  geom_path(data=fed16_scale, aes(x = player.total.shot.number, y = oppo.start.position.x)) +
  xlab("Federer shot Number")  + 
  ylab(" Opponent start position x coordinates for Federer shots") + 
  ggtitle("Federer 2016 opponent start position x coordinates scaled") 
   
```

```{r}
library(tidyr)
fed16_plot1<- fed16_scale %>%
  gather(key = vars, value = measurement, p.start.position.x, oppo.start.position.x, avg.player.speed.ratio, rally.side.change.count.diff)

fed16_plot2<- fed16_scale %>%
  gather(key = vars, value = measurement, p.start.shot.x, p.movement.angle.1, p.start.position.y, lag.p.angle)

fed16_plot3<- fed16_scale %>%
  gather(key = vars, value = measurement, avg.player.speed.ratio, lag.speed.ratio, oppo.start.position.y, p.start.shot.y)

ggplot(fed16_plot1, aes(x=player.total.shot.number,y=measurement)) + geom_line(color="blue") + facet_grid(vars~., scale="free_y") + xlab("Time") + ggtitle("Federer vs. Berdych 2016: Looking at how variables move together over the match")

ggplot(fed16_plot2, aes(x=player.total.shot.number,y=measurement)) + geom_line(color="blue") + facet_grid(vars~., scale="free_y") + xlab("Time") + ggtitle("Federer vs. Berdych 2016: Looking at how variables move together over the match")

ggplot(fed16_plot3, aes(x=player.total.shot.number,y=measurement)) + geom_line(color="blue") + facet_grid(vars~., scale="free_y") + xlab("Time") + ggtitle("Federer vs. Berdych 2016: Looking at how variables move together over the match")

```


#test loop for depmix


##single variable models using map function
```{r}
#for use with loop
# library(depmixS4)
# fed16_dep %>%
#   map(function(w)  fit((depmix(winner ~ 1, data = fed16_only, transition = ~ w, nstates = 2, family=multinomial("identity"))), verbose = FALSE, emc=em.control(rand=TRUE)) )
#  
```

```{r}

#model to automate stepwise crashes becuase of correlation between variables
# recursive.factorial <- function(x) {
# if (x == 0)    return (1)
# else           return (x * recursive.factorial(x-1))
# }

# loop_data <- fed16_only[, c("winner",   "p.start.position.x",    "p.start.position.y",     "oppo.start.position.x", "oppo.start.position.y",      "p.work", "oppo.work",    "p.diff.avg.shot.and.match.movement.speed",       "p.movement.angle.1", "p.movement.angle.2", "oppo.movement.angle.2", "p.start.shot.x", "p.start.shot.y", "lag.p.angle", "lag.speed.ratio")]
# 
# next_best_var <- function(data, column = NULL){
#   # if we know what variable to remove, remove it
#   if (!is.null(column)){
#     data <- data[, names(data) != column]
#   }
#   #if 1 variable remaining, add to model
#   if (ncol(data) == 1){
#     return(colnames(data))
#   }
#   #map over all available columns
#   
#   
#   
#   
#   
# }
# 
# inside_func <- function(data, x){
#   fm <- fit(depmix(winner ~ 1, data = data, transition = ~ x, nstates = 2, family=multinomial("identity")))
#   
#   
#   
#   }
# 
# # for every possible variable in data set
# Loop_trial <- ha %>% map(function(data,x) 
#   t6.mod41 <- depmix(winner ~ 1, data = fed16_only, transition = ~ x, nstates = 2, family=multinomial("identity")))
#  t6.fm41<- fit(t6.mod41)
#  
# 
#  t6.fm41
 
 
```
